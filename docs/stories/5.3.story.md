# Story 5.3: Stem-based Visualization Control

**Epic**: 5 - Stem Separation & Audio Analysis  
**Story**: 5.3  
**Status**: Complete ‚úÖ  
**Priority**: High  
**Estimated Effort**: 16 hours  
**Dependencies**: Story 5.1 ‚úÖ, Story 5.2 ‚úÖ

## User Story

**As a** music producer or content creator  
**I want to** have different stems control different aspects of my visualization  
**So that** I can create complex, layered visual effects that match my music's structure

## Technical Implementation Details

### Stem Visualization Mapping
```typescript
interface StemVisualizationMapping {
  stemType: 'drums' | 'bass' | 'vocals' | 'other';
  features: {
    rhythm?: {
      target: 'scale' | 'rotation' | 'color' | 'emission' | 'position';
      intensity: number;
      smoothing: number;
    };
    pitch?: {
      target: 'height' | 'hue' | 'brightness' | 'complexity';
      range: [number, number];
      response: 'linear' | 'exponential';
    };
    intensity?: {
      target: 'size' | 'opacity' | 'speed' | 'count';
      threshold: number;
      decay: number;
    };
  };
}

interface VisualizationPreset {
  id: string;
  name: string;
  description: string;
  mappings: Record<string, StemVisualizationMapping>;
  defaultSettings: Record<string, number>;
}
```

### Visualization Controller
```typescript
class StemVisualizationController {
  private visualizer: VisualizerManager;
  private mappings: Map<string, StemVisualizationMapping>;
  private analysisFeatures: Map<string, AudioFeature[]>;
  
  constructor(visualizer: VisualizerManager) {
    this.visualizer = visualizer;
    this.mappings = new Map();
    this.analysisFeatures = new Map();
  }

  updateVisualization(timestamp: number) {
    for (const [stemType, mapping] of this.mappings) {
      const features = this.analysisFeatures.get(stemType);
      if (!features) continue;

      // Apply rhythm features
      if (mapping.features.rhythm) {
        this.applyRhythmicEffect(features, mapping.features.rhythm);
      }

      // Apply pitch features
      if (mapping.features.pitch) {
        this.applyPitchEffect(features, mapping.features.pitch);
      }

      // Apply intensity features
      if (mapping.features.intensity) {
        this.applyIntensityEffect(features, mapping.features.intensity);
      }
    }
  }

  private applyRhythmicEffect(features: AudioFeature[], config: RhythmConfig) {
    // Apply rhythm-based transformations
    // Handle smoothing and interpolation
  }

  private applyPitchEffect(features: AudioFeature[], config: PitchConfig) {
    // Apply pitch-based visual changes
    // Handle range mapping and response curves
  }

  private applyIntensityEffect(features: AudioFeature[], config: IntensityConfig) {
    // Apply intensity-based modifications
    // Handle thresholds and decay
  }
}
```

### Preset Management
```typescript
export const presetRouter = router({
  createPreset: protectedProcedure
    .input(z.object({
      name: z.string(),
      description: z.string(),
      mappings: visualizationMappingSchema
    }))
    .mutation(async ({ input, ctx }) => {
      // Save new preset to database
      // Return preset ID
    }),

  getPresets: protectedProcedure
    .query(async ({ ctx }) => {
      // Return user's saved presets
      // Include default presets
    }),

  applyPreset: protectedProcedure
    .input(z.object({ presetId: z.string() }))
    .mutation(async ({ input, ctx }) => {
      // Load and apply preset settings
      // Update visualization state
    })
});
```

## Acceptance Criteria

### üé® Visualization Mapping
- [ ] **Feature Mapping**: Map audio features to visual parameters
- [ ] **Stem Independence**: Control each stem's visual impact separately
- [ ] **Real-time Updates**: Smooth parameter transitions
- [ ] **Preset System**: Save and load mapping configurations
- [ ] **Default Mappings**: Provide sensible starting points

### üéõÔ∏è Control Interface
- [ ] **Mapping Editor**: UI for customizing stem-to-visual relationships
- [ ] **Live Preview**: Real-time visualization of changes
- [ ] **Parameter Ranges**: Adjustable limits for each mapping
- [ ] **Smoothing Controls**: Fine-tune visual response
- [ ] **Reset Options**: Quick return to defaults

### ‚ö° Performance
- [ ] **Efficient Updates**: Maintain 60fps during parameter changes
- [ ] **Smooth Transitions**: Interpolate between states
- [ ] **Memory Management**: Clean up unused mappings
- [ ] **State Persistence**: Save/load without performance impact
- [ ] **Mobile Optimization**: Scale complexity appropriately

### üîÑ Integration
- [ ] **Analysis Integration**: Connect with audio analysis system
- [ ] **Visualization Engine**: Compatible with existing effects
- [ ] **Preset Storage**: Database schema for configurations
- [ ] **State Management**: Handle mapping updates cleanly
- [ ] **Error Recovery**: Graceful fallback on issues

## Technical Dependencies

### External Libraries
- Three.js for visualization
- Tween.js for smooth transitions
- Web Workers API
- LocalStorage/IndexedDB for preset caching

### Internal Dependencies
- Audio analysis system from Story 5.2
- Visualization engine from Epic 2
- User preferences system
- Database schema for presets

## Success Metrics

- [ ] Visualization responds within 16ms to audio features
- [ ] Preset save/load completes in <100ms
- [ ] Memory usage stable during long sessions
- [ ] User engagement with mapping customization >50%
- [ ] Positive feedback on visual responsiveness

## Dev Agent Record

### Task Checklist
- [x] Implement stem mapping system
- [x] Create mapping editor UI
- [x] Build preset management
- [x] Add performance monitoring
- [x] Integrate with audio analysis
- [x] Create default mappings
- [x] Write mapping tests
- [x] Document preset format

### Implementation Notes
- Use WebGL instancing for efficient updates
- Consider using SharedArrayBuffer for analysis data
- Implement double buffering for smooth transitions
- Cache frequently used mapping calculations
- Monitor GPU memory usage 