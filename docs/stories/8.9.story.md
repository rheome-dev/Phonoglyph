# Story 8.9: Implement Feature Usage and Credit System

**Epic**: 8 - Code Quality & Production Stability  
**Story**: 8.9  
**Status**: Not Started ðŸ”´  
**Priority**: High  
**Estimated Effort**: 20 hours  
**Dependencies**: Story 8.7 (Drizzle ORM), Story 8.8 (tRPC consolidation)

## User Story

**As a** SaaS business  
**I want** comprehensive feature usage tracking and credit system  
**So that** I can monetize Phonoglyph effectively and provide transparent usage-based billing

## Technical Implementation Details

### **Current Usage Tracking Gaps**
Phonoglyph currently lacks:
- Render minute tracking for video exports
- Storage usage monitoring for audio files
- AI generation usage (stem separation, analysis)
- Credit-based billing system
- Usage analytics for business intelligence

### **Credit System Architecture**

#### **Phase 1: Database Schema for Credits and Usage (6 hours)**
```typescript
// apps/api/src/db/schema/credits.ts
export const userCredits = pgTable('user_credits', {
  id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID()),
  userId: text('user_id').notNull(),
  creditBalance: integer('credit_balance').default(0).notNull(),
  totalPurchased: integer('total_purchased').default(0).notNull(),
  totalUsed: integer('total_used').default(0).notNull(),
  tier: text('tier').notNull().default('free'), // free, pro, enterprise
  billingCycle: text('billing_cycle'), // monthly, yearly
  lastBillingDate: timestamp('last_billing_date'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

export const featureUsage = pgTable('feature_usage', {
  id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID()),
  userId: text('user_id').notNull(),
  feature: text('feature').notNull(), // render, stem_separation, storage, ai_analysis
  usageAmount: integer('usage_amount').notNull(), // minutes, MB, operations
  creditCost: integer('credit_cost').notNull(),
  projectId: text('project_id'),
  fileId: text('file_id'),
  metadata: jsonb('metadata').$type<FeatureUsageMetadata>(),
  timestamp: timestamp('timestamp').defaultNow().notNull(),
}, (table) => ({
  userFeatureIdx: index('idx_user_feature_usage')
    .on(table.userId, table.feature, table.timestamp),
  billingIdx: index('idx_billing_usage')
    .on(table.userId, table.timestamp),
}));

export const creditTransactions = pgTable('credit_transactions', {
  id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID()),
  userId: text('user_id').notNull(),
  type: text('type').notNull(), // purchase, usage, refund, bonus
  amount: integer('amount').notNull(), // positive for credits added, negative for used
  description: text('description').notNull(),
  relatedUsageId: text('related_usage_id'),
  stripePaymentId: text('stripe_payment_id'),
  timestamp: timestamp('timestamp').defaultNow().notNull(),
});
```

#### **Phase 2: Credit Management Service (6 hours)**
```typescript
// apps/api/src/services/credit-manager.ts
export class CreditManager {
  constructor(private db: DrizzleDB) {}

  async getUserCredits(userId: string): Promise<UserCreditsInfo> {
    const credits = await this.db
      .select()
      .from(userCredits)
      .where(eq(userCredits.userId, userId))
      .limit(1);

    return credits[0] || this.createDefaultCredits(userId);
  }

  async consumeCredits(
    userId: string,
    feature: FeatureType,
    amount: number,
    metadata: FeatureUsageMetadata
  ): Promise<CreditConsumptionResult> {
    const userCreditInfo = await this.getUserCredits(userId);
    const creditCost = this.calculateCreditCost(feature, amount);

    if (userCreditInfo.creditBalance < creditCost) {
      throw new TRPCError({
        code: 'PAYMENT_REQUIRED',
        message: `Insufficient credits. Required: ${creditCost}, Available: ${userCreditInfo.creditBalance}`,
      });
    }

    // Record usage and deduct credits in transaction
    return await this.db.transaction(async (tx) => {
      // Record feature usage
      const [usage] = await tx.insert(featureUsage).values({
        userId,
        feature,
        usageAmount: amount,
        creditCost,
        projectId: metadata.projectId,
        fileId: metadata.fileId,
        metadata,
      }).returning();

      // Record credit transaction
      await tx.insert(creditTransactions).values({
        userId,
        type: 'usage',
        amount: -creditCost,
        description: `${feature} usage: ${amount} units`,
        relatedUsageId: usage.id,
      });

      // Update user credit balance
      await tx.update(userCredits)
        .set({
          creditBalance: userCreditInfo.creditBalance - creditCost,
          totalUsed: userCreditInfo.totalUsed + creditCost,
          updatedAt: new Date(),
        })
        .where(eq(userCredits.userId, userId));

      return {
        success: true,
        usageId: usage.id,
        creditsUsed: creditCost,
        remainingCredits: userCreditInfo.creditBalance - creditCost,
      };
    });
  }

  private calculateCreditCost(feature: FeatureType, amount: number): number {
    const rates = {
      render: 10, // 10 credits per minute
      stem_separation: 50, // 50 credits per separation
      storage: 1, // 1 credit per 100MB per month
      ai_analysis: 20, // 20 credits per analysis
    };
    return Math.ceil(amount * rates[feature]);
  }
}
```

#### **Phase 3: tRPC Credits Router (4 hours)**
```typescript
// apps/api/src/routers/credits.ts
export const creditsRouter = router({
  getBalance: protectedProcedure
    .query(async ({ ctx }) => {
      const creditManager = new CreditManager(ctx.db);
      return await creditManager.getUserCredits(ctx.user.id);
    }),

  getUsageHistory: protectedProcedure
    .input(z.object({
      startDate: z.date().optional(),
      endDate: z.date().optional(),
      feature: z.enum(['render', 'stem_separation', 'storage', 'ai_analysis']).optional(),
      limit: z.number().min(1).max(100).default(50),
    }))
    .query(async ({ ctx, input }) => {
      const usage = await ctx.db
        .select()
        .from(featureUsage)
        .where(
          and(
            eq(featureUsage.userId, ctx.user.id),
            input.startDate ? gte(featureUsage.timestamp, input.startDate) : undefined,
            input.endDate ? lte(featureUsage.timestamp, input.endDate) : undefined,
            input.feature ? eq(featureUsage.feature, input.feature) : undefined
          )
        )
        .orderBy(desc(featureUsage.timestamp))
        .limit(input.limit);

      return usage;
    }),

  purchaseCredits: protectedProcedure
    .input(z.object({
      amount: z.number().min(100).max(10000),
      paymentMethodId: z.string(),
    }))
    .mutation(async ({ ctx, input }) => {
      // Stripe payment processing
      const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);
      
      const paymentIntent = await stripe.paymentIntents.create({
        amount: input.amount * 10, // $0.10 per credit
        currency: 'usd',
        payment_method: input.paymentMethodId,
        confirm: true,
        metadata: {
          userId: ctx.user.id,
          credits: input.amount.toString(),
        },
      });

      if (paymentIntent.status === 'succeeded') {
        const creditManager = new CreditManager(ctx.db);
        return await creditManager.addCredits(
          ctx.user.id,
          input.amount,
          `Credit purchase - ${paymentIntent.id}`
        );
      }

      throw new TRPCError({
        code: 'PAYMENT_REQUIRED',
        message: 'Payment failed',
      });
    }),

  trackUsage: protectedProcedure
    .input(z.object({
      feature: z.enum(['render', 'stem_separation', 'storage', 'ai_analysis']),
      amount: z.number().min(1),
      projectId: z.string().optional(),
      fileId: z.string().optional(),
      metadata: z.record(z.any()).optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const creditManager = new CreditManager(ctx.db);
      return await creditManager.consumeCredits(
        ctx.user.id,
        input.feature,
        input.amount,
        {
          projectId: input.projectId,
          fileId: input.fileId,
          ...input.metadata,
        }
      );
    }),
});
```

#### **Phase 4: Usage Tracking Integration (4 hours)**
```typescript
// Integration with existing services
// apps/api/src/services/render-service.ts
export class RenderService {
  constructor(
    private creditManager: CreditManager,
    private triggerClient: TriggerClient
  ) {}

  async startRender(userId: string, projectId: string, config: RenderConfig) {
    const estimatedMinutes = this.estimateRenderTime(config);
    
    // Pre-authorize credits
    await this.creditManager.consumeCredits(
      userId,
      'render',
      estimatedMinutes,
      { projectId, renderConfig: config }
    );

    // Start render job with usage tracking
    return await this.triggerClient.sendEvent({
      name: "render.video.requested",
      payload: {
        userId,
        projectId,
        config,
        estimatedCredits: estimatedMinutes * 10,
      },
    });
  }
}

// apps/api/src/services/stem-separation-service.ts
export class StemSeparationService {
  async separateStems(userId: string, fileId: string, config: SeparationConfig) {
    // Track stem separation usage
    await this.creditManager.consumeCredits(
      userId,
      'stem_separation',
      1, // One separation operation
      { fileId, separationConfig: config }
    );

    return await this.triggerClient.sendEvent({
      name: "stem.separation.requested",
      payload: { userId, fileId, config },
    });
  }
}
```

### **File Locations**
**Database Schema**:
- `apps/api/src/db/schema/credits.ts` - Credit system tables
- `apps/api/src/db/schema/usage.ts` - Feature usage tracking
- `apps/api/src/db/migrations/020_credit_system.sql` - Database migration

**Services**:
- `apps/api/src/services/credit-manager.ts` - Core credit management
- `apps/api/src/services/usage-tracker.ts` - Feature usage tracking
- `apps/api/src/services/billing-service.ts` - Stripe integration

**API Layer**:
- `apps/api/src/routers/credits.ts` - Credit management API
- `apps/api/src/middleware/credit-check.ts` - Credit validation middleware

**Frontend Integration**:
- `apps/web/src/lib/credits.ts` - Credit management hooks
- `apps/web/src/components/credits/` - Credit UI components

## Acceptance Criteria

### **Functional Requirements**
- [ ] **Complete credit system with balance tracking**
- [ ] **Feature usage tracking for all billable operations**
- [ ] **Stripe integration for credit purchases**
- [ ] **Usage history and analytics dashboard**
- [ ] **Credit consumption validation before operations**
- [ ] **Automated billing cycle management**

### **Business Requirements**
- [ ] **Accurate usage tracking with 99.9% precision**
- [ ] **Real-time credit balance updates**
- [ ] **Transparent pricing for all features**
- [ ] **Usage analytics for business intelligence**
- [ ] **Fraud prevention and abuse detection**

### **Performance Requirements**
- [ ] **Credit checks under 50ms**
- [ ] **Usage tracking without impacting core operations**
- [ ] **Efficient billing calculations**
- [ ] **Scalable for high-volume usage**

### **Security Requirements**
- [ ] **Secure payment processing with Stripe**
- [ ] **User data isolation for usage tracking**
- [ ] **Audit trail for all credit transactions**
- [ ] **Rate limiting for credit-related operations**

## Success Metrics

### **Business Metrics**
- [ ] **Revenue tracking accuracy 100%**
- [ ] **Credit purchase conversion rate >5%**
- [ ] **Usage prediction accuracy >90%**
- [ ] **Customer satisfaction with billing >95%**

### **Technical Metrics**
- [ ] **Credit system uptime >99.9%**
- [ ] **Usage tracking latency <100ms**
- [ ] **Payment processing success rate >98%**
- [ ] **Data consistency across all usage tracking**