# Story 8.10: Implement Production Monitoring Stack (PostHog + Sentry)

**Epic**: 8 - Code Quality & Production Stability  
**Story**: 8.10  
**Status**: Not Started ðŸ”´  
**Priority**: High  
**Estimated Effort**: 16 hours  
**Dependencies**: Story 8.8 (tRPC consolidation)

## User Story

**As a** product team  
**I want** comprehensive production monitoring with error tracking and user analytics  
**So that** I can proactively identify issues and understand user behavior in Phonoglyph

## Technical Implementation Details

### **Current Monitoring Gaps**
Phonoglyph currently lacks:
- Error tracking and alerting
- User behavior analytics
- Performance monitoring
- Audio processing pipeline visibility
- Production health dashboards

### **Monitoring Stack Architecture**

#### **Phase 1: Sentry Error Tracking Setup (6 hours)**
```typescript
// apps/api/src/lib/sentry.ts
import * as Sentry from "@sentry/node";
import { nodeProfilingIntegration } from "@sentry/profiling-node";

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  integrations: [
    nodeProfilingIntegration(),
    Sentry.httpIntegration(),
    Sentry.expressIntegration(),
  ],
  tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
  profilesSampleRate: 0.1,
  beforeSend(event) {
    // Filter out sensitive data
    if (event.request?.data) {
      delete event.request.data.password;
      delete event.request.data.token;
    }
    return event;
  },
});

// Enhanced error context for audio processing
export const captureAudioProcessingError = (
  error: Error,
  context: {
    userId?: string;
    fileId?: string;
    operation: string;
    audioMetadata?: any;
  }
) => {
  Sentry.withScope((scope) => {
    scope.setTag('operation', context.operation);
    scope.setContext('audio_processing', {
      fileId: context.fileId,
      operation: context.operation,
      metadata: context.audioMetadata,
    });
    if (context.userId) {
      scope.setUser({ id: context.userId });
    }
    Sentry.captureException(error);
  });
};

// apps/web/src/lib/sentry.ts - Frontend Sentry
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  integrations: [
    Sentry.replayIntegration({
      maskAllText: false,
      blockAllMedia: false,
    }),
  ],
  tracesSampleRate: 0.1,
  replaysSessionSampleRate: 0.1,
  replaysOnErrorSampleRate: 1.0,
});
```

#### **Phase 2: PostHog Analytics Integration (4 hours)**
```typescript
// apps/web/src/lib/posthog.ts
import { PostHog } from 'posthog-node';
import posthog from 'posthog-js';

// Server-side PostHog
export const serverPostHog = new PostHog(
  process.env.POSTHOG_API_KEY!,
  {
    host: process.env.POSTHOG_HOST || 'https://app.posthog.com',
    flushAt: 20,
    flushInterval: 30000,
  }
);

// Client-side PostHog initialization
export const initPostHog = () => {
  if (typeof window !== 'undefined') {
    posthog.init(process.env.NEXT_PUBLIC_POSTHOG_KEY!, {
      api_host: process.env.NEXT_PUBLIC_POSTHOG_HOST || 'https://app.posthog.com',
      capture_pageview: false, // Disable automatic pageview capture
      capture_pageleave: true,
      loaded: (posthog) => {
        if (process.env.NODE_ENV === 'development') posthog.debug();
      },
    });
  }
};

// Audio processing analytics
export const trackAudioProcessing = (
  event: 'stem_separation_started' | 'stem_separation_completed' | 'audio_analysis_started' | 'audio_analysis_completed',
  properties: {
    userId?: string;
    fileId: string;
    duration?: number;
    fileSize?: number;
    processingTime?: number;
    success?: boolean;
    errorType?: string;
  }
) => {
  if (typeof window !== 'undefined') {
    posthog.capture(event, properties);
  } else {
    serverPostHog.capture({
      distinctId: properties.userId || 'anonymous',
      event,
      properties,
    });
  }
};

// User behavior tracking
export const trackUserAction = (
  action: 'project_created' | 'file_uploaded' | 'render_started' | 'credits_purchased',
  properties: Record<string, any> = {}
) => {
  if (typeof window !== 'undefined') {
    posthog.capture(action, properties);
  }
};
```

#### **Phase 3: tRPC Monitoring Integration (3 hours)**
```typescript
// apps/api/src/middleware/monitoring.ts
import { TRPCError } from '@trpc/server';
import { captureAudioProcessingError } from '../lib/sentry';
import { serverPostHog } from '../lib/posthog';

export const monitoringMiddleware = t.middleware(async ({ path, type, next, ctx }) => {
  const start = Date.now();
  
  try {
    const result = await next();
    const duration = Date.now() - start;
    
    // Track successful API calls
    serverPostHog.capture({
      distinctId: ctx.user?.id || 'anonymous',
      event: 'api_call_success',
      properties: {
        path,
        type,
        duration,
        userId: ctx.user?.id,
      },
    });
    
    return result;
  } catch (error) {
    const duration = Date.now() - start;
    
    // Enhanced error tracking for audio operations
    if (path.includes('stem') || path.includes('audio') || path.includes('midi')) {
      captureAudioProcessingError(error as Error, {
        userId: ctx.user?.id,
        operation: `${type}:${path}`,
      });
    } else {
      Sentry.captureException(error);
    }
    
    // Track failed API calls
    serverPostHog.capture({
      distinctId: ctx.user?.id || 'anonymous',
      event: 'api_call_error',
      properties: {
        path,
        type,
        duration,
        errorCode: (error as TRPCError).code,
        errorMessage: (error as Error).message,
        userId: ctx.user?.id,
      },
    });
    
    throw error;
  }
});

// Apply monitoring to all protected procedures
export const monitoredProcedure = protectedProcedure.use(monitoringMiddleware);
```

#### **Phase 4: Audio Processing Pipeline Monitoring (3 hours)**
```typescript
// apps/api/src/services/audio-monitoring.ts
export class AudioProcessingMonitor {
  static trackStemSeparation(
    userId: string,
    fileId: string,
    status: 'started' | 'completed' | 'failed',
    metadata?: {
      duration?: number;
      fileSize?: number;
      processingTime?: number;
      errorType?: string;
    }
  ) {
    const event = `stem_separation_${status}`;
    
    trackAudioProcessing(event, {
      userId,
      fileId,
      ...metadata,
    });
    
    // Alert on failures
    if (status === 'failed') {
      Sentry.captureMessage(`Stem separation failed for file ${fileId}`, {
        level: 'error',
        tags: { operation: 'stem_separation' },
        user: { id: userId },
        extra: metadata,
      });
    }
  }
  
  static trackAudioAnalysis(
    userId: string,
    fileId: string,
    analysisType: string,
    status: 'started' | 'completed' | 'failed',
    metadata?: any
  ) {
    trackAudioProcessing(`audio_analysis_${status}`, {
      userId,
      fileId,
      analysisType,
      ...metadata,
    });
  }
  
  static trackRenderOperation(
    userId: string,
    projectId: string,
    status: 'started' | 'completed' | 'failed',
    metadata?: {
      duration?: number;
      outputSize?: number;
      renderTime?: number;
      quality?: string;
    }
  ) {
    serverPostHog.capture({
      distinctId: userId,
      event: `render_${status}`,
      properties: {
        projectId,
        ...metadata,
      },
    });
  }
}

// Integration with existing services
// apps/api/src/services/stem-separation.ts
export class StemSeparationService {
  async separateStems(userId: string, fileId: string, config: any) {
    AudioProcessingMonitor.trackStemSeparation(userId, fileId, 'started', {
      fileSize: config.fileSize,
    });
    
    try {
      const result = await this.performSeparation(fileId, config);
      
      AudioProcessingMonitor.trackStemSeparation(userId, fileId, 'completed', {
        processingTime: result.processingTime,
        duration: result.audioDuration,
      });
      
      return result;
    } catch (error) {
      AudioProcessingMonitor.trackStemSeparation(userId, fileId, 'failed', {
        errorType: error.constructor.name,
      });
      throw error;
    }
  }
}
```

### **File Locations**
**Monitoring Configuration**:
- `apps/api/src/lib/sentry.ts` - Backend error tracking
- `apps/web/src/lib/sentry.ts` - Frontend error tracking
- `apps/web/src/lib/posthog.ts` - Analytics configuration
- `apps/api/src/lib/posthog.ts` - Server-side analytics

**Middleware and Integration**:
- `apps/api/src/middleware/monitoring.ts` - tRPC monitoring middleware
- `apps/api/src/services/audio-monitoring.ts` - Audio processing monitoring
- `apps/web/src/hooks/useAnalytics.ts` - Frontend analytics hooks

**Configuration**:
- `sentry.client.config.ts` - Sentry client configuration
- `sentry.server.config.ts` - Sentry server configuration
- `next.config.js` - Next.js monitoring integration

## Acceptance Criteria

### **Error Tracking Requirements**
- [ ] **All API errors automatically tracked in Sentry**
- [ ] **Audio processing errors with enhanced context**
- [ ] **Frontend errors with user session replay**
- [ ] **Performance monitoring for critical operations**
- [ ] **Alert notifications for critical errors**

### **Analytics Requirements**
- [ ] **User behavior tracking for all key actions**
- [ ] **Audio processing pipeline analytics**
- [ ] **Feature usage analytics for business intelligence**
- [ ] **Performance metrics and trends**
- [ ] **Conversion funnel tracking**

### **Monitoring Coverage**
- [ ] **100% coverage of tRPC API endpoints**
- [ ] **Audio processing pipeline monitoring**
- [ ] **User authentication and session tracking**
- [ ] **Credit system and billing analytics**
- [ ] **File upload and processing monitoring**

### **Performance Requirements**
- [ ] **Monitoring overhead under 5% of response time**
- [ ] **Analytics data collection without blocking operations**
- [ ] **Error tracking with minimal performance impact**
- [ ] **Real-time alerting for critical issues**

## Success Metrics

### **Operational Metrics**
- [ ] **Error detection rate >95%**
- [ ] **Mean time to detection <5 minutes**
- [ ] **Alert accuracy >90% (low false positives)**
- [ ] **Monitoring system uptime >99.9%**

### **Business Intelligence Metrics**
- [ ] **User behavior insights for product decisions**
- [ ] **Feature usage data for prioritization**
- [ ] **Performance bottleneck identification**
- [ ] **Revenue impact analysis from monitoring data**

### **Developer Experience Metrics**
- [ ] **Faster debugging with enhanced error context**
- [ ] **Proactive issue identification**
- [ ] **Improved production confidence**
- [ ] **Data-driven development decisions**