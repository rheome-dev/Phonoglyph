# Story 5.5: Hybrid MIDI/Audio Workflow

**Epic**: 5 - Stem Separation & Audio Analysis  
**Story**: 5.5  
**Status**: Not Started üî¥  
**Priority**: Medium  
**Estimated Effort**: 20 hours  
**Dependencies**: Story 5.2 ‚úÖ, Story 5.3 ‚úÖ, Story 5.4 ‚úÖ

## User Story

**As a** professional music producer  
**I want to** combine MIDI and audio analysis approaches in my visualizations  
**So that** I can leverage the precision of MIDI with the organic feel of audio analysis

## Technical Implementation Details

### Hybrid Control System
```typescript
interface HybridControlSource {
  type: 'midi' | 'audio' | 'hybrid';
  midiWeight?: number; // 0-1 for hybrid mode
  audioWeight?: number; // 0-1 for hybrid mode
  parameters: {
    [key: string]: {
      source: 'midi' | 'audio' | 'hybrid';
      midiMapping?: {
        channel: number;
        controller?: number;
        note?: number;
        scaling: number;
      };
      audioMapping?: {
        feature: string;
        stem?: string;
        scaling: number;
      };
    };
  };
}

class HybridController {
  private midiProcessor: MIDIProcessor;
  private audioAnalyzer: AudioAnalyzer;
  private visualizer: VisualizerManager;
  private controlSources: Map<string, HybridControlSource>;
  
  constructor(
    midiProcessor: MIDIProcessor,
    audioAnalyzer: AudioAnalyzer,
    visualizer: VisualizerManager
  ) {
    this.midiProcessor = midiProcessor;
    this.audioAnalyzer = audioAnalyzer;
    this.visualizer = visualizer;
    this.controlSources = new Map();
  }

  updateVisuals(timestamp: number) {
    for (const [param, source] of this.controlSources) {
      switch (source.type) {
        case 'midi':
          this.applyMIDIControl(param, source);
          break;
        case 'audio':
          this.applyAudioControl(param, source);
          break;
        case 'hybrid':
          this.applyHybridControl(param, source);
          break;
      }
    }
  }

  private applyHybridControl(param: string, source: HybridControlSource) {
    // Blend MIDI and audio control signals
    // Apply weighted influence
    // Handle timing synchronization
  }
}
```

### Synchronization System
```typescript
interface SyncPoint {
  timestamp: number;
  midiTick: number;
  audioTime: number;
  confidence: number;
}

class SyncManager {
  private syncPoints: SyncPoint[];
  private midiClock: number;
  private audioClock: number;
  
  calculateOffset(): number {
    // Compute and maintain MIDI/audio timing offset
    // Return current offset for synchronization
  }

  addSyncPoint(point: SyncPoint) {
    // Add new sync point
    // Update timing model
  }

  getAdjustedTime(timestamp: number): {
    midiTime: number;
    audioTime: number;
  } {
    // Convert between timing domains
    // Handle drift correction
  }
}
```

### Hybrid Control API
```typescript
export const hybridRouter = router({
  setControlSource: protectedProcedure
    .input(z.object({
      parameter: z.string(),
      source: hybridControlSchema
    }))
    .mutation(async ({ input, ctx }) => {
      // Update control source configuration
      // Apply changes to visualization
    }),

  getSyncStatus: protectedProcedure
    .query(async ({ ctx }) => {
      // Return current sync status
      // Include timing statistics
    }),

  saveHybridPreset: protectedProcedure
    .input(z.object({
      name: z.string(),
      configuration: hybridConfigSchema
    }))
    .mutation(async ({ input, ctx }) => {
      // Save hybrid control configuration
      // Update user presets
    })
});
```

## Acceptance Criteria

### üéõÔ∏è Hybrid Control
- [ ] **Source Selection**: Switch between MIDI, audio, or hybrid control
- [ ] **Weight Adjustment**: Fine-tune MIDI vs audio influence
- [ ] **Parameter Mapping**: Map controls to visual parameters
- [ ] **Preset System**: Save and load hybrid configurations
- [ ] **Real-time Switching**: Smooth transitions between sources

### ‚è±Ô∏è Synchronization
- [ ] **Clock Sync**: Maintain MIDI and audio timing alignment
- [ ] **Drift Correction**: Handle timing discrepancies
- [ ] **Sync Monitoring**: Display sync status and quality
- [ ] **Manual Adjustment**: Tools for timing correction
- [ ] **Auto-calibration**: Detect and fix sync issues

### üé® Visual Integration
- [ ] **Blended Control**: Smooth mixing of control sources
- [ ] **Transition Effects**: Clean switches between modes
- [ ] **Visual Feedback**: Indicate active control source
- [ ] **Error Handling**: Graceful fallback on sync issues
- [ ] **Performance Monitoring**: Track control responsiveness

### üì± User Interface
- [ ] **Control Panel**: Interface for source selection
- [ ] **Weight Controls**: Sliders for influence adjustment
- [ ] **Sync Display**: Visual sync status indicator
- [ ] **Preset Manager**: Save/load hybrid configurations
- [ ] **Mobile Support**: Touch-friendly control interface

## Technical Dependencies

### External Libraries
- Web MIDI API
- Web Audio API
- WebWorker API for sync processing
- LocalStorage/IndexedDB for presets

### Internal Dependencies
- MIDI processing system
- Audio analysis from Story 5.2
- Visualization control from Story 5.3
- Feature extraction from Story 5.4

## Success Metrics

- [ ] Sync accuracy within ¬±5ms
- [ ] Smooth transitions between sources
- [ ] Control latency <16ms
- [ ] Preset save/load in <100ms
- [ ] Positive user feedback on hybrid control

## Dev Agent Record

### Task Checklist
- [ ] Implement hybrid controller
- [ ] Build synchronization system
- [ ] Create control UI
- [ ] Add preset management
- [ ] Implement sync monitoring
- [ ] Add calibration tools
- [ ] Write sync tests
- [ ] Document hybrid workflow

### Implementation Notes
- Use high-resolution timestamps
- Implement circular buffer for sync points
- Consider using SharedArrayBuffer for timing
- Cache control computations where possible
- Monitor CPU usage during hybrid mode 