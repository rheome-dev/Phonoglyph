"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1";
exports.ids = ["vendor-chunks/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/Draggable.js":
/*!******************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/Draggable.js ***!
  \******************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"DraggableCore\", ({\n    enumerable: true,\n    get: function() {\n        return _DraggableCore.default;\n    }\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/../../node_modules/.pnpm/next@14.1.0_@babel+core@7.27.7_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/../../node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js\"));\nvar _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ \"(ssr)/../../node_modules/.pnpm/next@14.1.0_@babel+core@7.27.7_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\"));\nvar _clsx = __webpack_require__(/*! clsx */ \"(ssr)/../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.js\");\nvar _domFns = __webpack_require__(/*! ./utils/domFns */ \"(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/domFns.js\");\nvar _positionFns = __webpack_require__(/*! ./utils/positionFns */ \"(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/positionFns.js\");\nvar _shims = __webpack_require__(/*! ./utils/shims */ \"(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _DraggableCore = _interopRequireDefault(__webpack_require__(/*! ./DraggableCore */ \"(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/DraggableCore.js\"));\nvar _log = _interopRequireDefault(__webpack_require__(/*! ./utils/log */ \"(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/log.js\"));\nfunction _interopRequireDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nfunction _interopRequireWildcard(e, t) {\n    if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();\n    return (_interopRequireWildcard = function(e, t) {\n        if (!t && e && e.__esModule) return e;\n        var o, i, f = {\n            __proto__: null,\n            default: e\n        };\n        if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f;\n        if (o = t ? n : r) {\n            if (o.has(e)) return o.get(e);\n            o.set(e, f);\n        }\n        for(const t in e)\"default\" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);\n        return f;\n    })(e, t);\n}\nfunction _extends() {\n    return _extends = Object.assign ? Object.assign.bind() : function(n) {\n        for(var e = 1; e < arguments.length; e++){\n            var t = arguments[e];\n            for(var r in t)({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n        }\n        return n;\n    }, _extends.apply(null, arguments);\n}\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n} /*:: import type {ControlPosition, PositionOffsetControlPosition, DraggableCoreProps, DraggableCoreDefaultProps} from './DraggableCore';*/ \n/*:: import type {Bounds, DraggableEventHandler} from './utils/types';*/ /*:: import type {Element as ReactElement} from 'react';*/ /*:: type DraggableState = {\n  dragging: boolean,\n  dragged: boolean,\n  x: number, y: number,\n  slackX: number, slackY: number,\n  isElementSVG: boolean,\n  prevPropsPosition: ?ControlPosition,\n};*/ /*:: export type DraggableDefaultProps = {\n  ...DraggableCoreDefaultProps,\n  axis: 'both' | 'x' | 'y' | 'none',\n  bounds: Bounds | string | false,\n  defaultClassName: string,\n  defaultClassNameDragging: string,\n  defaultClassNameDragged: string,\n  defaultPosition: ControlPosition,\n  scale: number,\n};*/ /*:: export type DraggableProps = {\n  ...DraggableCoreProps,\n  ...DraggableDefaultProps,\n  positionOffset: PositionOffsetControlPosition,\n  position: ControlPosition,\n};*/ //\n// Define <Draggable>\n//\nclass Draggable extends React.Component /*:: <DraggableProps, DraggableState>*/  {\n    // React 16.3+\n    // Arity (props, state)\n    static getDerivedStateFromProps(_ref /*:: */ , _ref2 /*:: */ ) /*: ?Partial<DraggableState>*/ {\n        let { position } /*: DraggableProps*/  = _ref /*: DraggableProps*/ ;\n        let { prevPropsPosition } /*: DraggableState*/  = _ref2 /*: DraggableState*/ ;\n        // Set x/y if a new position is provided in props that is different than the previous.\n        if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {\n            (0, _log.default)(\"Draggable: getDerivedStateFromProps %j\", {\n                position,\n                prevPropsPosition\n            });\n            return {\n                x: position.x,\n                y: position.y,\n                prevPropsPosition: {\n                    ...position\n                }\n            };\n        }\n        return null;\n    }\n    constructor(props /*: DraggableProps*/ ){\n        super(props);\n        _defineProperty(this, \"onDragStart\", (e, coreData)=>{\n            (0, _log.default)(\"Draggable: onDragStart: %j\", coreData);\n            // Short-circuit if user's callback killed it.\n            const shouldStart = this.props.onStart(e, (0, _positionFns.createDraggableData)(this, coreData));\n            // Kills start event on core as well, so move handlers are never bound.\n            if (shouldStart === false) return false;\n            this.setState({\n                dragging: true,\n                dragged: true\n            });\n        });\n        _defineProperty(this, \"onDrag\", (e, coreData)=>{\n            if (!this.state.dragging) return false;\n            (0, _log.default)(\"Draggable: onDrag: %j\", coreData);\n            const uiData = (0, _positionFns.createDraggableData)(this, coreData);\n            const newState = {\n                x: uiData.x,\n                y: uiData.y,\n                slackX: 0,\n                slackY: 0\n            };\n            // Keep within bounds.\n            if (this.props.bounds) {\n                // Save original x and y.\n                const { x, y } = newState;\n                // Add slack to the values used to calculate bound position. This will ensure that if\n                // we start removing slack, the element won't react to it right away until it's been\n                // completely removed.\n                newState.x += this.state.slackX;\n                newState.y += this.state.slackY;\n                // Get bound position. This will ceil/floor the x and y within the boundaries.\n                const [newStateX, newStateY] = (0, _positionFns.getBoundPosition)(this, newState.x, newState.y);\n                newState.x = newStateX;\n                newState.y = newStateY;\n                // Recalculate slack by noting how much was shaved by the boundPosition handler.\n                newState.slackX = this.state.slackX + (x - newState.x);\n                newState.slackY = this.state.slackY + (y - newState.y);\n                // Update the event we fire to reflect what really happened after bounds took effect.\n                uiData.x = newState.x;\n                uiData.y = newState.y;\n                uiData.deltaX = newState.x - this.state.x;\n                uiData.deltaY = newState.y - this.state.y;\n            }\n            // Short-circuit if user's callback killed it.\n            const shouldUpdate = this.props.onDrag(e, uiData);\n            if (shouldUpdate === false) return false;\n            this.setState(newState);\n        });\n        _defineProperty(this, \"onDragStop\", (e, coreData)=>{\n            if (!this.state.dragging) return false;\n            // Short-circuit if user's callback killed it.\n            const shouldContinue = this.props.onStop(e, (0, _positionFns.createDraggableData)(this, coreData));\n            if (shouldContinue === false) return false;\n            (0, _log.default)(\"Draggable: onDragStop: %j\", coreData);\n            const newState /*: Partial<DraggableState>*/  = {\n                dragging: false,\n                slackX: 0,\n                slackY: 0\n            };\n            // If this is a controlled component, the result of this operation will be to\n            // revert back to the old position. We expect a handler on `onDragStop`, at the least.\n            const controlled = Boolean(this.props.position);\n            if (controlled) {\n                const { x, y } = this.props.position;\n                newState.x = x;\n                newState.y = y;\n            }\n            this.setState(newState);\n        });\n        this.state = {\n            // Whether or not we are currently dragging.\n            dragging: false,\n            // Whether or not we have been dragged before.\n            dragged: false,\n            // Current transform x and y.\n            x: props.position ? props.position.x : props.defaultPosition.x,\n            y: props.position ? props.position.y : props.defaultPosition.y,\n            prevPropsPosition: {\n                ...props.position\n            },\n            // Used for compensating for out-of-bounds drags\n            slackX: 0,\n            slackY: 0,\n            // Can only determine if SVG after mounting\n            isElementSVG: false\n        };\n        if (props.position && !(props.onDrag || props.onStop)) {\n            // eslint-disable-next-line no-console\n            console.warn(\"A `position` was applied to this <Draggable>, without drag handlers. This will make this \" + \"component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the \" + \"`position` of this element.\");\n        }\n    }\n    componentDidMount() {\n        // Check to see if the element passed is an instanceof SVGElement\n        if (typeof window.SVGElement !== \"undefined\" && this.findDOMNode() instanceof window.SVGElement) {\n            this.setState({\n                isElementSVG: true\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.state.dragging) {\n            this.setState({\n                dragging: false\n            }); // prevents invariant if unmounted while dragging\n        }\n    }\n    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n    // the underlying DOM node ourselves. See the README for more information.\n    findDOMNode() /*: ?HTMLElement*/ {\n        return this.props?.nodeRef?.current ?? _reactDom.default.findDOMNode(this);\n    }\n    render() /*: ReactElement<any>*/ {\n        const { axis, bounds, children, defaultPosition, defaultClassName, defaultClassNameDragging, defaultClassNameDragged, position, positionOffset, scale, ...draggableCoreProps } = this.props;\n        let style = {};\n        let svgTransform = null;\n        // If this is controlled, we don't want to move it - unless it's dragging.\n        const controlled = Boolean(position);\n        const draggable = !controlled || this.state.dragging;\n        const validPosition = position || defaultPosition;\n        const transformOpts = {\n            // Set left if horizontal drag is enabled\n            x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,\n            // Set top if vertical drag is enabled\n            y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y\n        };\n        // If this element was SVG, we use the `transform` attribute.\n        if (this.state.isElementSVG) {\n            svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);\n        } else {\n            // Add a CSS transform to move the element around. This allows us to move the element around\n            // without worrying about whether or not it is relatively or absolutely positioned.\n            // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>\n            // has a clean slate.\n            style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);\n        }\n        // Mark with class while dragging\n        const className = (0, _clsx.clsx)(children.props.className || \"\", defaultClassName, {\n            [defaultClassNameDragging]: this.state.dragging,\n            [defaultClassNameDragged]: this.state.dragged\n        });\n        // Reuse the child provided\n        // This makes it flexible to use whatever element is wanted (div, ul, etc)\n        return /*#__PURE__*/ React.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {\n            onStart: this.onDragStart,\n            onDrag: this.onDrag,\n            onStop: this.onDragStop\n        }), /*#__PURE__*/ React.cloneElement(React.Children.only(children), {\n            className: className,\n            style: {\n                ...children.props.style,\n                ...style\n            },\n            transform: svgTransform\n        }));\n    }\n}\nexports[\"default\"] = Draggable;\n_defineProperty(Draggable, \"displayName\", \"Draggable\");\n_defineProperty(Draggable, \"propTypes\", {\n    // Accepts all props <DraggableCore> accepts.\n    ..._DraggableCore.default.propTypes,\n    /**\n   * `axis` determines which axis the draggable can move.\n   *\n   *  Note that all callbacks will still return data as normal. This only\n   *  controls flushing to the DOM.\n   *\n   * 'both' allows movement horizontally and vertically.\n   * 'x' limits movement to horizontal axis.\n   * 'y' limits movement to vertical axis.\n   * 'none' limits all movement.\n   *\n   * Defaults to 'both'.\n   */ axis: _propTypes.default.oneOf([\n        \"both\",\n        \"x\",\n        \"y\",\n        \"none\"\n    ]),\n    /**\n   * `bounds` determines the range of movement available to the element.\n   * Available values are:\n   *\n   * 'parent' restricts movement within the Draggable's parent node.\n   *\n   * Alternatively, pass an object with the following properties, all of which are optional:\n   *\n   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}\n   *\n   * All values are in px.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable bounds={{right: 300, bottom: 300}}>\n   *              <div>Content</div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */ bounds: _propTypes.default.oneOfType([\n        _propTypes.default.shape({\n            left: _propTypes.default.number,\n            right: _propTypes.default.number,\n            top: _propTypes.default.number,\n            bottom: _propTypes.default.number\n        }),\n        _propTypes.default.string,\n        _propTypes.default.oneOf([\n            false\n        ])\n    ]),\n    defaultClassName: _propTypes.default.string,\n    defaultClassNameDragging: _propTypes.default.string,\n    defaultClassNameDragged: _propTypes.default.string,\n    /**\n   * `defaultPosition` specifies the x and y that the dragged item should start at\n   *\n   * Example:\n   *\n   * ```jsx\n   *      let App = React.createClass({\n   *          render: function () {\n   *              return (\n   *                  <Draggable defaultPosition={{x: 25, y: 25}}>\n   *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n   *                  </Draggable>\n   *              );\n   *          }\n   *      });\n   * ```\n   */ defaultPosition: _propTypes.default.shape({\n        x: _propTypes.default.number,\n        y: _propTypes.default.number\n    }),\n    positionOffset: _propTypes.default.shape({\n        x: _propTypes.default.oneOfType([\n            _propTypes.default.number,\n            _propTypes.default.string\n        ]),\n        y: _propTypes.default.oneOfType([\n            _propTypes.default.number,\n            _propTypes.default.string\n        ])\n    }),\n    /**\n   * `position`, if present, defines the current position of the element.\n   *\n   *  This is similar to how form elements in React work - if no `position` is supplied, the component\n   *  is uncontrolled.\n   *\n   * Example:\n   *\n   * ```jsx\n   *      let App = React.createClass({\n   *          render: function () {\n   *              return (\n   *                  <Draggable position={{x: 25, y: 25}}>\n   *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n   *                  </Draggable>\n   *              );\n   *          }\n   *      });\n   * ```\n   */ position: _propTypes.default.shape({\n        x: _propTypes.default.number,\n        y: _propTypes.default.number\n    }),\n    /**\n   * These properties should be defined on the child, not here.\n   */ className: _shims.dontSetMe,\n    style: _shims.dontSetMe,\n    transform: _shims.dontSetMe\n});\n_defineProperty(Draggable, \"defaultProps\", {\n    ..._DraggableCore.default.defaultProps,\n    axis: \"both\",\n    bounds: false,\n    defaultClassName: \"react-draggable\",\n    defaultClassNameDragging: \"react-draggable-dragging\",\n    defaultClassNameDragged: \"react-draggable-dragged\",\n    defaultPosition: {\n        x: 0,\n        y: 0\n    },\n    scale: 1\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRyYWdnYWJsZUA0LjUuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL0RyYWdnYWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkgsaURBQWdEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDSCxPQUFPQyxlQUFlQyxPQUFPO0lBQy9CO0FBQ0YsQ0FBQyxFQUFDO0FBQ0ZMLGtCQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJTSxRQUFRQyx3QkFBd0JDLG1CQUFPQSxDQUFDLDBNQUFPO0FBQ25ELElBQUlDLGFBQWFDLHVCQUF1QkYsbUJBQU9BLENBQUMscUdBQVk7QUFDNUQsSUFBSUcsWUFBWUQsdUJBQXVCRixtQkFBT0EsQ0FBQyxrTkFBVztBQUMxRCxJQUFJSSxRQUFRSixtQkFBT0EsQ0FBQyxzRkFBTTtBQUMxQixJQUFJSyxVQUFVTCxtQkFBT0EsQ0FBQywrS0FBZ0I7QUFDdEMsSUFBSU0sZUFBZU4sbUJBQU9BLENBQUMseUxBQXFCO0FBQ2hELElBQUlPLFNBQVNQLG1CQUFPQSxDQUFDLDZLQUFlO0FBQ3BDLElBQUlKLGlCQUFpQk0sdUJBQXVCRixtQkFBT0EsQ0FBQyxpTEFBaUI7QUFDckUsSUFBSVEsT0FBT04sdUJBQXVCRixtQkFBT0EsQ0FBQyx5S0FBYTtBQUN2RCxTQUFTRSx1QkFBdUJPLENBQUM7SUFBSSxPQUFPQSxLQUFLQSxFQUFFQyxVQUFVLEdBQUdELElBQUk7UUFBRVosU0FBU1k7SUFBRTtBQUFHO0FBQ3BGLFNBQVNWLHdCQUF3QlUsQ0FBQyxFQUFFRSxDQUFDO0lBQUksSUFBSSxjQUFjLE9BQU9DLFNBQVMsSUFBSUMsSUFBSSxJQUFJRCxXQUFXRSxJQUFJLElBQUlGO0lBQVcsT0FBTyxDQUFDYiwwQkFB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QUNEZCxXQUFXakcsT0FBT29ILFNBQVM7SUFDM0I1QixPQUFPeEYsT0FBT29ILFNBQVM7SUFDdkJYLFdBQVd6RyxPQUFPb0gsU0FBUztBQUM3QjtBQUNBN0YsZ0JBQWdCVSxXQUFXLGdCQUFnQjtJQUN6QyxHQUFHNUMsZUFBZUMsT0FBTyxDQUFDK0gsWUFBWTtJQUN0Q3JDLE1BQU07SUFDTnhCLFFBQVE7SUFDUjBCLGtCQUFrQjtJQUNsQkMsMEJBQTBCO0lBQzFCQyx5QkFBeUI7SUFDekJoQixpQkFBaUI7UUFDZjVCLEdBQUc7UUFDSEMsR0FBRztJQUNMO0lBQ0E2QyxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWlkaXZpei93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRyYWdnYWJsZUA0LjUuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL0RyYWdnYWJsZS5qcz8zZmVmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRHJhZ2dhYmxlQ29yZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfRHJhZ2dhYmxlQ29yZS5kZWZhdWx0O1xuICB9XG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xudmFyIF9yZWFjdERvbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG52YXIgX2Nsc3ggPSByZXF1aXJlKFwiY2xzeFwiKTtcbnZhciBfZG9tRm5zID0gcmVxdWlyZShcIi4vdXRpbHMvZG9tRm5zXCIpO1xudmFyIF9wb3NpdGlvbkZucyA9IHJlcXVpcmUoXCIuL3V0aWxzL3Bvc2l0aW9uRm5zXCIpO1xudmFyIF9zaGltcyA9IHJlcXVpcmUoXCIuL3V0aWxzL3NoaW1zXCIpO1xudmFyIF9EcmFnZ2FibGVDb3JlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9EcmFnZ2FibGVDb3JlXCIpKTtcbnZhciBfbG9nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9sb2dcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgdCkgeyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBXZWFrTWFwKSB2YXIgciA9IG5ldyBXZWFrTWFwKCksIG4gPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gZnVuY3Rpb24gKGUsIHQpIHsgaWYgKCF0ICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgdmFyIG8sIGksIGYgPSB7IF9fcHJvdG9fXzogbnVsbCwgZGVmYXVsdDogZSB9OyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiBlICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIGY7IGlmIChvID0gdCA/IG4gOiByKSB7IGlmIChvLmhhcyhlKSkgcmV0dXJuIG8uZ2V0KGUpOyBvLnNldChlLCBmKTsgfSBmb3IgKGNvbnN0IHQgaW4gZSkgXCJkZWZhdWx0XCIgIT09IHQgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB0KSAmJiAoKGkgPSAobyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB0KSkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IG8oZiwgdCwgaSkgOiBmW3RdID0gZVt0XSk7IHJldHVybiBmOyB9KShlLCB0KTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IHJldHVybiBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uIChuKSB7IGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7IHZhciB0ID0gYXJndW1lbnRzW2VdOyBmb3IgKHZhciByIGluIHQpICh7fSkuaGFzT3duUHJvcGVydHkuY2FsbCh0LCByKSAmJiAobltyXSA9IHRbcl0pOyB9IHJldHVybiBuOyB9LCBfZXh0ZW5kcy5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9IC8qOjogaW1wb3J0IHR5cGUge0NvbnRyb2xQb3NpdGlvbiwgUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24sIERyYWdnYWJsZUNvcmVQcm9wcywgRHJhZ2dhYmxlQ29yZURlZmF1bHRQcm9wc30gZnJvbSAnLi9EcmFnZ2FibGVDb3JlJzsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7Qm91bmRzLCBEcmFnZ2FibGVFdmVudEhhbmRsZXJ9IGZyb20gJy4vdXRpbHMvdHlwZXMnOyovXG4vKjo6IGltcG9ydCB0eXBlIHtFbGVtZW50IGFzIFJlYWN0RWxlbWVudH0gZnJvbSAncmVhY3QnOyovXG4vKjo6IHR5cGUgRHJhZ2dhYmxlU3RhdGUgPSB7XG4gIGRyYWdnaW5nOiBib29sZWFuLFxuICBkcmFnZ2VkOiBib29sZWFuLFxuICB4OiBudW1iZXIsIHk6IG51bWJlcixcbiAgc2xhY2tYOiBudW1iZXIsIHNsYWNrWTogbnVtYmVyLFxuICBpc0VsZW1lbnRTVkc6IGJvb2xlYW4sXG4gIHByZXZQcm9wc1Bvc2l0aW9uOiA/Q29udHJvbFBvc2l0aW9uLFxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVEZWZhdWx0UHJvcHMgPSB7XG4gIC4uLkRyYWdnYWJsZUNvcmVEZWZhdWx0UHJvcHMsXG4gIGF4aXM6ICdib3RoJyB8ICd4JyB8ICd5JyB8ICdub25lJyxcbiAgYm91bmRzOiBCb3VuZHMgfCBzdHJpbmcgfCBmYWxzZSxcbiAgZGVmYXVsdENsYXNzTmFtZTogc3RyaW5nLFxuICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmc6IHN0cmluZyxcbiAgZGVmYXVsdENsYXNzTmFtZURyYWdnZWQ6IHN0cmluZyxcbiAgZGVmYXVsdFBvc2l0aW9uOiBDb250cm9sUG9zaXRpb24sXG4gIHNjYWxlOiBudW1iZXIsXG59OyovXG4vKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZVByb3BzID0ge1xuICAuLi5EcmFnZ2FibGVDb3JlUHJvcHMsXG4gIC4uLkRyYWdnYWJsZURlZmF1bHRQcm9wcyxcbiAgcG9zaXRpb25PZmZzZXQ6IFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uLFxuICBwb3NpdGlvbjogQ29udHJvbFBvc2l0aW9uLFxufTsqL1xuLy9cbi8vIERlZmluZSA8RHJhZ2dhYmxlPlxuLy9cbmNsYXNzIERyYWdnYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCAvKjo6IDxEcmFnZ2FibGVQcm9wcywgRHJhZ2dhYmxlU3RhdGU+Ki97XG4gIC8vIFJlYWN0IDE2LjMrXG4gIC8vIEFyaXR5IChwcm9wcywgc3RhdGUpXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoX3JlZiAvKjo6ICovLCBfcmVmMiAvKjo6ICovKSAvKjogP1BhcnRpYWw8RHJhZ2dhYmxlU3RhdGU+Ki97XG4gICAgbGV0IHtcbiAgICAgIHBvc2l0aW9uXG4gICAgfSAvKjogRHJhZ2dhYmxlUHJvcHMqLyA9IF9yZWYgLyo6IERyYWdnYWJsZVByb3BzKi87XG4gICAgbGV0IHtcbiAgICAgIHByZXZQcm9wc1Bvc2l0aW9uXG4gICAgfSAvKjogRHJhZ2dhYmxlU3RhdGUqLyA9IF9yZWYyIC8qOiBEcmFnZ2FibGVTdGF0ZSovO1xuICAgIC8vIFNldCB4L3kgaWYgYSBuZXcgcG9zaXRpb24gaXMgcHJvdmlkZWQgaW4gcHJvcHMgdGhhdCBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgcHJldmlvdXMuXG4gICAgaWYgKHBvc2l0aW9uICYmICghcHJldlByb3BzUG9zaXRpb24gfHwgcG9zaXRpb24ueCAhPT0gcHJldlByb3BzUG9zaXRpb24ueCB8fCBwb3NpdGlvbi55ICE9PSBwcmV2UHJvcHNQb3NpdGlvbi55KSkge1xuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZTogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICVqJywge1xuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgcHJldlByb3BzUG9zaXRpb25cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9zaXRpb24ueCxcbiAgICAgICAgeTogcG9zaXRpb24ueSxcbiAgICAgICAgcHJldlByb3BzUG9zaXRpb246IHtcbiAgICAgICAgICAuLi5wb3NpdGlvblxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3Rvcihwcm9wcyAvKjogRHJhZ2dhYmxlUHJvcHMqLykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdTdGFydFwiLCAoZSwgY29yZURhdGEpID0+IHtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGU6IG9uRHJhZ1N0YXJ0OiAlaicsIGNvcmVEYXRhKTtcblxuICAgICAgLy8gU2hvcnQtY2lyY3VpdCBpZiB1c2VyJ3MgY2FsbGJhY2sga2lsbGVkIGl0LlxuICAgICAgY29uc3Qgc2hvdWxkU3RhcnQgPSB0aGlzLnByb3BzLm9uU3RhcnQoZSwgKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVEcmFnZ2FibGVEYXRhKSh0aGlzLCBjb3JlRGF0YSkpO1xuICAgICAgLy8gS2lsbHMgc3RhcnQgZXZlbnQgb24gY29yZSBhcyB3ZWxsLCBzbyBtb3ZlIGhhbmRsZXJzIGFyZSBuZXZlciBib3VuZC5cbiAgICAgIGlmIChzaG91bGRTdGFydCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgZHJhZ2dlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnXCIsIChlLCBjb3JlRGF0YSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLmRyYWdnaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlOiBvbkRyYWc6ICVqJywgY29yZURhdGEpO1xuICAgICAgY29uc3QgdWlEYXRhID0gKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVEcmFnZ2FibGVEYXRhKSh0aGlzLCBjb3JlRGF0YSk7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgeDogdWlEYXRhLngsXG4gICAgICAgIHk6IHVpRGF0YS55LFxuICAgICAgICBzbGFja1g6IDAsXG4gICAgICAgIHNsYWNrWTogMFxuICAgICAgfTtcblxuICAgICAgLy8gS2VlcCB3aXRoaW4gYm91bmRzLlxuICAgICAgaWYgKHRoaXMucHJvcHMuYm91bmRzKSB7XG4gICAgICAgIC8vIFNhdmUgb3JpZ2luYWwgeCBhbmQgeS5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gbmV3U3RhdGU7XG5cbiAgICAgICAgLy8gQWRkIHNsYWNrIHRvIHRoZSB2YWx1ZXMgdXNlZCB0byBjYWxjdWxhdGUgYm91bmQgcG9zaXRpb24uIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCBpZlxuICAgICAgICAvLyB3ZSBzdGFydCByZW1vdmluZyBzbGFjaywgdGhlIGVsZW1lbnQgd29uJ3QgcmVhY3QgdG8gaXQgcmlnaHQgYXdheSB1bnRpbCBpdCdzIGJlZW5cbiAgICAgICAgLy8gY29tcGxldGVseSByZW1vdmVkLlxuICAgICAgICBuZXdTdGF0ZS54ICs9IHRoaXMuc3RhdGUuc2xhY2tYO1xuICAgICAgICBuZXdTdGF0ZS55ICs9IHRoaXMuc3RhdGUuc2xhY2tZO1xuXG4gICAgICAgIC8vIEdldCBib3VuZCBwb3NpdGlvbi4gVGhpcyB3aWxsIGNlaWwvZmxvb3IgdGhlIHggYW5kIHkgd2l0aGluIHRoZSBib3VuZGFyaWVzLlxuICAgICAgICBjb25zdCBbbmV3U3RhdGVYLCBuZXdTdGF0ZVldID0gKDAsIF9wb3NpdGlvbkZucy5nZXRCb3VuZFBvc2l0aW9uKSh0aGlzLCBuZXdTdGF0ZS54LCBuZXdTdGF0ZS55KTtcbiAgICAgICAgbmV3U3RhdGUueCA9IG5ld1N0YXRlWDtcbiAgICAgICAgbmV3U3RhdGUueSA9IG5ld1N0YXRlWTtcblxuICAgICAgICAvLyBSZWNhbGN1bGF0ZSBzbGFjayBieSBub3RpbmcgaG93IG11Y2ggd2FzIHNoYXZlZCBieSB0aGUgYm91bmRQb3NpdGlvbiBoYW5kbGVyLlxuICAgICAgICBuZXdTdGF0ZS5zbGFja1ggPSB0aGlzLnN0YXRlLnNsYWNrWCArICh4IC0gbmV3U3RhdGUueCk7XG4gICAgICAgIG5ld1N0YXRlLnNsYWNrWSA9IHRoaXMuc3RhdGUuc2xhY2tZICsgKHkgLSBuZXdTdGF0ZS55KTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGV2ZW50IHdlIGZpcmUgdG8gcmVmbGVjdCB3aGF0IHJlYWxseSBoYXBwZW5lZCBhZnRlciBib3VuZHMgdG9vayBlZmZlY3QuXG4gICAgICAgIHVpRGF0YS54ID0gbmV3U3RhdGUueDtcbiAgICAgICAgdWlEYXRhLnkgPSBuZXdTdGF0ZS55O1xuICAgICAgICB1aURhdGEuZGVsdGFYID0gbmV3U3RhdGUueCAtIHRoaXMuc3RhdGUueDtcbiAgICAgICAgdWlEYXRhLmRlbHRhWSA9IG5ld1N0YXRlLnkgLSB0aGlzLnN0YXRlLnk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgdXNlcidzIGNhbGxiYWNrIGtpbGxlZCBpdC5cbiAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZSA9IHRoaXMucHJvcHMub25EcmFnKGUsIHVpRGF0YSk7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnU3RvcFwiLCAoZSwgY29yZURhdGEpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5kcmFnZ2luZykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIHVzZXIncyBjYWxsYmFjayBraWxsZWQgaXQuXG4gICAgICBjb25zdCBzaG91bGRDb250aW51ZSA9IHRoaXMucHJvcHMub25TdG9wKGUsICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlRHJhZ2dhYmxlRGF0YSkodGhpcywgY29yZURhdGEpKTtcbiAgICAgIGlmIChzaG91bGRDb250aW51ZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGU6IG9uRHJhZ1N0b3A6ICVqJywgY29yZURhdGEpO1xuICAgICAgY29uc3QgbmV3U3RhdGUgLyo6IFBhcnRpYWw8RHJhZ2dhYmxlU3RhdGU+Ki8gPSB7XG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgc2xhY2tYOiAwLFxuICAgICAgICBzbGFja1k6IDBcbiAgICAgIH07XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIGNvbXBvbmVudCwgdGhlIHJlc3VsdCBvZiB0aGlzIG9wZXJhdGlvbiB3aWxsIGJlIHRvXG4gICAgICAvLyByZXZlcnQgYmFjayB0byB0aGUgb2xkIHBvc2l0aW9uLiBXZSBleHBlY3QgYSBoYW5kbGVyIG9uIGBvbkRyYWdTdG9wYCwgYXQgdGhlIGxlYXN0LlxuICAgICAgY29uc3QgY29udHJvbGxlZCA9IEJvb2xlYW4odGhpcy5wcm9wcy5wb3NpdGlvbik7XG4gICAgICBpZiAoY29udHJvbGxlZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5XG4gICAgICAgIH0gPSB0aGlzLnByb3BzLnBvc2l0aW9uO1xuICAgICAgICBuZXdTdGF0ZS54ID0geDtcbiAgICAgICAgbmV3U3RhdGUueSA9IHk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgLy8gV2hldGhlciBvciBub3Qgd2UgYXJlIGN1cnJlbnRseSBkcmFnZ2luZy5cbiAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHdlIGhhdmUgYmVlbiBkcmFnZ2VkIGJlZm9yZS5cbiAgICAgIGRyYWdnZWQ6IGZhbHNlLFxuICAgICAgLy8gQ3VycmVudCB0cmFuc2Zvcm0geCBhbmQgeS5cbiAgICAgIHg6IHByb3BzLnBvc2l0aW9uID8gcHJvcHMucG9zaXRpb24ueCA6IHByb3BzLmRlZmF1bHRQb3NpdGlvbi54LFxuICAgICAgeTogcHJvcHMucG9zaXRpb24gPyBwcm9wcy5wb3NpdGlvbi55IDogcHJvcHMuZGVmYXVsdFBvc2l0aW9uLnksXG4gICAgICBwcmV2UHJvcHNQb3NpdGlvbjoge1xuICAgICAgICAuLi5wcm9wcy5wb3NpdGlvblxuICAgICAgfSxcbiAgICAgIC8vIFVzZWQgZm9yIGNvbXBlbnNhdGluZyBmb3Igb3V0LW9mLWJvdW5kcyBkcmFnc1xuICAgICAgc2xhY2tYOiAwLFxuICAgICAgc2xhY2tZOiAwLFxuICAgICAgLy8gQ2FuIG9ubHkgZGV0ZXJtaW5lIGlmIFNWRyBhZnRlciBtb3VudGluZ1xuICAgICAgaXNFbGVtZW50U1ZHOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKHByb3BzLnBvc2l0aW9uICYmICEocHJvcHMub25EcmFnIHx8IHByb3BzLm9uU3RvcCkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oJ0EgYHBvc2l0aW9uYCB3YXMgYXBwbGllZCB0byB0aGlzIDxEcmFnZ2FibGU+LCB3aXRob3V0IGRyYWcgaGFuZGxlcnMuIFRoaXMgd2lsbCBtYWtlIHRoaXMgJyArICdjb21wb25lbnQgZWZmZWN0aXZlbHkgdW5kcmFnZ2FibGUuIFBsZWFzZSBhdHRhY2ggYG9uRHJhZ2Agb3IgYG9uU3RvcGAgaGFuZGxlcnMgc28geW91IGNhbiBhZGp1c3QgdGhlICcgKyAnYHBvc2l0aW9uYCBvZiB0aGlzIGVsZW1lbnQuJyk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgZWxlbWVudCBwYXNzZWQgaXMgYW4gaW5zdGFuY2VvZiBTVkdFbGVtZW50XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuU1ZHRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5maW5kRE9NTm9kZSgpIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0VsZW1lbnRTVkc6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5kcmFnZ2luZykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZVxuICAgICAgfSk7IC8vIHByZXZlbnRzIGludmFyaWFudCBpZiB1bm1vdW50ZWQgd2hpbGUgZHJhZ2dpbmdcbiAgICB9XG4gIH1cblxuICAvLyBSZWFjdCBTdHJpY3QgTW9kZSBjb21wYXRpYmlsaXR5OiBpZiBgbm9kZVJlZmAgaXMgcGFzc2VkLCB3ZSB3aWxsIHVzZSBpdCBpbnN0ZWFkIG9mIHRyeWluZyB0byBmaW5kXG4gIC8vIHRoZSB1bmRlcmx5aW5nIERPTSBub2RlIG91cnNlbHZlcy4gU2VlIHRoZSBSRUFETUUgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gIGZpbmRET01Ob2RlKCkgLyo6ID9IVE1MRWxlbWVudCove1xuICAgIHJldHVybiB0aGlzLnByb3BzPy5ub2RlUmVmPy5jdXJyZW50ID8/IF9yZWFjdERvbS5kZWZhdWx0LmZpbmRET01Ob2RlKHRoaXMpO1xuICB9XG4gIHJlbmRlcigpIC8qOiBSZWFjdEVsZW1lbnQ8YW55Piove1xuICAgIGNvbnN0IHtcbiAgICAgIGF4aXMsXG4gICAgICBib3VuZHMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGRlZmF1bHRQb3NpdGlvbixcbiAgICAgIGRlZmF1bHRDbGFzc05hbWUsXG4gICAgICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmcsXG4gICAgICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZCxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgcG9zaXRpb25PZmZzZXQsXG4gICAgICBzY2FsZSxcbiAgICAgIC4uLmRyYWdnYWJsZUNvcmVQcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCBzdHlsZSA9IHt9O1xuICAgIGxldCBzdmdUcmFuc2Zvcm0gPSBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBjb250cm9sbGVkLCB3ZSBkb24ndCB3YW50IHRvIG1vdmUgaXQgLSB1bmxlc3MgaXQncyBkcmFnZ2luZy5cbiAgICBjb25zdCBjb250cm9sbGVkID0gQm9vbGVhbihwb3NpdGlvbik7XG4gICAgY29uc3QgZHJhZ2dhYmxlID0gIWNvbnRyb2xsZWQgfHwgdGhpcy5zdGF0ZS5kcmFnZ2luZztcbiAgICBjb25zdCB2YWxpZFBvc2l0aW9uID0gcG9zaXRpb24gfHwgZGVmYXVsdFBvc2l0aW9uO1xuICAgIGNvbnN0IHRyYW5zZm9ybU9wdHMgPSB7XG4gICAgICAvLyBTZXQgbGVmdCBpZiBob3Jpem9udGFsIGRyYWcgaXMgZW5hYmxlZFxuICAgICAgeDogKDAsIF9wb3NpdGlvbkZucy5jYW5EcmFnWCkodGhpcykgJiYgZHJhZ2dhYmxlID8gdGhpcy5zdGF0ZS54IDogdmFsaWRQb3NpdGlvbi54LFxuICAgICAgLy8gU2V0IHRvcCBpZiB2ZXJ0aWNhbCBkcmFnIGlzIGVuYWJsZWRcbiAgICAgIHk6ICgwLCBfcG9zaXRpb25GbnMuY2FuRHJhZ1kpKHRoaXMpICYmIGRyYWdnYWJsZSA/IHRoaXMuc3RhdGUueSA6IHZhbGlkUG9zaXRpb24ueVxuICAgIH07XG5cbiAgICAvLyBJZiB0aGlzIGVsZW1lbnQgd2FzIFNWRywgd2UgdXNlIHRoZSBgdHJhbnNmb3JtYCBhdHRyaWJ1dGUuXG4gICAgaWYgKHRoaXMuc3RhdGUuaXNFbGVtZW50U1ZHKSB7XG4gICAgICBzdmdUcmFuc2Zvcm0gPSAoMCwgX2RvbUZucy5jcmVhdGVTVkdUcmFuc2Zvcm0pKHRyYW5zZm9ybU9wdHMsIHBvc2l0aW9uT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIGEgQ1NTIHRyYW5zZm9ybSB0byBtb3ZlIHRoZSBlbGVtZW50IGFyb3VuZC4gVGhpcyBhbGxvd3MgdXMgdG8gbW92ZSB0aGUgZWxlbWVudCBhcm91bmRcbiAgICAgIC8vIHdpdGhvdXQgd29ycnlpbmcgYWJvdXQgd2hldGhlciBvciBub3QgaXQgaXMgcmVsYXRpdmVseSBvciBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQuXG4gICAgICAvLyBJZiB0aGUgaXRlbSB5b3UgYXJlIGRyYWdnaW5nIGFscmVhZHkgaGFzIGEgdHJhbnNmb3JtIHNldCwgd3JhcCBpdCBpbiBhIDxzcGFuPiBzbyA8RHJhZ2dhYmxlPlxuICAgICAgLy8gaGFzIGEgY2xlYW4gc2xhdGUuXG4gICAgICBzdHlsZSA9ICgwLCBfZG9tRm5zLmNyZWF0ZUNTU1RyYW5zZm9ybSkodHJhbnNmb3JtT3B0cywgcG9zaXRpb25PZmZzZXQpO1xuICAgIH1cblxuICAgIC8vIE1hcmsgd2l0aCBjbGFzcyB3aGlsZSBkcmFnZ2luZ1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9ICgwLCBfY2xzeC5jbHN4KShjaGlsZHJlbi5wcm9wcy5jbGFzc05hbWUgfHwgJycsIGRlZmF1bHRDbGFzc05hbWUsIHtcbiAgICAgIFtkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmddOiB0aGlzLnN0YXRlLmRyYWdnaW5nLFxuICAgICAgW2RlZmF1bHRDbGFzc05hbWVEcmFnZ2VkXTogdGhpcy5zdGF0ZS5kcmFnZ2VkXG4gICAgfSk7XG5cbiAgICAvLyBSZXVzZSB0aGUgY2hpbGQgcHJvdmlkZWRcbiAgICAvLyBUaGlzIG1ha2VzIGl0IGZsZXhpYmxlIHRvIHVzZSB3aGF0ZXZlciBlbGVtZW50IGlzIHdhbnRlZCAoZGl2LCB1bCwgZXRjKVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChfRHJhZ2dhYmxlQ29yZS5kZWZhdWx0LCBfZXh0ZW5kcyh7fSwgZHJhZ2dhYmxlQ29yZVByb3BzLCB7XG4gICAgICBvblN0YXJ0OiB0aGlzLm9uRHJhZ1N0YXJ0LFxuICAgICAgb25EcmFnOiB0aGlzLm9uRHJhZyxcbiAgICAgIG9uU3RvcDogdGhpcy5vbkRyYWdTdG9wXG4gICAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbiksIHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgLi4uY2hpbGRyZW4ucHJvcHMuc3R5bGUsXG4gICAgICAgIC4uLnN0eWxlXG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtOiBzdmdUcmFuc2Zvcm1cbiAgICB9KSk7XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IERyYWdnYWJsZTtcbl9kZWZpbmVQcm9wZXJ0eShEcmFnZ2FibGUsIFwiZGlzcGxheU5hbWVcIiwgJ0RyYWdnYWJsZScpO1xuX2RlZmluZVByb3BlcnR5KERyYWdnYWJsZSwgXCJwcm9wVHlwZXNcIiwge1xuICAvLyBBY2NlcHRzIGFsbCBwcm9wcyA8RHJhZ2dhYmxlQ29yZT4gYWNjZXB0cy5cbiAgLi4uX0RyYWdnYWJsZUNvcmUuZGVmYXVsdC5wcm9wVHlwZXMsXG4gIC8qKlxuICAgKiBgYXhpc2AgZGV0ZXJtaW5lcyB3aGljaCBheGlzIHRoZSBkcmFnZ2FibGUgY2FuIG1vdmUuXG4gICAqXG4gICAqICBOb3RlIHRoYXQgYWxsIGNhbGxiYWNrcyB3aWxsIHN0aWxsIHJldHVybiBkYXRhIGFzIG5vcm1hbC4gVGhpcyBvbmx5XG4gICAqICBjb250cm9scyBmbHVzaGluZyB0byB0aGUgRE9NLlxuICAgKlxuICAgKiAnYm90aCcgYWxsb3dzIG1vdmVtZW50IGhvcml6b250YWxseSBhbmQgdmVydGljYWxseS5cbiAgICogJ3gnIGxpbWl0cyBtb3ZlbWVudCB0byBob3Jpem9udGFsIGF4aXMuXG4gICAqICd5JyBsaW1pdHMgbW92ZW1lbnQgdG8gdmVydGljYWwgYXhpcy5cbiAgICogJ25vbmUnIGxpbWl0cyBhbGwgbW92ZW1lbnQuXG4gICAqXG4gICAqIERlZmF1bHRzIHRvICdib3RoJy5cbiAgICovXG4gIGF4aXM6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbJ2JvdGgnLCAneCcsICd5JywgJ25vbmUnXSksXG4gIC8qKlxuICAgKiBgYm91bmRzYCBkZXRlcm1pbmVzIHRoZSByYW5nZSBvZiBtb3ZlbWVudCBhdmFpbGFibGUgdG8gdGhlIGVsZW1lbnQuXG4gICAqIEF2YWlsYWJsZSB2YWx1ZXMgYXJlOlxuICAgKlxuICAgKiAncGFyZW50JyByZXN0cmljdHMgbW92ZW1lbnQgd2l0aGluIHRoZSBEcmFnZ2FibGUncyBwYXJlbnQgbm9kZS5cbiAgICpcbiAgICogQWx0ZXJuYXRpdmVseSwgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMsIGFsbCBvZiB3aGljaCBhcmUgb3B0aW9uYWw6XG4gICAqXG4gICAqIHtsZWZ0OiBMRUZUX0JPVU5ELCByaWdodDogUklHSFRfQk9VTkQsIGJvdHRvbTogQk9UVE9NX0JPVU5ELCB0b3A6IFRPUF9CT1VORH1cbiAgICpcbiAgICogQWxsIHZhbHVlcyBhcmUgaW4gcHguXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiAgIGxldCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgKiAgICAgICAgIHJldHVybiAoXG4gICAqICAgICAgICAgICAgPERyYWdnYWJsZSBib3VuZHM9e3tyaWdodDogMzAwLCBib3R0b206IDMwMH19PlxuICAgKiAgICAgICAgICAgICAgPGRpdj5Db250ZW50PC9kaXY+XG4gICAqICAgICAgICAgICA8L0RyYWdnYWJsZT5cbiAgICogICAgICAgICApO1xuICAgKiAgICAgICB9XG4gICAqICAgfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgYm91bmRzOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICAgIGxlZnQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gICAgcmlnaHQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gICAgdG9wOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIGJvdHRvbTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlclxuICB9KSwgX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZywgX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mKFtmYWxzZV0pXSksXG4gIGRlZmF1bHRDbGFzc05hbWU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZzogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgZGVmYXVsdENsYXNzTmFtZURyYWdnZWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8qKlxuICAgKiBgZGVmYXVsdFBvc2l0aW9uYCBzcGVjaWZpZXMgdGhlIHggYW5kIHkgdGhhdCB0aGUgZHJhZ2dlZCBpdGVtIHNob3VsZCBzdGFydCBhdFxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogICAgICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICogICAgICAgICAgICAgIHJldHVybiAoXG4gICAqICAgICAgICAgICAgICAgICAgPERyYWdnYWJsZSBkZWZhdWx0UG9zaXRpb249e3t4OiAyNSwgeTogMjV9fT5cbiAgICogICAgICAgICAgICAgICAgICAgICAgPGRpdj5JIHN0YXJ0IHdpdGggdHJhbnNmb3JtWDogMjVweCBhbmQgdHJhbnNmb3JtWTogMjVweDs8L2Rpdj5cbiAgICogICAgICAgICAgICAgICAgICA8L0RyYWdnYWJsZT5cbiAgICogICAgICAgICAgICAgICk7XG4gICAqICAgICAgICAgIH1cbiAgICogICAgICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBkZWZhdWx0UG9zaXRpb246IF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgeDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICB5OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXG4gIH0pLFxuICBwb3NpdGlvbk9mZnNldDogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICB4OiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nXSksXG4gICAgeTogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlciwgX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZ10pXG4gIH0pLFxuICAvKipcbiAgICogYHBvc2l0aW9uYCwgaWYgcHJlc2VudCwgZGVmaW5lcyB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogIFRoaXMgaXMgc2ltaWxhciB0byBob3cgZm9ybSBlbGVtZW50cyBpbiBSZWFjdCB3b3JrIC0gaWYgbm8gYHBvc2l0aW9uYCBpcyBzdXBwbGllZCwgdGhlIGNvbXBvbmVudFxuICAgKiAgaXMgdW5jb250cm9sbGVkLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogICAgICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICogICAgICAgICAgICAgIHJldHVybiAoXG4gICAqICAgICAgICAgICAgICAgICAgPERyYWdnYWJsZSBwb3NpdGlvbj17e3g6IDI1LCB5OiAyNX19PlxuICAgKiAgICAgICAgICAgICAgICAgICAgICA8ZGl2Pkkgc3RhcnQgd2l0aCB0cmFuc2Zvcm1YOiAyNXB4IGFuZCB0cmFuc2Zvcm1ZOiAyNXB4OzwvZGl2PlxuICAgKiAgICAgICAgICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICAgICAgICAgICAgKTtcbiAgICogICAgICAgICAgfVxuICAgKiAgICAgIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIHBvc2l0aW9uOiBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICAgIHg6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gICAgeTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlclxuICB9KSxcbiAgLyoqXG4gICAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIGJlIGRlZmluZWQgb24gdGhlIGNoaWxkLCBub3QgaGVyZS5cbiAgICovXG4gIGNsYXNzTmFtZTogX3NoaW1zLmRvbnRTZXRNZSxcbiAgc3R5bGU6IF9zaGltcy5kb250U2V0TWUsXG4gIHRyYW5zZm9ybTogX3NoaW1zLmRvbnRTZXRNZVxufSk7XG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIC4uLl9EcmFnZ2FibGVDb3JlLmRlZmF1bHQuZGVmYXVsdFByb3BzLFxuICBheGlzOiAnYm90aCcsXG4gIGJvdW5kczogZmFsc2UsXG4gIGRlZmF1bHRDbGFzc05hbWU6ICdyZWFjdC1kcmFnZ2FibGUnLFxuICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmc6ICdyZWFjdC1kcmFnZ2FibGUtZHJhZ2dpbmcnLFxuICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZDogJ3JlYWN0LWRyYWdnYWJsZS1kcmFnZ2VkJyxcbiAgZGVmYXVsdFBvc2l0aW9uOiB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH0sXG4gIHNjYWxlOiAxXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX0RyYWdnYWJsZUNvcmUiLCJkZWZhdWx0IiwiUmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfcHJvcFR5cGVzIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9yZWFjdERvbSIsIl9jbHN4IiwiX2RvbUZucyIsIl9wb3NpdGlvbkZucyIsIl9zaGltcyIsIl9sb2ciLCJlIiwiX19lc01vZHVsZSIsInQiLCJXZWFrTWFwIiwiciIsIm4iLCJvIiwiaSIsImYiLCJfX3Byb3RvX18iLCJoYXMiLCJzZXQiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcHBseSIsIl9kZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIkRyYWdnYWJsZSIsIkNvbXBvbmVudCIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIl9yZWYiLCJfcmVmMiIsInBvc2l0aW9uIiwicHJldlByb3BzUG9zaXRpb24iLCJ4IiwieSIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJjb3JlRGF0YSIsInNob3VsZFN0YXJ0Iiwib25TdGFydCIsImNyZWF0ZURyYWdnYWJsZURhdGEiLCJzZXRTdGF0ZSIsImRyYWdnaW5nIiwiZHJhZ2dlZCIsInN0YXRlIiwidWlEYXRhIiwibmV3U3RhdGUiLCJzbGFja1giLCJzbGFja1kiLCJib3VuZHMiLCJuZXdTdGF0ZVgiLCJuZXdTdGF0ZVkiLCJnZXRCb3VuZFBvc2l0aW9uIiwiZGVsdGFYIiwiZGVsdGFZIiwic2hvdWxkVXBkYXRlIiwib25EcmFnIiwic2hvdWxkQ29udGludWUiLCJvblN0b3AiLCJjb250cm9sbGVkIiwiQm9vbGVhbiIsImRlZmF1bHRQb3NpdGlvbiIsImlzRWxlbWVudFNWRyIsImNvbnNvbGUiLCJ3YXJuIiwiY29tcG9uZW50RGlkTW91bnQiLCJ3aW5kb3ciLCJTVkdFbGVtZW50IiwiZmluZERPTU5vZGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIm5vZGVSZWYiLCJjdXJyZW50IiwicmVuZGVyIiwiYXhpcyIsImNoaWxkcmVuIiwiZGVmYXVsdENsYXNzTmFtZSIsImRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZyIsImRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkIiwicG9zaXRpb25PZmZzZXQiLCJzY2FsZSIsImRyYWdnYWJsZUNvcmVQcm9wcyIsInN0eWxlIiwic3ZnVHJhbnNmb3JtIiwiZHJhZ2dhYmxlIiwidmFsaWRQb3NpdGlvbiIsInRyYW5zZm9ybU9wdHMiLCJjYW5EcmFnWCIsImNhbkRyYWdZIiwiY3JlYXRlU1ZHVHJhbnNmb3JtIiwiY3JlYXRlQ1NTVHJhbnNmb3JtIiwiY2xhc3NOYW1lIiwiY2xzeCIsImNyZWF0ZUVsZW1lbnQiLCJvbkRyYWdTdGFydCIsIm9uRHJhZ1N0b3AiLCJjbG9uZUVsZW1lbnQiLCJDaGlsZHJlbiIsIm9ubHkiLCJ0cmFuc2Zvcm0iLCJwcm9wVHlwZXMiLCJvbmVPZiIsIm9uZU9mVHlwZSIsInNoYXBlIiwibGVmdCIsIm51bWJlciIsInJpZ2h0IiwidG9wIiwiYm90dG9tIiwic3RyaW5nIiwiZG9udFNldE1lIiwiZGVmYXVsdFByb3BzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/Draggable.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/DraggableCore.js":
/*!**********************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/DraggableCore.js ***!
  \**********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/../../node_modules/.pnpm/next@14.1.0_@babel+core@7.27.7_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/../../node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js\"));\nvar _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ \"(ssr)/../../node_modules/.pnpm/next@14.1.0_@babel+core@7.27.7_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\"));\nvar _domFns = __webpack_require__(/*! ./utils/domFns */ \"(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/domFns.js\");\nvar _positionFns = __webpack_require__(/*! ./utils/positionFns */ \"(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/positionFns.js\");\nvar _shims = __webpack_require__(/*! ./utils/shims */ \"(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _log = _interopRequireDefault(__webpack_require__(/*! ./utils/log */ \"(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/log.js\"));\nfunction _interopRequireDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nfunction _interopRequireWildcard(e, t) {\n    if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();\n    return (_interopRequireWildcard = function(e, t) {\n        if (!t && e && e.__esModule) return e;\n        var o, i, f = {\n            __proto__: null,\n            default: e\n        };\n        if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f;\n        if (o = t ? n : r) {\n            if (o.has(e)) return o.get(e);\n            o.set(e, f);\n        }\n        for(const t in e)\"default\" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);\n        return f;\n    })(e, t);\n}\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n/*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/ /*:: import type {Element as ReactElement} from 'react';*/ // Simple abstraction for dragging events names.\nconst eventsFor = {\n    touch: {\n        start: \"touchstart\",\n        move: \"touchmove\",\n        stop: \"touchend\"\n    },\n    mouse: {\n        start: \"mousedown\",\n        move: \"mousemove\",\n        stop: \"mouseup\"\n    }\n};\n// Default to mouse events.\nlet dragEventFor = eventsFor.mouse;\n/*:: export type DraggableData = {\n  node: HTMLElement,\n  x: number, y: number,\n  deltaX: number, deltaY: number,\n  lastX: number, lastY: number,\n};*/ /*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void | false;*/ /*:: export type ControlPosition = {x: number, y: number};*/ /*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/ /*:: export type DraggableCoreDefaultProps = {\n  allowAnyClick: boolean,\n  allowMobileScroll: boolean,\n  disabled: boolean,\n  enableUserSelectHack: boolean,\n  onStart: DraggableEventHandler,\n  onDrag: DraggableEventHandler,\n  onStop: DraggableEventHandler,\n  onMouseDown: (e: MouseEvent) => void,\n  scale: number,\n};*/ /*:: export type DraggableCoreProps = {\n  ...DraggableCoreDefaultProps,\n  cancel: string,\n  children: ReactElement<any>,\n  offsetParent: HTMLElement,\n  grid: [number, number],\n  handle: string,\n  nodeRef?: ?React.ElementRef<any>,\n};*/ //\n// Define <DraggableCore>.\n//\n// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can\n// work well with libraries that require more control over the element.\n//\nclass DraggableCore extends React.Component /*:: <DraggableCoreProps>*/  {\n    constructor(){\n        super(...arguments);\n        _defineProperty(this, \"dragging\", false);\n        // Used while dragging to determine deltas.\n        _defineProperty(this, \"lastX\", NaN);\n        _defineProperty(this, \"lastY\", NaN);\n        _defineProperty(this, \"touchIdentifier\", null);\n        _defineProperty(this, \"mounted\", false);\n        _defineProperty(this, \"handleDragStart\", (e)=>{\n            // Make it possible to attach event handlers on top of this one.\n            this.props.onMouseDown(e);\n            // Only accept left-clicks.\n            if (!this.props.allowAnyClick && typeof e.button === \"number\" && e.button !== 0) return false;\n            // Get nodes. Be sure to grab relative document (could be iframed)\n            const thisNode = this.findDOMNode();\n            if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {\n                throw new Error(\"<DraggableCore> not mounted on DragStart!\");\n            }\n            const { ownerDocument } = thisNode;\n            // Short circuit if handle or cancel prop was provided and selector doesn't match.\n            if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.cancel, thisNode)) {\n                return;\n            }\n            // Prevent scrolling on mobile devices, like ipad/iphone.\n            // Important that this is after handle/cancel.\n            if (e.type === \"touchstart\" && !this.props.allowMobileScroll) e.preventDefault();\n            // Set touch identifier in component state if this is a touch event. This allows us to\n            // distinguish between individual touches on multitouch screens by identifying which\n            // touchpoint was set to this element.\n            const touchIdentifier = (0, _domFns.getTouchIdentifier)(e);\n            this.touchIdentifier = touchIdentifier;\n            // Get the current drag point from the event. This is used as the offset.\n            const position = (0, _positionFns.getControlPosition)(e, touchIdentifier, this);\n            if (position == null) return; // not possible but satisfies flow\n            const { x, y } = position;\n            // Create an event object with all the data parents need to make a decision here.\n            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n            (0, _log.default)(\"DraggableCore: handleDragStart: %j\", coreEvent);\n            // Call event handler. If it returns explicit false, cancel.\n            (0, _log.default)(\"calling\", this.props.onStart);\n            const shouldUpdate = this.props.onStart(e, coreEvent);\n            if (shouldUpdate === false || this.mounted === false) return;\n            // Add a style to the body to disable user-select. This prevents text from\n            // being selected all over the page.\n            if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);\n            // Initiate dragging. Set the current x and y as offsets\n            // so we know how much we've moved during the drag. This allows us\n            // to drag elements around even if they have been moved, without issue.\n            this.dragging = true;\n            this.lastX = x;\n            this.lastY = y;\n            // Add events to the document directly so we catch when the user's mouse/touch moves outside of\n            // this element. We use different events depending on whether or not we have detected that this\n            // is a touch-capable device.\n            (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);\n            (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);\n        });\n        _defineProperty(this, \"handleDrag\", (e)=>{\n            // Get the current drag point from the event. This is used as the offset.\n            const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n            if (position == null) return;\n            let { x, y } = position;\n            // Snap to grid if prop has been provided\n            if (Array.isArray(this.props.grid)) {\n                let deltaX = x - this.lastX, deltaY = y - this.lastY;\n                [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n                if (!deltaX && !deltaY) return; // skip useless drag\n                x = this.lastX + deltaX, y = this.lastY + deltaY;\n            }\n            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n            (0, _log.default)(\"DraggableCore: handleDrag: %j\", coreEvent);\n            // Call event handler. If it returns explicit false, trigger end.\n            const shouldUpdate = this.props.onDrag(e, coreEvent);\n            if (shouldUpdate === false || this.mounted === false) {\n                try {\n                    // $FlowIgnore\n                    this.handleDragStop(new MouseEvent(\"mouseup\"));\n                } catch (err) {\n                    // Old browsers\n                    const event = document.createEvent(\"MouseEvents\");\n                    // I see why this insanity was deprecated\n                    // $FlowIgnore\n                    event.initMouseEvent(\"mouseup\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n                    this.handleDragStop(event);\n                }\n                return;\n            }\n            this.lastX = x;\n            this.lastY = y;\n        });\n        _defineProperty(this, \"handleDragStop\", (e)=>{\n            if (!this.dragging) return;\n            const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n            if (position == null) return;\n            let { x, y } = position;\n            // Snap to grid if prop has been provided\n            if (Array.isArray(this.props.grid)) {\n                let deltaX = x - this.lastX || 0;\n                let deltaY = y - this.lastY || 0;\n                [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n                x = this.lastX + deltaX, y = this.lastY + deltaY;\n            }\n            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n            // Call event handler\n            const shouldContinue = this.props.onStop(e, coreEvent);\n            if (shouldContinue === false || this.mounted === false) return false;\n            const thisNode = this.findDOMNode();\n            if (thisNode) {\n                // Remove user-select hack\n                if (this.props.enableUserSelectHack) (0, _domFns.scheduleRemoveUserSelectStyles)(thisNode.ownerDocument);\n            }\n            (0, _log.default)(\"DraggableCore: handleDragStop: %j\", coreEvent);\n            // Reset the el.\n            this.dragging = false;\n            this.lastX = NaN;\n            this.lastY = NaN;\n            if (thisNode) {\n                // Remove event handlers\n                (0, _log.default)(\"DraggableCore: Removing handlers\");\n                (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);\n                (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);\n            }\n        });\n        _defineProperty(this, \"onMouseDown\", (e)=>{\n            dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse\n            return this.handleDragStart(e);\n        });\n        _defineProperty(this, \"onMouseUp\", (e)=>{\n            dragEventFor = eventsFor.mouse;\n            return this.handleDragStop(e);\n        });\n        // Same as onMouseDown (start drag), but now consider this a touch device.\n        _defineProperty(this, \"onTouchStart\", (e)=>{\n            // We're on a touch device now, so change the event handlers\n            dragEventFor = eventsFor.touch;\n            return this.handleDragStart(e);\n        });\n        _defineProperty(this, \"onTouchEnd\", (e)=>{\n            // We're on a touch device now, so change the event handlers\n            dragEventFor = eventsFor.touch;\n            return this.handleDragStop(e);\n        });\n    }\n    componentDidMount() {\n        this.mounted = true;\n        // Touch handlers must be added with {passive: false} to be cancelable.\n        // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n        const thisNode = this.findDOMNode();\n        if (thisNode) {\n            (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n                passive: false\n            });\n        }\n    }\n    componentWillUnmount() {\n        this.mounted = false;\n        // Remove any leftover event handlers. Remove both touch and mouse handlers in case\n        // some browser quirk caused a touch event to fire during a mouse move, or vice versa.\n        const thisNode = this.findDOMNode();\n        if (thisNode) {\n            const { ownerDocument } = thisNode;\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);\n            (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n                passive: false\n            });\n            if (this.props.enableUserSelectHack) (0, _domFns.scheduleRemoveUserSelectStyles)(ownerDocument);\n        }\n    }\n    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n    // the underlying DOM node ourselves. See the README for more information.\n    findDOMNode() /*: ?HTMLElement*/ {\n        return this.props?.nodeRef ? this.props?.nodeRef?.current : _reactDom.default.findDOMNode(this);\n    }\n    render() /*: React.Element<any>*/ {\n        // Reuse the child provided\n        // This makes it flexible to use whatever element is wanted (div, ul, etc)\n        return /*#__PURE__*/ React.cloneElement(React.Children.only(this.props.children), {\n            // Note: mouseMove handler is attached to document so it will still function\n            // when the user drags quickly and leaves the bounds of the element.\n            onMouseDown: this.onMouseDown,\n            onMouseUp: this.onMouseUp,\n            // onTouchStart is added on `componentDidMount` so they can be added with\n            // {passive: false}, which allows it to cancel. See\n            // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n            onTouchEnd: this.onTouchEnd\n        });\n    }\n}\nexports[\"default\"] = DraggableCore;\n_defineProperty(DraggableCore, \"displayName\", \"DraggableCore\");\n_defineProperty(DraggableCore, \"propTypes\", {\n    /**\n   * `allowAnyClick` allows dragging using any mouse button.\n   * By default, we only accept the left button.\n   *\n   * Defaults to `false`.\n   */ allowAnyClick: _propTypes.default.bool,\n    /**\n   * `allowMobileScroll` turns off cancellation of the 'touchstart' event\n   * on mobile devices. Only enable this if you are having trouble with click\n   * events. Prefer using 'handle' / 'cancel' instead.\n   *\n   * Defaults to `false`.\n   */ allowMobileScroll: _propTypes.default.bool,\n    children: _propTypes.default.node.isRequired,\n    /**\n   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,\n   * with the exception of `onMouseDown`, will not fire.\n   */ disabled: _propTypes.default.bool,\n    /**\n   * By default, we add 'user-select:none' attributes to the document body\n   * to prevent ugly text selection during drag. If this is causing problems\n   * for your app, set this to `false`.\n   */ enableUserSelectHack: _propTypes.default.bool,\n    /**\n   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets\n   * instead of using the parent node.\n   */ offsetParent: function(props /*: DraggableCoreProps*/ , propName /*: $Keys<DraggableCoreProps>*/ ) {\n        if (props[propName] && props[propName].nodeType !== 1) {\n            throw new Error(\"Draggable's offsetParent must be a DOM Node.\");\n        }\n    },\n    /**\n   * `grid` specifies the x and y that dragging should snap to.\n   */ grid: _propTypes.default.arrayOf(_propTypes.default.number),\n    /**\n   * `handle` specifies a selector to be used as the handle that initiates drag.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable handle=\".handle\">\n   *              <div>\n   *                  <div className=\"handle\">Click me to drag</div>\n   *                  <div>This is some other content</div>\n   *              </div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */ handle: _propTypes.default.string,\n    /**\n   * `cancel` specifies a selector to be used to prevent drag initialization.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *           return(\n   *               <Draggable cancel=\".cancel\">\n   *                   <div>\n   *                     <div className=\"cancel\">You can't drag from here</div>\n   *                     <div>Dragging here works fine</div>\n   *                   </div>\n   *               </Draggable>\n   *           );\n   *       }\n   *   });\n   * ```\n   */ cancel: _propTypes.default.string,\n    /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.\n   * Unfortunately, in order for <Draggable> to work properly, we need raw access\n   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`\n   * as in this example:\n   *\n   * function MyComponent() {\n   *   const nodeRef = React.useRef(null);\n   *   return (\n   *     <Draggable nodeRef={nodeRef}>\n   *       <div ref={nodeRef}>Example Target</div>\n   *     </Draggable>\n   *   );\n   * }\n   *\n   * This can be used for arbitrarily nested components, so long as the ref ends up\n   * pointing to the actual child DOM node and not a custom component.\n   */ nodeRef: _propTypes.default.object,\n    /**\n   * Called when dragging starts.\n   * If this function returns the boolean false, dragging will be canceled.\n   */ onStart: _propTypes.default.func,\n    /**\n   * Called while dragging.\n   * If this function returns the boolean false, dragging will be canceled.\n   */ onDrag: _propTypes.default.func,\n    /**\n   * Called when dragging stops.\n   * If this function returns the boolean false, the drag will remain active.\n   */ onStop: _propTypes.default.func,\n    /**\n   * A workaround option which can be passed if onMouseDown needs to be accessed,\n   * since it'll always be blocked (as there is internal use of onMouseDown)\n   */ onMouseDown: _propTypes.default.func,\n    /**\n   * `scale`, if set, applies scaling while dragging an element\n   */ scale: _propTypes.default.number,\n    /**\n   * These properties should be defined on the child, not here.\n   */ className: _shims.dontSetMe,\n    style: _shims.dontSetMe,\n    transform: _shims.dontSetMe\n});\n_defineProperty(DraggableCore, \"defaultProps\", {\n    allowAnyClick: false,\n    // by default only accept left click\n    allowMobileScroll: false,\n    disabled: false,\n    enableUserSelectHack: true,\n    onStart: function() {},\n    onDrag: function() {},\n    onStop: function() {},\n    onMouseDown: function() {},\n    scale: 1\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRyYWdnYWJsZUA0LjUuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL0RyYWdnYWJsZUNvcmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJRyxRQUFRQyx3QkFBd0JDLG1CQUFPQSxDQUFDLDBNQUFPO0FBQ25ELElBQUlDLGFBQWFDLHVCQUF1QkYsbUJBQU9BLENBQUMscUdBQVk7QUFDNUQsSUFBSUcsWUFBWUQsdUJBQXVCRixtQkFBT0EsQ0FBQyxrTkFBVztBQUMxRCxJQUFJSSxVQUFVSixtQkFBT0EsQ0FBQywrS0FBZ0I7QUFDdEMsSUFBSUssZUFBZUwsbUJBQU9BLENBQUMseUxBQXFCO0FBQ2hELElBQUlNLFNBQVNOLG1CQUFPQSxDQUFDLDZLQUFlO0FBQ3BDLElBQUlPLE9BQU9MLHVCQUF1QkYsbUJBQU9BLENBQUMseUtBQWE7QUFDdkQsU0FBU0UsdUJBQXVCTSxDQUFDO0lBQUksT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxHQUFHRCxJQUFJO1FBQUVYLFNBQVNXO0lBQUU7QUFBRztBQUNwRixTQUFTVCx3QkFBd0JTLENBQUMsRUFBRUUsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ1osMEJBQTBCLFNBQVVTLENBQUMsRUFBRUUsQ0FBQztRQUFJLElBQUksQ0FBQ0EsS0FBS0YsS0FBS0EsRUFBRUMsVUFBVSxFQUFFLE9BQU9EO1FBQUcsSUFBSU0sR0FBR0MsR0FBR0MsSUFBSTtZQUFFQyxXQUFXO1lBQU1wQixTQUFTVztRQUFFO1FBQUcsSUFBSSxTQUFTQSxLQUFLLFlBQVks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QjtBQUNBMUcsZ0JBQWdCa0IsZUFBZSxnQkFBZ0I7SUFDN0NPLGVBQWU7SUFDZixvQ0FBb0M7SUFDcENlLG1CQUFtQjtJQUNuQlIsVUFBVTtJQUNWcUIsc0JBQXNCO0lBQ3RCSCxTQUFTLFlBQWE7SUFDdEJpQixRQUFRLFlBQWE7SUFDckJTLFFBQVEsWUFBYTtJQUNyQnBELGFBQWEsWUFBYTtJQUMxQmdGLE9BQU87QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL0BtaWRpdml6L3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZHJhZ2dhYmxlQDQuNS4wX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvRHJhZ2dhYmxlQ29yZS5qcz80YzM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG52YXIgX3JlYWN0RG9tID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbnZhciBfZG9tRm5zID0gcmVxdWlyZShcIi4vdXRpbHMvZG9tRm5zXCIpO1xudmFyIF9wb3NpdGlvbkZucyA9IHJlcXVpcmUoXCIuL3V0aWxzL3Bvc2l0aW9uRm5zXCIpO1xudmFyIF9zaGltcyA9IHJlcXVpcmUoXCIuL3V0aWxzL3NoaW1zXCIpO1xudmFyIF9sb2cgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL2xvZ1wiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCB0KSB7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFdlYWtNYXApIHZhciByID0gbmV3IFdlYWtNYXAoKSwgbiA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSBmdW5jdGlvbiAoZSwgdCkgeyBpZiAoIXQgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyB2YXIgbywgaSwgZiA9IHsgX19wcm90b19fOiBudWxsLCBkZWZhdWx0OiBlIH07IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGUgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4gZjsgaWYgKG8gPSB0ID8gbiA6IHIpIHsgaWYgKG8uaGFzKGUpKSByZXR1cm4gby5nZXQoZSk7IG8uc2V0KGUsIGYpOyB9IGZvciAoY29uc3QgdCBpbiBlKSBcImRlZmF1bHRcIiAhPT0gdCAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHQpICYmICgoaSA9IChvID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHQpKSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gbyhmLCB0LCBpKSA6IGZbdF0gPSBlW3RdKTsgcmV0dXJuIGY7IH0pKGUsIHQpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vKjo6IGltcG9ydCB0eXBlIHtFdmVudEhhbmRsZXIsIE1vdXNlVG91Y2hFdmVudH0gZnJvbSAnLi91dGlscy90eXBlcyc7Ki9cbi8qOjogaW1wb3J0IHR5cGUge0VsZW1lbnQgYXMgUmVhY3RFbGVtZW50fSBmcm9tICdyZWFjdCc7Ki9cbi8vIFNpbXBsZSBhYnN0cmFjdGlvbiBmb3IgZHJhZ2dpbmcgZXZlbnRzIG5hbWVzLlxuY29uc3QgZXZlbnRzRm9yID0ge1xuICB0b3VjaDoge1xuICAgIHN0YXJ0OiAndG91Y2hzdGFydCcsXG4gICAgbW92ZTogJ3RvdWNobW92ZScsXG4gICAgc3RvcDogJ3RvdWNoZW5kJ1xuICB9LFxuICBtb3VzZToge1xuICAgIHN0YXJ0OiAnbW91c2Vkb3duJyxcbiAgICBtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgICBzdG9wOiAnbW91c2V1cCdcbiAgfVxufTtcblxuLy8gRGVmYXVsdCB0byBtb3VzZSBldmVudHMuXG5sZXQgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLm1vdXNlO1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVEYXRhID0ge1xuICBub2RlOiBIVE1MRWxlbWVudCxcbiAgeDogbnVtYmVyLCB5OiBudW1iZXIsXG4gIGRlbHRhWDogbnVtYmVyLCBkZWx0YVk6IG51bWJlcixcbiAgbGFzdFg6IG51bWJlciwgbGFzdFk6IG51bWJlcixcbn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgRHJhZ2dhYmxlRXZlbnRIYW5kbGVyID0gKGU6IE1vdXNlRXZlbnQsIGRhdGE6IERyYWdnYWJsZURhdGEpID0+IHZvaWQgfCBmYWxzZTsqL1xuLyo6OiBleHBvcnQgdHlwZSBDb250cm9sUG9zaXRpb24gPSB7eDogbnVtYmVyLCB5OiBudW1iZXJ9OyovXG4vKjo6IGV4cG9ydCB0eXBlIFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uID0ge3g6IG51bWJlcnxzdHJpbmcsIHk6IG51bWJlcnxzdHJpbmd9OyovXG4vKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZUNvcmVEZWZhdWx0UHJvcHMgPSB7XG4gIGFsbG93QW55Q2xpY2s6IGJvb2xlYW4sXG4gIGFsbG93TW9iaWxlU2Nyb2xsOiBib29sZWFuLFxuICBkaXNhYmxlZDogYm9vbGVhbixcbiAgZW5hYmxlVXNlclNlbGVjdEhhY2s6IGJvb2xlYW4sXG4gIG9uU3RhcnQ6IERyYWdnYWJsZUV2ZW50SGFuZGxlcixcbiAgb25EcmFnOiBEcmFnZ2FibGVFdmVudEhhbmRsZXIsXG4gIG9uU3RvcDogRHJhZ2dhYmxlRXZlbnRIYW5kbGVyLFxuICBvbk1vdXNlRG93bjogKGU6IE1vdXNlRXZlbnQpID0+IHZvaWQsXG4gIHNjYWxlOiBudW1iZXIsXG59OyovXG4vKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZUNvcmVQcm9wcyA9IHtcbiAgLi4uRHJhZ2dhYmxlQ29yZURlZmF1bHRQcm9wcyxcbiAgY2FuY2VsOiBzdHJpbmcsXG4gIGNoaWxkcmVuOiBSZWFjdEVsZW1lbnQ8YW55PixcbiAgb2Zmc2V0UGFyZW50OiBIVE1MRWxlbWVudCxcbiAgZ3JpZDogW251bWJlciwgbnVtYmVyXSxcbiAgaGFuZGxlOiBzdHJpbmcsXG4gIG5vZGVSZWY/OiA/UmVhY3QuRWxlbWVudFJlZjxhbnk+LFxufTsqL1xuLy9cbi8vIERlZmluZSA8RHJhZ2dhYmxlQ29yZT4uXG4vL1xuLy8gPERyYWdnYWJsZUNvcmU+IGlzIGZvciBhZHZhbmNlZCB1c2FnZSBvZiA8RHJhZ2dhYmxlPi4gSXQgbWFpbnRhaW5zIG1pbmltYWwgaW50ZXJuYWwgc3RhdGUgc28gaXQgY2FuXG4vLyB3b3JrIHdlbGwgd2l0aCBsaWJyYXJpZXMgdGhhdCByZXF1aXJlIG1vcmUgY29udHJvbCBvdmVyIHRoZSBlbGVtZW50LlxuLy9cblxuY2xhc3MgRHJhZ2dhYmxlQ29yZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCAvKjo6IDxEcmFnZ2FibGVDb3JlUHJvcHM+Ki97XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZHJhZ2dpbmdcIiwgZmFsc2UpO1xuICAgIC8vIFVzZWQgd2hpbGUgZHJhZ2dpbmcgdG8gZGV0ZXJtaW5lIGRlbHRhcy5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYXN0WFwiLCBOYU4pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhc3RZXCIsIE5hTik7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG91Y2hJZGVudGlmaWVyXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vdW50ZWRcIiwgZmFsc2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYWdTdGFydFwiLCBlID0+IHtcbiAgICAgIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gYXR0YWNoIGV2ZW50IGhhbmRsZXJzIG9uIHRvcCBvZiB0aGlzIG9uZS5cbiAgICAgIHRoaXMucHJvcHMub25Nb3VzZURvd24oZSk7XG5cbiAgICAgIC8vIE9ubHkgYWNjZXB0IGxlZnQtY2xpY2tzLlxuICAgICAgaWYgKCF0aGlzLnByb3BzLmFsbG93QW55Q2xpY2sgJiYgdHlwZW9mIGUuYnV0dG9uID09PSAnbnVtYmVyJyAmJiBlLmJ1dHRvbiAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBHZXQgbm9kZXMuIEJlIHN1cmUgdG8gZ3JhYiByZWxhdGl2ZSBkb2N1bWVudCAoY291bGQgYmUgaWZyYW1lZClcbiAgICAgIGNvbnN0IHRoaXNOb2RlID0gdGhpcy5maW5kRE9NTm9kZSgpO1xuICAgICAgaWYgKCF0aGlzTm9kZSB8fCAhdGhpc05vZGUub3duZXJEb2N1bWVudCB8fCAhdGhpc05vZGUub3duZXJEb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignPERyYWdnYWJsZUNvcmU+IG5vdCBtb3VudGVkIG9uIERyYWdTdGFydCEnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3duZXJEb2N1bWVudFxuICAgICAgfSA9IHRoaXNOb2RlO1xuXG4gICAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIGhhbmRsZSBvciBjYW5jZWwgcHJvcCB3YXMgcHJvdmlkZWQgYW5kIHNlbGVjdG9yIGRvZXNuJ3QgbWF0Y2guXG4gICAgICBpZiAodGhpcy5wcm9wcy5kaXNhYmxlZCB8fCAhKGUudGFyZ2V0IGluc3RhbmNlb2Ygb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5Ob2RlKSB8fCB0aGlzLnByb3BzLmhhbmRsZSAmJiAhKDAsIF9kb21GbnMubWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvKShlLnRhcmdldCwgdGhpcy5wcm9wcy5oYW5kbGUsIHRoaXNOb2RlKSB8fCB0aGlzLnByb3BzLmNhbmNlbCAmJiAoMCwgX2RvbUZucy5tYXRjaGVzU2VsZWN0b3JBbmRQYXJlbnRzVG8pKGUudGFyZ2V0LCB0aGlzLnByb3BzLmNhbmNlbCwgdGhpc05vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmcgb24gbW9iaWxlIGRldmljZXMsIGxpa2UgaXBhZC9pcGhvbmUuXG4gICAgICAvLyBJbXBvcnRhbnQgdGhhdCB0aGlzIGlzIGFmdGVyIGhhbmRsZS9jYW5jZWwuXG4gICAgICBpZiAoZS50eXBlID09PSAndG91Y2hzdGFydCcgJiYgIXRoaXMucHJvcHMuYWxsb3dNb2JpbGVTY3JvbGwpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgLy8gU2V0IHRvdWNoIGlkZW50aWZpZXIgaW4gY29tcG9uZW50IHN0YXRlIGlmIHRoaXMgaXMgYSB0b3VjaCBldmVudC4gVGhpcyBhbGxvd3MgdXMgdG9cbiAgICAgIC8vIGRpc3Rpbmd1aXNoIGJldHdlZW4gaW5kaXZpZHVhbCB0b3VjaGVzIG9uIG11bHRpdG91Y2ggc2NyZWVucyBieSBpZGVudGlmeWluZyB3aGljaFxuICAgICAgLy8gdG91Y2hwb2ludCB3YXMgc2V0IHRvIHRoaXMgZWxlbWVudC5cbiAgICAgIGNvbnN0IHRvdWNoSWRlbnRpZmllciA9ICgwLCBfZG9tRm5zLmdldFRvdWNoSWRlbnRpZmllcikoZSk7XG4gICAgICB0aGlzLnRvdWNoSWRlbnRpZmllciA9IHRvdWNoSWRlbnRpZmllcjtcblxuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGRyYWcgcG9pbnQgZnJvbSB0aGUgZXZlbnQuIFRoaXMgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0LlxuICAgICAgY29uc3QgcG9zaXRpb24gPSAoMCwgX3Bvc2l0aW9uRm5zLmdldENvbnRyb2xQb3NpdGlvbikoZSwgdG91Y2hJZGVudGlmaWVyLCB0aGlzKTtcbiAgICAgIGlmIChwb3NpdGlvbiA9PSBudWxsKSByZXR1cm47IC8vIG5vdCBwb3NzaWJsZSBidXQgc2F0aXNmaWVzIGZsb3dcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHBvc2l0aW9uO1xuXG4gICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgb2JqZWN0IHdpdGggYWxsIHRoZSBkYXRhIHBhcmVudHMgbmVlZCB0byBtYWtlIGEgZGVjaXNpb24gaGVyZS5cbiAgICAgIGNvbnN0IGNvcmVFdmVudCA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlQ29yZURhdGEpKHRoaXMsIHgsIHkpO1xuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IGhhbmRsZURyYWdTdGFydDogJWonLCBjb3JlRXZlbnQpO1xuXG4gICAgICAvLyBDYWxsIGV2ZW50IGhhbmRsZXIuIElmIGl0IHJldHVybnMgZXhwbGljaXQgZmFsc2UsIGNhbmNlbC5cbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdjYWxsaW5nJywgdGhpcy5wcm9wcy5vblN0YXJ0KTtcbiAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZSA9IHRoaXMucHJvcHMub25TdGFydChlLCBjb3JlRXZlbnQpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5tb3VudGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAvLyBBZGQgYSBzdHlsZSB0byB0aGUgYm9keSB0byBkaXNhYmxlIHVzZXItc2VsZWN0LiBUaGlzIHByZXZlbnRzIHRleHQgZnJvbVxuICAgICAgLy8gYmVpbmcgc2VsZWN0ZWQgYWxsIG92ZXIgdGhlIHBhZ2UuXG4gICAgICBpZiAodGhpcy5wcm9wcy5lbmFibGVVc2VyU2VsZWN0SGFjaykgKDAsIF9kb21GbnMuYWRkVXNlclNlbGVjdFN0eWxlcykob3duZXJEb2N1bWVudCk7XG5cbiAgICAgIC8vIEluaXRpYXRlIGRyYWdnaW5nLiBTZXQgdGhlIGN1cnJlbnQgeCBhbmQgeSBhcyBvZmZzZXRzXG4gICAgICAvLyBzbyB3ZSBrbm93IGhvdyBtdWNoIHdlJ3ZlIG1vdmVkIGR1cmluZyB0aGUgZHJhZy4gVGhpcyBhbGxvd3MgdXNcbiAgICAgIC8vIHRvIGRyYWcgZWxlbWVudHMgYXJvdW5kIGV2ZW4gaWYgdGhleSBoYXZlIGJlZW4gbW92ZWQsIHdpdGhvdXQgaXNzdWUuXG4gICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMubGFzdFggPSB4O1xuICAgICAgdGhpcy5sYXN0WSA9IHk7XG5cbiAgICAgIC8vIEFkZCBldmVudHMgdG8gdGhlIGRvY3VtZW50IGRpcmVjdGx5IHNvIHdlIGNhdGNoIHdoZW4gdGhlIHVzZXIncyBtb3VzZS90b3VjaCBtb3ZlcyBvdXRzaWRlIG9mXG4gICAgICAvLyB0aGlzIGVsZW1lbnQuIFdlIHVzZSBkaWZmZXJlbnQgZXZlbnRzIGRlcGVuZGluZyBvbiB3aGV0aGVyIG9yIG5vdCB3ZSBoYXZlIGRldGVjdGVkIHRoYXQgdGhpc1xuICAgICAgLy8gaXMgYSB0b3VjaC1jYXBhYmxlIGRldmljZS5cbiAgICAgICgwLCBfZG9tRm5zLmFkZEV2ZW50KShvd25lckRvY3VtZW50LCBkcmFnRXZlbnRGb3IubW92ZSwgdGhpcy5oYW5kbGVEcmFnKTtcbiAgICAgICgwLCBfZG9tRm5zLmFkZEV2ZW50KShvd25lckRvY3VtZW50LCBkcmFnRXZlbnRGb3Iuc3RvcCwgdGhpcy5oYW5kbGVEcmFnU3RvcCk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhZ1wiLCBlID0+IHtcbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBkcmFnIHBvaW50IGZyb20gdGhlIGV2ZW50LiBUaGlzIGlzIHVzZWQgYXMgdGhlIG9mZnNldC5cbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gKDAsIF9wb3NpdGlvbkZucy5nZXRDb250cm9sUG9zaXRpb24pKGUsIHRoaXMudG91Y2hJZGVudGlmaWVyLCB0aGlzKTtcbiAgICAgIGlmIChwb3NpdGlvbiA9PSBudWxsKSByZXR1cm47XG4gICAgICBsZXQge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gcG9zaXRpb247XG5cbiAgICAgIC8vIFNuYXAgdG8gZ3JpZCBpZiBwcm9wIGhhcyBiZWVuIHByb3ZpZGVkXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnByb3BzLmdyaWQpKSB7XG4gICAgICAgIGxldCBkZWx0YVggPSB4IC0gdGhpcy5sYXN0WCxcbiAgICAgICAgICBkZWx0YVkgPSB5IC0gdGhpcy5sYXN0WTtcbiAgICAgICAgW2RlbHRhWCwgZGVsdGFZXSA9ICgwLCBfcG9zaXRpb25GbnMuc25hcFRvR3JpZCkodGhpcy5wcm9wcy5ncmlkLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIGlmICghZGVsdGFYICYmICFkZWx0YVkpIHJldHVybjsgLy8gc2tpcCB1c2VsZXNzIGRyYWdcbiAgICAgICAgeCA9IHRoaXMubGFzdFggKyBkZWx0YVgsIHkgPSB0aGlzLmxhc3RZICsgZGVsdGFZO1xuICAgICAgfVxuICAgICAgY29uc3QgY29yZUV2ZW50ID0gKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVDb3JlRGF0YSkodGhpcywgeCwgeSk7XG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlQ29yZTogaGFuZGxlRHJhZzogJWonLCBjb3JlRXZlbnQpO1xuXG4gICAgICAvLyBDYWxsIGV2ZW50IGhhbmRsZXIuIElmIGl0IHJldHVybnMgZXhwbGljaXQgZmFsc2UsIHRyaWdnZXIgZW5kLlxuICAgICAgY29uc3Qgc2hvdWxkVXBkYXRlID0gdGhpcy5wcm9wcy5vbkRyYWcoZSwgY29yZUV2ZW50KTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IGZhbHNlIHx8IHRoaXMubW91bnRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyAkRmxvd0lnbm9yZVxuICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0b3AobmV3IE1vdXNlRXZlbnQoJ21vdXNldXAnKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIE9sZCBicm93c2Vyc1xuICAgICAgICAgIGNvbnN0IGV2ZW50ID0gKChkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKSAvKjogYW55Ki8pIC8qOiBNb3VzZVRvdWNoRXZlbnQqLyk7XG4gICAgICAgICAgLy8gSSBzZWUgd2h5IHRoaXMgaW5zYW5pdHkgd2FzIGRlcHJlY2F0ZWRcbiAgICAgICAgICAvLyAkRmxvd0lnbm9yZVxuICAgICAgICAgIGV2ZW50LmluaXRNb3VzZUV2ZW50KCdtb3VzZXVwJywgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAwLCAwLCAwLCAwLCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RvcChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0WCA9IHg7XG4gICAgICB0aGlzLmxhc3RZID0geTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVEcmFnU3RvcFwiLCBlID0+IHtcbiAgICAgIGlmICghdGhpcy5kcmFnZ2luZykgcmV0dXJuO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSAoMCwgX3Bvc2l0aW9uRm5zLmdldENvbnRyb2xQb3NpdGlvbikoZSwgdGhpcy50b3VjaElkZW50aWZpZXIsIHRoaXMpO1xuICAgICAgaWYgKHBvc2l0aW9uID09IG51bGwpIHJldHVybjtcbiAgICAgIGxldCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBwb3NpdGlvbjtcblxuICAgICAgLy8gU25hcCB0byBncmlkIGlmIHByb3AgaGFzIGJlZW4gcHJvdmlkZWRcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMucHJvcHMuZ3JpZCkpIHtcbiAgICAgICAgbGV0IGRlbHRhWCA9IHggLSB0aGlzLmxhc3RYIHx8IDA7XG4gICAgICAgIGxldCBkZWx0YVkgPSB5IC0gdGhpcy5sYXN0WSB8fCAwO1xuICAgICAgICBbZGVsdGFYLCBkZWx0YVldID0gKDAsIF9wb3NpdGlvbkZucy5zbmFwVG9HcmlkKSh0aGlzLnByb3BzLmdyaWQsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgeCA9IHRoaXMubGFzdFggKyBkZWx0YVgsIHkgPSB0aGlzLmxhc3RZICsgZGVsdGFZO1xuICAgICAgfVxuICAgICAgY29uc3QgY29yZUV2ZW50ID0gKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVDb3JlRGF0YSkodGhpcywgeCwgeSk7XG5cbiAgICAgIC8vIENhbGwgZXZlbnQgaGFuZGxlclxuICAgICAgY29uc3Qgc2hvdWxkQ29udGludWUgPSB0aGlzLnByb3BzLm9uU3RvcChlLCBjb3JlRXZlbnQpO1xuICAgICAgaWYgKHNob3VsZENvbnRpbnVlID09PSBmYWxzZSB8fCB0aGlzLm1vdW50ZWQgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICAgIGlmICh0aGlzTm9kZSkge1xuICAgICAgICAvLyBSZW1vdmUgdXNlci1zZWxlY3QgaGFja1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5lbmFibGVVc2VyU2VsZWN0SGFjaykgKDAsIF9kb21GbnMuc2NoZWR1bGVSZW1vdmVVc2VyU2VsZWN0U3R5bGVzKSh0aGlzTm9kZS5vd25lckRvY3VtZW50KTtcbiAgICAgIH1cbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGVDb3JlOiBoYW5kbGVEcmFnU3RvcDogJWonLCBjb3JlRXZlbnQpO1xuXG4gICAgICAvLyBSZXNldCB0aGUgZWwuXG4gICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmxhc3RYID0gTmFOO1xuICAgICAgdGhpcy5sYXN0WSA9IE5hTjtcbiAgICAgIGlmICh0aGlzTm9kZSkge1xuICAgICAgICAvLyBSZW1vdmUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IFJlbW92aW5nIGhhbmRsZXJzJyk7XG4gICAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KSh0aGlzTm9kZS5vd25lckRvY3VtZW50LCBkcmFnRXZlbnRGb3IubW92ZSwgdGhpcy5oYW5kbGVEcmFnKTtcbiAgICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKHRoaXNOb2RlLm93bmVyRG9jdW1lbnQsIGRyYWdFdmVudEZvci5zdG9wLCB0aGlzLmhhbmRsZURyYWdTdG9wKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbk1vdXNlRG93blwiLCBlID0+IHtcbiAgICAgIGRyYWdFdmVudEZvciA9IGV2ZW50c0Zvci5tb3VzZTsgLy8gb24gdG91Y2hzY3JlZW4gbGFwdG9wcyB3ZSBjb3VsZCBzd2l0Y2ggYmFjayB0byBtb3VzZVxuXG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVEcmFnU3RhcnQoZSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25Nb3VzZVVwXCIsIGUgPT4ge1xuICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLm1vdXNlO1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRHJhZ1N0b3AoZSk7XG4gICAgfSk7XG4gICAgLy8gU2FtZSBhcyBvbk1vdXNlRG93biAoc3RhcnQgZHJhZyksIGJ1dCBub3cgY29uc2lkZXIgdGhpcyBhIHRvdWNoIGRldmljZS5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblRvdWNoU3RhcnRcIiwgZSA9PiB7XG4gICAgICAvLyBXZSdyZSBvbiBhIHRvdWNoIGRldmljZSBub3csIHNvIGNoYW5nZSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgIGRyYWdFdmVudEZvciA9IGV2ZW50c0Zvci50b3VjaDtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZURyYWdTdGFydChlKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblRvdWNoRW5kXCIsIGUgPT4ge1xuICAgICAgLy8gV2UncmUgb24gYSB0b3VjaCBkZXZpY2Ugbm93LCBzbyBjaGFuZ2UgdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAgICBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IudG91Y2g7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVEcmFnU3RvcChlKTtcbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgIC8vIFRvdWNoIGhhbmRsZXJzIG11c3QgYmUgYWRkZWQgd2l0aCB7cGFzc2l2ZTogZmFsc2V9IHRvIGJlIGNhbmNlbGFibGUuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxNy8wMS9zY3JvbGxpbmctaW50ZXJ2ZW50aW9uXG4gICAgY29uc3QgdGhpc05vZGUgPSB0aGlzLmZpbmRET01Ob2RlKCk7XG4gICAgaWYgKHRoaXNOb2RlKSB7XG4gICAgICAoMCwgX2RvbUZucy5hZGRFdmVudCkodGhpc05vZGUsIGV2ZW50c0Zvci50b3VjaC5zdGFydCwgdGhpcy5vblRvdWNoU3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICAvLyBSZW1vdmUgYW55IGxlZnRvdmVyIGV2ZW50IGhhbmRsZXJzLiBSZW1vdmUgYm90aCB0b3VjaCBhbmQgbW91c2UgaGFuZGxlcnMgaW4gY2FzZVxuICAgIC8vIHNvbWUgYnJvd3NlciBxdWlyayBjYXVzZWQgYSB0b3VjaCBldmVudCB0byBmaXJlIGR1cmluZyBhIG1vdXNlIG1vdmUsIG9yIHZpY2UgdmVyc2EuXG4gICAgY29uc3QgdGhpc05vZGUgPSB0aGlzLmZpbmRET01Ob2RlKCk7XG4gICAgaWYgKHRoaXNOb2RlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG93bmVyRG9jdW1lbnRcbiAgICAgIH0gPSB0aGlzTm9kZTtcbiAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KShvd25lckRvY3VtZW50LCBldmVudHNGb3IubW91c2UubW92ZSwgdGhpcy5oYW5kbGVEcmFnKTtcbiAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KShvd25lckRvY3VtZW50LCBldmVudHNGb3IudG91Y2gubW92ZSwgdGhpcy5oYW5kbGVEcmFnKTtcbiAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KShvd25lckRvY3VtZW50LCBldmVudHNGb3IubW91c2Uuc3RvcCwgdGhpcy5oYW5kbGVEcmFnU3RvcCk7XG4gICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkob3duZXJEb2N1bWVudCwgZXZlbnRzRm9yLnRvdWNoLnN0b3AsIHRoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKHRoaXNOb2RlLCBldmVudHNGb3IudG91Y2guc3RhcnQsIHRoaXMub25Ub3VjaFN0YXJ0LCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnByb3BzLmVuYWJsZVVzZXJTZWxlY3RIYWNrKSAoMCwgX2RvbUZucy5zY2hlZHVsZVJlbW92ZVVzZXJTZWxlY3RTdHlsZXMpKG93bmVyRG9jdW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWN0IFN0cmljdCBNb2RlIGNvbXBhdGliaWxpdHk6IGlmIGBub2RlUmVmYCBpcyBwYXNzZWQsIHdlIHdpbGwgdXNlIGl0IGluc3RlYWQgb2YgdHJ5aW5nIHRvIGZpbmRcbiAgLy8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUgb3Vyc2VsdmVzLiBTZWUgdGhlIFJFQURNRSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgZmluZERPTU5vZGUoKSAvKjogP0hUTUxFbGVtZW50Ki97XG4gICAgcmV0dXJuIHRoaXMucHJvcHM/Lm5vZGVSZWYgPyB0aGlzLnByb3BzPy5ub2RlUmVmPy5jdXJyZW50IDogX3JlYWN0RG9tLmRlZmF1bHQuZmluZERPTU5vZGUodGhpcyk7XG4gIH1cbiAgcmVuZGVyKCkgLyo6IFJlYWN0LkVsZW1lbnQ8YW55Piove1xuICAgIC8vIFJldXNlIHRoZSBjaGlsZCBwcm92aWRlZFxuICAgIC8vIFRoaXMgbWFrZXMgaXQgZmxleGlibGUgdG8gdXNlIHdoYXRldmVyIGVsZW1lbnQgaXMgd2FudGVkIChkaXYsIHVsLCBldGMpXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoUmVhY3QuQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKSwge1xuICAgICAgLy8gTm90ZTogbW91c2VNb3ZlIGhhbmRsZXIgaXMgYXR0YWNoZWQgdG8gZG9jdW1lbnQgc28gaXQgd2lsbCBzdGlsbCBmdW5jdGlvblxuICAgICAgLy8gd2hlbiB0aGUgdXNlciBkcmFncyBxdWlja2x5IGFuZCBsZWF2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgZWxlbWVudC5cbiAgICAgIG9uTW91c2VEb3duOiB0aGlzLm9uTW91c2VEb3duLFxuICAgICAgb25Nb3VzZVVwOiB0aGlzLm9uTW91c2VVcCxcbiAgICAgIC8vIG9uVG91Y2hTdGFydCBpcyBhZGRlZCBvbiBgY29tcG9uZW50RGlkTW91bnRgIHNvIHRoZXkgY2FuIGJlIGFkZGVkIHdpdGhcbiAgICAgIC8vIHtwYXNzaXZlOiBmYWxzZX0sIHdoaWNoIGFsbG93cyBpdCB0byBjYW5jZWwuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxNy8wMS9zY3JvbGxpbmctaW50ZXJ2ZW50aW9uXG4gICAgICBvblRvdWNoRW5kOiB0aGlzLm9uVG91Y2hFbmRcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ2dhYmxlQ29yZTtcbl9kZWZpbmVQcm9wZXJ0eShEcmFnZ2FibGVDb3JlLCBcImRpc3BsYXlOYW1lXCIsICdEcmFnZ2FibGVDb3JlJyk7XG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlQ29yZSwgXCJwcm9wVHlwZXNcIiwge1xuICAvKipcbiAgICogYGFsbG93QW55Q2xpY2tgIGFsbG93cyBkcmFnZ2luZyB1c2luZyBhbnkgbW91c2UgYnV0dG9uLlxuICAgKiBCeSBkZWZhdWx0LCB3ZSBvbmx5IGFjY2VwdCB0aGUgbGVmdCBidXR0b24uXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqL1xuICBhbGxvd0FueUNsaWNrOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLyoqXG4gICAqIGBhbGxvd01vYmlsZVNjcm9sbGAgdHVybnMgb2ZmIGNhbmNlbGxhdGlvbiBvZiB0aGUgJ3RvdWNoc3RhcnQnIGV2ZW50XG4gICAqIG9uIG1vYmlsZSBkZXZpY2VzLiBPbmx5IGVuYWJsZSB0aGlzIGlmIHlvdSBhcmUgaGF2aW5nIHRyb3VibGUgd2l0aCBjbGlja1xuICAgKiBldmVudHMuIFByZWZlciB1c2luZyAnaGFuZGxlJyAvICdjYW5jZWwnIGluc3RlYWQuXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqL1xuICBhbGxvd01vYmlsZVNjcm9sbDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzLmRlZmF1bHQubm9kZS5pc1JlcXVpcmVkLFxuICAvKipcbiAgICogYGRpc2FibGVkYCwgaWYgdHJ1ZSwgc3RvcHMgdGhlIDxEcmFnZ2FibGU+IGZyb20gZHJhZ2dpbmcuIEFsbCBoYW5kbGVycyxcbiAgICogd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGBvbk1vdXNlRG93bmAsIHdpbGwgbm90IGZpcmUuXG4gICAqL1xuICBkaXNhYmxlZDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0LCB3ZSBhZGQgJ3VzZXItc2VsZWN0Om5vbmUnIGF0dHJpYnV0ZXMgdG8gdGhlIGRvY3VtZW50IGJvZHlcbiAgICogdG8gcHJldmVudCB1Z2x5IHRleHQgc2VsZWN0aW9uIGR1cmluZyBkcmFnLiBJZiB0aGlzIGlzIGNhdXNpbmcgcHJvYmxlbXNcbiAgICogZm9yIHlvdXIgYXBwLCBzZXQgdGhpcyB0byBgZmFsc2VgLlxuICAgKi9cbiAgZW5hYmxlVXNlclNlbGVjdEhhY2s6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvKipcbiAgICogYG9mZnNldFBhcmVudGAsIGlmIHNldCwgdXNlcyB0aGUgcGFzc2VkIERPTSBub2RlIHRvIGNvbXB1dGUgZHJhZyBvZmZzZXRzXG4gICAqIGluc3RlYWQgb2YgdXNpbmcgdGhlIHBhcmVudCBub2RlLlxuICAgKi9cbiAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbiAocHJvcHMgLyo6IERyYWdnYWJsZUNvcmVQcm9wcyovLCBwcm9wTmFtZSAvKjogJEtleXM8RHJhZ2dhYmxlQ29yZVByb3BzPiovKSB7XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSAmJiBwcm9wc1twcm9wTmFtZV0ubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRHJhZ2dhYmxlXFwncyBvZmZzZXRQYXJlbnQgbXVzdCBiZSBhIERPTSBOb2RlLicpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIGBncmlkYCBzcGVjaWZpZXMgdGhlIHggYW5kIHkgdGhhdCBkcmFnZ2luZyBzaG91bGQgc25hcCB0by5cbiAgICovXG4gIGdyaWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5hcnJheU9mKF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIpLFxuICAvKipcbiAgICogYGhhbmRsZWAgc3BlY2lmaWVzIGEgc2VsZWN0b3IgdG8gYmUgdXNlZCBhcyB0aGUgaGFuZGxlIHRoYXQgaW5pdGlhdGVzIGRyYWcuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiAgIGxldCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgKiAgICAgICAgIHJldHVybiAoXG4gICAqICAgICAgICAgICAgPERyYWdnYWJsZSBoYW5kbGU9XCIuaGFuZGxlXCI+XG4gICAqICAgICAgICAgICAgICA8ZGl2PlxuICAgKiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGFuZGxlXCI+Q2xpY2sgbWUgdG8gZHJhZzwvZGl2PlxuICAgKiAgICAgICAgICAgICAgICAgIDxkaXY+VGhpcyBpcyBzb21lIG90aGVyIGNvbnRlbnQ8L2Rpdj5cbiAgICogICAgICAgICAgICAgIDwvZGl2PlxuICAgKiAgICAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAqICAgICAgICAgKTtcbiAgICogICAgICAgfVxuICAgKiAgIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGhhbmRsZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLyoqXG4gICAqIGBjYW5jZWxgIHNwZWNpZmllcyBhIHNlbGVjdG9yIHRvIGJlIHVzZWQgdG8gcHJldmVudCBkcmFnIGluaXRpYWxpemF0aW9uLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICogICAgICAgICAgIHJldHVybihcbiAgICogICAgICAgICAgICAgICA8RHJhZ2dhYmxlIGNhbmNlbD1cIi5jYW5jZWxcIj5cbiAgICogICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICogICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhbmNlbFwiPllvdSBjYW4ndCBkcmFnIGZyb20gaGVyZTwvZGl2PlxuICAgKiAgICAgICAgICAgICAgICAgICAgIDxkaXY+RHJhZ2dpbmcgaGVyZSB3b3JrcyBmaW5lPC9kaXY+XG4gICAqICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgKiAgICAgICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICAgICAgICAgKTtcbiAgICogICAgICAgfVxuICAgKiAgIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGNhbmNlbDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLyogSWYgcnVubmluZyBpbiBSZWFjdCBTdHJpY3QgbW9kZSwgUmVhY3RET00uZmluZERPTU5vZGUoKSBpcyBkZXByZWNhdGVkLlxuICAgKiBVbmZvcnR1bmF0ZWx5LCBpbiBvcmRlciBmb3IgPERyYWdnYWJsZT4gdG8gd29yayBwcm9wZXJseSwgd2UgbmVlZCByYXcgYWNjZXNzXG4gICAqIHRvIHRoZSB1bmRlcmx5aW5nIERPTSBub2RlLiBJZiB5b3Ugd2FudCB0byBhdm9pZCB0aGUgd2FybmluZywgcGFzcyBhIGBub2RlUmVmYFxuICAgKiBhcyBpbiB0aGlzIGV4YW1wbGU6XG4gICAqXG4gICAqIGZ1bmN0aW9uIE15Q29tcG9uZW50KCkge1xuICAgKiAgIGNvbnN0IG5vZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAqICAgcmV0dXJuIChcbiAgICogICAgIDxEcmFnZ2FibGUgbm9kZVJlZj17bm9kZVJlZn0+XG4gICAqICAgICAgIDxkaXYgcmVmPXtub2RlUmVmfT5FeGFtcGxlIFRhcmdldDwvZGl2PlxuICAgKiAgICAgPC9EcmFnZ2FibGU+XG4gICAqICAgKTtcbiAgICogfVxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIGZvciBhcmJpdHJhcmlseSBuZXN0ZWQgY29tcG9uZW50cywgc28gbG9uZyBhcyB0aGUgcmVmIGVuZHMgdXBcbiAgICogcG9pbnRpbmcgdG8gdGhlIGFjdHVhbCBjaGlsZCBET00gbm9kZSBhbmQgbm90IGEgY3VzdG9tIGNvbXBvbmVudC5cbiAgICovXG4gIG5vZGVSZWY6IF9wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3QsXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBkcmFnZ2luZyBzdGFydHMuXG4gICAqIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgYm9vbGVhbiBmYWxzZSwgZHJhZ2dpbmcgd2lsbCBiZSBjYW5jZWxlZC5cbiAgICovXG4gIG9uU3RhcnQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvKipcbiAgICogQ2FsbGVkIHdoaWxlIGRyYWdnaW5nLlxuICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGJvb2xlYW4gZmFsc2UsIGRyYWdnaW5nIHdpbGwgYmUgY2FuY2VsZWQuXG4gICAqL1xuICBvbkRyYWc6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gZHJhZ2dpbmcgc3RvcHMuXG4gICAqIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgYm9vbGVhbiBmYWxzZSwgdGhlIGRyYWcgd2lsbCByZW1haW4gYWN0aXZlLlxuICAgKi9cbiAgb25TdG9wOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLyoqXG4gICAqIEEgd29ya2Fyb3VuZCBvcHRpb24gd2hpY2ggY2FuIGJlIHBhc3NlZCBpZiBvbk1vdXNlRG93biBuZWVkcyB0byBiZSBhY2Nlc3NlZCxcbiAgICogc2luY2UgaXQnbGwgYWx3YXlzIGJlIGJsb2NrZWQgKGFzIHRoZXJlIGlzIGludGVybmFsIHVzZSBvZiBvbk1vdXNlRG93bilcbiAgICovXG4gIG9uTW91c2VEb3duOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLyoqXG4gICAqIGBzY2FsZWAsIGlmIHNldCwgYXBwbGllcyBzY2FsaW5nIHdoaWxlIGRyYWdnaW5nIGFuIGVsZW1lbnRcbiAgICovXG4gIHNjYWxlOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAvKipcbiAgICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgYmUgZGVmaW5lZCBvbiB0aGUgY2hpbGQsIG5vdCBoZXJlLlxuICAgKi9cbiAgY2xhc3NOYW1lOiBfc2hpbXMuZG9udFNldE1lLFxuICBzdHlsZTogX3NoaW1zLmRvbnRTZXRNZSxcbiAgdHJhbnNmb3JtOiBfc2hpbXMuZG9udFNldE1lXG59KTtcbl9kZWZpbmVQcm9wZXJ0eShEcmFnZ2FibGVDb3JlLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIGFsbG93QW55Q2xpY2s6IGZhbHNlLFxuICAvLyBieSBkZWZhdWx0IG9ubHkgYWNjZXB0IGxlZnQgY2xpY2tcbiAgYWxsb3dNb2JpbGVTY3JvbGw6IGZhbHNlLFxuICBkaXNhYmxlZDogZmFsc2UsXG4gIGVuYWJsZVVzZXJTZWxlY3RIYWNrOiB0cnVlLFxuICBvblN0YXJ0OiBmdW5jdGlvbiAoKSB7fSxcbiAgb25EcmFnOiBmdW5jdGlvbiAoKSB7fSxcbiAgb25TdG9wOiBmdW5jdGlvbiAoKSB7fSxcbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uICgpIHt9LFxuICBzY2FsZTogMVxufSk7Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIlJlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiX3Byb3BUeXBlcyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfcmVhY3REb20iLCJfZG9tRm5zIiwiX3Bvc2l0aW9uRm5zIiwiX3NoaW1zIiwiX2xvZyIsImUiLCJfX2VzTW9kdWxlIiwidCIsIldlYWtNYXAiLCJyIiwibiIsIm8iLCJpIiwiZiIsIl9fcHJvdG9fXyIsImhhcyIsImdldCIsInNldCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9kZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJldmVudHNGb3IiLCJ0b3VjaCIsInN0YXJ0IiwibW92ZSIsInN0b3AiLCJtb3VzZSIsImRyYWdFdmVudEZvciIsIkRyYWdnYWJsZUNvcmUiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsImFyZ3VtZW50cyIsIk5hTiIsInByb3BzIiwib25Nb3VzZURvd24iLCJhbGxvd0FueUNsaWNrIiwiYnV0dG9uIiwidGhpc05vZGUiLCJmaW5kRE9NTm9kZSIsIm93bmVyRG9jdW1lbnQiLCJib2R5IiwiRXJyb3IiLCJkaXNhYmxlZCIsInRhcmdldCIsImRlZmF1bHRWaWV3IiwiTm9kZSIsImhhbmRsZSIsIm1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbyIsImNhbmNlbCIsInR5cGUiLCJhbGxvd01vYmlsZVNjcm9sbCIsInByZXZlbnREZWZhdWx0IiwidG91Y2hJZGVudGlmaWVyIiwiZ2V0VG91Y2hJZGVudGlmaWVyIiwicG9zaXRpb24iLCJnZXRDb250cm9sUG9zaXRpb24iLCJ4IiwieSIsImNvcmVFdmVudCIsImNyZWF0ZUNvcmVEYXRhIiwib25TdGFydCIsInNob3VsZFVwZGF0ZSIsIm1vdW50ZWQiLCJlbmFibGVVc2VyU2VsZWN0SGFjayIsImFkZFVzZXJTZWxlY3RTdHlsZXMiLCJkcmFnZ2luZyIsImxhc3RYIiwibGFzdFkiLCJhZGRFdmVudCIsImhhbmRsZURyYWciLCJoYW5kbGVEcmFnU3RvcCIsIkFycmF5IiwiaXNBcnJheSIsImdyaWQiLCJkZWx0YVgiLCJkZWx0YVkiLCJzbmFwVG9HcmlkIiwib25EcmFnIiwiTW91c2VFdmVudCIsImVyciIsImV2ZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImluaXRNb3VzZUV2ZW50Iiwid2luZG93Iiwic2hvdWxkQ29udGludWUiLCJvblN0b3AiLCJzY2hlZHVsZVJlbW92ZVVzZXJTZWxlY3RTdHlsZXMiLCJyZW1vdmVFdmVudCIsImhhbmRsZURyYWdTdGFydCIsImNvbXBvbmVudERpZE1vdW50Iiwib25Ub3VjaFN0YXJ0IiwicGFzc2l2ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50Iiwibm9kZVJlZiIsImN1cnJlbnQiLCJyZW5kZXIiLCJjbG9uZUVsZW1lbnQiLCJDaGlsZHJlbiIsIm9ubHkiLCJjaGlsZHJlbiIsIm9uTW91c2VVcCIsIm9uVG91Y2hFbmQiLCJib29sIiwibm9kZSIsImlzUmVxdWlyZWQiLCJvZmZzZXRQYXJlbnQiLCJwcm9wTmFtZSIsIm5vZGVUeXBlIiwiYXJyYXlPZiIsIm51bWJlciIsInN0cmluZyIsIm9iamVjdCIsImZ1bmMiLCJzY2FsZSIsImNsYXNzTmFtZSIsImRvbnRTZXRNZSIsInN0eWxlIiwidHJhbnNmb3JtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/DraggableCore.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/cjs.js":
/*!************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/cjs.js ***!
  \************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { default: Draggable, DraggableCore } = __webpack_require__(/*! ./Draggable */ \"(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/Draggable.js\");\n// Previous versions of this lib exported <Draggable> as the root export. As to no-// them, or TypeScript, we export *both* as the root and as 'default'.\n// See https://github.com/mzabriskie/react-draggable/pull/254\n// and https://github.com/mzabriskie/react-draggable/issues/266\nmodule.exports = Draggable;\nmodule.exports[\"default\"] = Draggable;\nmodule.exports.DraggableCore = DraggableCore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRyYWdnYWJsZUA0LjUuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL2Nqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLE1BQU0sRUFDSkEsU0FBU0MsU0FBUyxFQUNsQkMsYUFBYSxFQUNkLEdBQUdDLG1CQUFPQSxDQUFDO0FBRVoseUpBQXlKO0FBQ3pKLDZEQUE2RDtBQUM3RCwrREFBK0Q7QUFDL0RDLE9BQU9DLE9BQU8sR0FBR0o7QUFDakJHLHlCQUFzQixHQUFHSDtBQUN6QkcsNEJBQTRCLEdBQUdGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1pZGl2aXovd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1kcmFnZ2FibGVANC41LjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9janMuanM/NTc0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3Qge1xuICBkZWZhdWx0OiBEcmFnZ2FibGUsXG4gIERyYWdnYWJsZUNvcmVcbn0gPSByZXF1aXJlKCcuL0RyYWdnYWJsZScpO1xuXG4vLyBQcmV2aW91cyB2ZXJzaW9ucyBvZiB0aGlzIGxpYiBleHBvcnRlZCA8RHJhZ2dhYmxlPiBhcyB0aGUgcm9vdCBleHBvcnQuIEFzIHRvIG5vLS8vIHRoZW0sIG9yIFR5cGVTY3JpcHQsIHdlIGV4cG9ydCAqYm90aCogYXMgdGhlIHJvb3QgYW5kIGFzICdkZWZhdWx0Jy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9yZWFjdC1kcmFnZ2FibGUvcHVsbC8yNTRcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9yZWFjdC1kcmFnZ2FibGUvaXNzdWVzLzI2NlxubW9kdWxlLmV4cG9ydHMgPSBEcmFnZ2FibGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ2dhYmxlO1xubW9kdWxlLmV4cG9ydHMuRHJhZ2dhYmxlQ29yZSA9IERyYWdnYWJsZUNvcmU7Il0sIm5hbWVzIjpbImRlZmF1bHQiLCJEcmFnZ2FibGUiLCJEcmFnZ2FibGVDb3JlIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/cjs.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/domFns.js":
/*!*********************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/domFns.js ***!
  \*********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addClassName = addClassName;\nexports.addEvent = addEvent;\nexports.addUserSelectStyles = addUserSelectStyles;\nexports.createCSSTransform = createCSSTransform;\nexports.createSVGTransform = createSVGTransform;\nexports.getTouch = getTouch;\nexports.getTouchIdentifier = getTouchIdentifier;\nexports.getTranslation = getTranslation;\nexports.innerHeight = innerHeight;\nexports.innerWidth = innerWidth;\nexports.matchesSelector = matchesSelector;\nexports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;\nexports.offsetXYFromParent = offsetXYFromParent;\nexports.outerHeight = outerHeight;\nexports.outerWidth = outerWidth;\nexports.removeClassName = removeClassName;\nexports.removeEvent = removeEvent;\nexports.scheduleRemoveUserSelectStyles = scheduleRemoveUserSelectStyles;\nvar _shims = __webpack_require__(/*! ./shims */ \"(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _getPrefix = _interopRequireWildcard(__webpack_require__(/*! ./getPrefix */ \"(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/getPrefix.js\"));\nfunction _interopRequireWildcard(e, t) {\n    if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();\n    return (_interopRequireWildcard = function(e, t) {\n        if (!t && e && e.__esModule) return e;\n        var o, i, f = {\n            __proto__: null,\n            default: e\n        };\n        if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f;\n        if (o = t ? n : r) {\n            if (o.has(e)) return o.get(e);\n            o.set(e, f);\n        }\n        for(const t in e)\"default\" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);\n        return f;\n    })(e, t);\n}\n/*:: import type {ControlPosition, PositionOffsetControlPosition, MouseTouchEvent} from './types';*/ let matchesSelectorFunc = \"\";\nfunction matchesSelector(el /*: Node*/ , selector /*: string*/ ) /*: boolean*/ {\n    if (!matchesSelectorFunc) {\n        matchesSelectorFunc = (0, _shims.findInArray)([\n            \"matches\",\n            \"webkitMatchesSelector\",\n            \"mozMatchesSelector\",\n            \"msMatchesSelector\",\n            \"oMatchesSelector\"\n        ], function(method) {\n            // $FlowIgnore: Doesn't think elements are indexable\n            return (0, _shims.isFunction)(el[method]);\n        });\n    }\n    // Might not be found entirely (not an Element?) - in that case, bail\n    // $FlowIgnore: Doesn't think elements are indexable\n    if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;\n    // $FlowIgnore: Doesn't think elements are indexable\n    return el[matchesSelectorFunc](selector);\n}\n// Works up the tree to the draggable itself attempting to match selector.\nfunction matchesSelectorAndParentsTo(el /*: Node*/ , selector /*: string*/ , baseNode /*: Node*/ ) /*: boolean*/ {\n    let node = el;\n    do {\n        if (matchesSelector(node, selector)) return true;\n        if (node === baseNode) return false;\n        // $FlowIgnore[incompatible-type]\n        node = node.parentNode;\n    }while (node);\n    return false;\n}\nfunction addEvent(el /*: ?Node*/ , event /*: string*/ , handler /*: Function*/ , inputOptions /*: Object*/ ) /*: void*/ {\n    if (!el) return;\n    const options = {\n        capture: true,\n        ...inputOptions\n    };\n    // $FlowIgnore[method-unbinding]\n    if (el.addEventListener) {\n        el.addEventListener(event, handler, options);\n    } else if (el.attachEvent) {\n        el.attachEvent(\"on\" + event, handler);\n    } else {\n        // $FlowIgnore: Doesn't think elements are indexable\n        el[\"on\" + event] = handler;\n    }\n}\nfunction removeEvent(el /*: ?Node*/ , event /*: string*/ , handler /*: Function*/ , inputOptions /*: Object*/ ) /*: void*/ {\n    if (!el) return;\n    const options = {\n        capture: true,\n        ...inputOptions\n    };\n    // $FlowIgnore[method-unbinding]\n    if (el.removeEventListener) {\n        el.removeEventListener(event, handler, options);\n    } else if (el.detachEvent) {\n        el.detachEvent(\"on\" + event, handler);\n    } else {\n        // $FlowIgnore: Doesn't think elements are indexable\n        el[\"on\" + event] = null;\n    }\n}\nfunction outerHeight(node /*: HTMLElement*/ ) /*: number*/ {\n    // This is deliberately excluding margin for our calculations, since we are using\n    // offsetTop which is including margin. See getBoundPosition\n    let height = node.clientHeight;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    height += (0, _shims.int)(computedStyle.borderTopWidth);\n    height += (0, _shims.int)(computedStyle.borderBottomWidth);\n    return height;\n}\nfunction outerWidth(node /*: HTMLElement*/ ) /*: number*/ {\n    // This is deliberately excluding margin for our calculations, since we are using\n    // offsetLeft which is including margin. See getBoundPosition\n    let width = node.clientWidth;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    width += (0, _shims.int)(computedStyle.borderLeftWidth);\n    width += (0, _shims.int)(computedStyle.borderRightWidth);\n    return width;\n}\nfunction innerHeight(node /*: HTMLElement*/ ) /*: number*/ {\n    let height = node.clientHeight;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    height -= (0, _shims.int)(computedStyle.paddingTop);\n    height -= (0, _shims.int)(computedStyle.paddingBottom);\n    return height;\n}\nfunction innerWidth(node /*: HTMLElement*/ ) /*: number*/ {\n    let width = node.clientWidth;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    width -= (0, _shims.int)(computedStyle.paddingLeft);\n    width -= (0, _shims.int)(computedStyle.paddingRight);\n    return width;\n}\n/*:: interface EventWithOffset {\n  clientX: number, clientY: number\n}*/ // Get from offsetParent\nfunction offsetXYFromParent(evt /*: EventWithOffset*/ , offsetParent /*: HTMLElement*/ , scale /*: number*/ ) /*: ControlPosition*/ {\n    const isBody = offsetParent === offsetParent.ownerDocument.body;\n    const offsetParentRect = isBody ? {\n        left: 0,\n        top: 0\n    } : offsetParent.getBoundingClientRect();\n    const x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;\n    const y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;\n    return {\n        x,\n        y\n    };\n}\nfunction createCSSTransform(controlPos /*: ControlPosition*/ , positionOffset /*: PositionOffsetControlPosition*/ ) /*: Object*/ {\n    const translation = getTranslation(controlPos, positionOffset, \"px\");\n    return {\n        [(0, _getPrefix.browserPrefixToKey)(\"transform\", _getPrefix.default)]: translation\n    };\n}\nfunction createSVGTransform(controlPos /*: ControlPosition*/ , positionOffset /*: PositionOffsetControlPosition*/ ) /*: string*/ {\n    const translation = getTranslation(controlPos, positionOffset, \"\");\n    return translation;\n}\nfunction getTranslation(_ref /*:: */ , positionOffset /*: PositionOffsetControlPosition*/ , unitSuffix /*: string*/ ) /*: string*/ {\n    let { x, y } /*: ControlPosition*/  = _ref /*: ControlPosition*/ ;\n    let translation = `translate(${x}${unitSuffix},${y}${unitSuffix})`;\n    if (positionOffset) {\n        const defaultX = `${typeof positionOffset.x === \"string\" ? positionOffset.x : positionOffset.x + unitSuffix}`;\n        const defaultY = `${typeof positionOffset.y === \"string\" ? positionOffset.y : positionOffset.y + unitSuffix}`;\n        translation = `translate(${defaultX}, ${defaultY})` + translation;\n    }\n    return translation;\n}\nfunction getTouch(e /*: MouseTouchEvent*/ , identifier /*: number*/ ) /*: ?{clientX: number, clientY: number}*/ {\n    return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, (t)=>identifier === t.identifier) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, (t)=>identifier === t.identifier);\n}\nfunction getTouchIdentifier(e /*: MouseTouchEvent*/ ) /*: ?number*/ {\n    if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;\n    if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;\n}\n// User-select Hacks:\n//\n// Useful for preventing blue highlights all over everything when dragging.\n// Note we're passing `document` b/c we could be iframed\nfunction addUserSelectStyles(doc /*: ?Document*/ ) {\n    if (!doc) return;\n    let styleEl = doc.getElementById(\"react-draggable-style-el\");\n    if (!styleEl) {\n        styleEl = doc.createElement(\"style\");\n        styleEl.type = \"text/css\";\n        styleEl.id = \"react-draggable-style-el\";\n        styleEl.innerHTML = \".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\\n\";\n        styleEl.innerHTML += \".react-draggable-transparent-selection *::selection {all: inherit;}\\n\";\n        doc.getElementsByTagName(\"head\")[0].appendChild(styleEl);\n    }\n    if (doc.body) addClassName(doc.body, \"react-draggable-transparent-selection\");\n}\nfunction scheduleRemoveUserSelectStyles(doc /*: ?Document*/ ) {\n    // Prevent a possible \"forced reflow\"\n    if (window.requestAnimationFrame) {\n        window.requestAnimationFrame(()=>{\n            removeUserSelectStyles(doc);\n        });\n    } else {\n        removeUserSelectStyles(doc);\n    }\n}\nfunction removeUserSelectStyles(doc /*: ?Document*/ ) {\n    if (!doc) return;\n    try {\n        if (doc.body) removeClassName(doc.body, \"react-draggable-transparent-selection\");\n        // $FlowIgnore: IE\n        if (doc.selection) {\n            // $FlowIgnore: IE\n            doc.selection.empty();\n        } else {\n            // Remove selection caused by scroll, unless it's a focused input\n            // (we use doc.defaultView in case we're in an iframe)\n            const selection = (doc.defaultView || window).getSelection();\n            if (selection && selection.type !== \"Caret\") {\n                selection.removeAllRanges();\n            }\n        }\n    } catch (e) {\n    // probably IE\n    }\n}\nfunction addClassName(el /*: HTMLElement*/ , className /*: string*/ ) {\n    if (el.classList) {\n        el.classList.add(className);\n    } else {\n        if (!el.className.match(new RegExp(`(?:^|\\\\s)${className}(?!\\\\S)`))) {\n            el.className += ` ${className}`;\n        }\n    }\n}\nfunction removeClassName(el /*: HTMLElement*/ , className /*: string*/ ) {\n    if (el.classList) {\n        el.classList.remove(className);\n    } else {\n        el.className = el.className.replace(new RegExp(`(?:^|\\\\s)${className}(?!\\\\S)`, \"g\"), \"\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRyYWdnYWJsZUA0LjUuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL2RvbUZucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsb0JBQW9CLEdBQUdFO0FBQ3ZCRixnQkFBZ0IsR0FBR0c7QUFDbkJILDJCQUEyQixHQUFHSTtBQUM5QkosMEJBQTBCLEdBQUdLO0FBQzdCTCwwQkFBMEIsR0FBR007QUFDN0JOLGdCQUFnQixHQUFHTztBQUNuQlAsMEJBQTBCLEdBQUdRO0FBQzdCUixzQkFBc0IsR0FBR1M7QUFDekJULG1CQUFtQixHQUFHVTtBQUN0QlYsa0JBQWtCLEdBQUdXO0FBQ3JCWCx1QkFBdUIsR0FBR1k7QUFDMUJaLG1DQUFtQyxHQUFHYTtBQUN0Q2IsMEJBQTBCLEdBQUdjO0FBQzdCZCxtQkFBbUIsR0FBR2U7QUFDdEJmLGtCQUFrQixHQUFHZ0I7QUFDckJoQix1QkFBdUIsR0FBR2lCO0FBQzFCakIsbUJBQW1CLEdBQUdrQjtBQUN0QmxCLHNDQUFzQyxHQUFHbUI7QUFDekMsSUFBSUMsU0FBU0MsbUJBQU9BLENBQUMsdUtBQVM7QUFDOUIsSUFBSUMsYUFBYUMsd0JBQXdCRixtQkFBT0EsQ0FBQywrS0FBYTtBQUM5RCxTQUFTRSx3QkFBd0JDLENBQUMsRUFBRUMsQ0FBQztJQUFJLElBQUksY0FBYyxPQUFPQyxTQUFTLElBQUlDLElBQUksSUFBSUQsV0FBV0UsSUFBSSxJQUFJRjtJQUFXLE9BQU8sQ0FBQ0gsMEJBQTBCLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztRQUFJLElBQUksQ0FBQ0EsS0FBS0QsS0FBS0EsRUFBRUssVUFBVSxFQUFFLE9BQU9MO1FBQUcsSUFBSU0sR0FBR0MsR0FBR0MsSUFBSTtZQUFF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VSxHQUFYO0lBQ3RELElBQUk1RSxHQUFHNkUsU0FBUyxFQUFFO1FBQ2hCN0UsR0FBRzZFLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDTDtJQUN0QixPQUFPO1FBQ0w1RSxHQUFHNEUsU0FBUyxHQUFHNUUsR0FBRzRFLFNBQVMsQ0FBQ00sT0FBTyxDQUFDLElBQUlGLE9BQU8sQ0FBQyxTQUFTLEVBQUVKLFVBQVUsT0FBTyxDQUFDLEVBQUUsTUFBTTtJQUN2RjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1pZGl2aXovd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1kcmFnZ2FibGVANC41LjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9kb21GbnMuanM/MDY3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWRkQ2xhc3NOYW1lID0gYWRkQ2xhc3NOYW1lO1xuZXhwb3J0cy5hZGRFdmVudCA9IGFkZEV2ZW50O1xuZXhwb3J0cy5hZGRVc2VyU2VsZWN0U3R5bGVzID0gYWRkVXNlclNlbGVjdFN0eWxlcztcbmV4cG9ydHMuY3JlYXRlQ1NTVHJhbnNmb3JtID0gY3JlYXRlQ1NTVHJhbnNmb3JtO1xuZXhwb3J0cy5jcmVhdGVTVkdUcmFuc2Zvcm0gPSBjcmVhdGVTVkdUcmFuc2Zvcm07XG5leHBvcnRzLmdldFRvdWNoID0gZ2V0VG91Y2g7XG5leHBvcnRzLmdldFRvdWNoSWRlbnRpZmllciA9IGdldFRvdWNoSWRlbnRpZmllcjtcbmV4cG9ydHMuZ2V0VHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbjtcbmV4cG9ydHMuaW5uZXJIZWlnaHQgPSBpbm5lckhlaWdodDtcbmV4cG9ydHMuaW5uZXJXaWR0aCA9IGlubmVyV2lkdGg7XG5leHBvcnRzLm1hdGNoZXNTZWxlY3RvciA9IG1hdGNoZXNTZWxlY3RvcjtcbmV4cG9ydHMubWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvID0gbWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvO1xuZXhwb3J0cy5vZmZzZXRYWUZyb21QYXJlbnQgPSBvZmZzZXRYWUZyb21QYXJlbnQ7XG5leHBvcnRzLm91dGVySGVpZ2h0ID0gb3V0ZXJIZWlnaHQ7XG5leHBvcnRzLm91dGVyV2lkdGggPSBvdXRlcldpZHRoO1xuZXhwb3J0cy5yZW1vdmVDbGFzc05hbWUgPSByZW1vdmVDbGFzc05hbWU7XG5leHBvcnRzLnJlbW92ZUV2ZW50ID0gcmVtb3ZlRXZlbnQ7XG5leHBvcnRzLnNjaGVkdWxlUmVtb3ZlVXNlclNlbGVjdFN0eWxlcyA9IHNjaGVkdWxlUmVtb3ZlVXNlclNlbGVjdFN0eWxlcztcbnZhciBfc2hpbXMgPSByZXF1aXJlKFwiLi9zaGltc1wiKTtcbnZhciBfZ2V0UHJlZml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vZ2V0UHJlZml4XCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHQpIHsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgV2Vha01hcCkgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCBuID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IGZ1bmN0aW9uIChlLCB0KSB7IGlmICghdCAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IHZhciBvLCBpLCBmID0geyBfX3Byb3RvX186IG51bGwsIGRlZmF1bHQ6IGUgfTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiBmOyBpZiAobyA9IHQgPyBuIDogcikgeyBpZiAoby5oYXMoZSkpIHJldHVybiBvLmdldChlKTsgby5zZXQoZSwgZik7IH0gZm9yIChjb25zdCB0IGluIGUpIFwiZGVmYXVsdFwiICE9PSB0ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdCkgJiYgKChpID0gKG8gPSBPYmplY3QuZGVmaW5lUHJvcGVydHkpICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdCkpICYmIChpLmdldCB8fCBpLnNldCkgPyBvKGYsIHQsIGkpIDogZlt0XSA9IGVbdF0pOyByZXR1cm4gZjsgfSkoZSwgdCk7IH1cbi8qOjogaW1wb3J0IHR5cGUge0NvbnRyb2xQb3NpdGlvbiwgUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24sIE1vdXNlVG91Y2hFdmVudH0gZnJvbSAnLi90eXBlcyc7Ki9cbmxldCBtYXRjaGVzU2VsZWN0b3JGdW5jID0gJyc7XG5mdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3IoZWwgLyo6IE5vZGUqLywgc2VsZWN0b3IgLyo6IHN0cmluZyovKSAvKjogYm9vbGVhbiove1xuICBpZiAoIW1hdGNoZXNTZWxlY3RvckZ1bmMpIHtcbiAgICBtYXRjaGVzU2VsZWN0b3JGdW5jID0gKDAsIF9zaGltcy5maW5kSW5BcnJheSkoWydtYXRjaGVzJywgJ3dlYmtpdE1hdGNoZXNTZWxlY3RvcicsICdtb3pNYXRjaGVzU2VsZWN0b3InLCAnbXNNYXRjaGVzU2VsZWN0b3InLCAnb01hdGNoZXNTZWxlY3RvciddLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG4gICAgICByZXR1cm4gKDAsIF9zaGltcy5pc0Z1bmN0aW9uKShlbFttZXRob2RdKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1pZ2h0IG5vdCBiZSBmb3VuZCBlbnRpcmVseSAobm90IGFuIEVsZW1lbnQ/KSAtIGluIHRoYXQgY2FzZSwgYmFpbFxuICAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG4gIGlmICghKDAsIF9zaGltcy5pc0Z1bmN0aW9uKShlbFttYXRjaGVzU2VsZWN0b3JGdW5jXSkpIHJldHVybiBmYWxzZTtcblxuICAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG4gIHJldHVybiBlbFttYXRjaGVzU2VsZWN0b3JGdW5jXShzZWxlY3Rvcik7XG59XG5cbi8vIFdvcmtzIHVwIHRoZSB0cmVlIHRvIHRoZSBkcmFnZ2FibGUgaXRzZWxmIGF0dGVtcHRpbmcgdG8gbWF0Y2ggc2VsZWN0b3IuXG5mdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3JBbmRQYXJlbnRzVG8oZWwgLyo6IE5vZGUqLywgc2VsZWN0b3IgLyo6IHN0cmluZyovLCBiYXNlTm9kZSAvKjogTm9kZSovKSAvKjogYm9vbGVhbiove1xuICBsZXQgbm9kZSA9IGVsO1xuICBkbyB7XG4gICAgaWYgKG1hdGNoZXNTZWxlY3Rvcihub2RlLCBzZWxlY3RvcikpIHJldHVybiB0cnVlO1xuICAgIGlmIChub2RlID09PSBiYXNlTm9kZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vICRGbG93SWdub3JlW2luY29tcGF0aWJsZS10eXBlXVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH0gd2hpbGUgKG5vZGUpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhZGRFdmVudChlbCAvKjogP05vZGUqLywgZXZlbnQgLyo6IHN0cmluZyovLCBoYW5kbGVyIC8qOiBGdW5jdGlvbiovLCBpbnB1dE9wdGlvbnMgLyo6IE9iamVjdCovKSAvKjogdm9pZCove1xuICBpZiAoIWVsKSByZXR1cm47XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAuLi5pbnB1dE9wdGlvbnNcbiAgfTtcbiAgLy8gJEZsb3dJZ25vcmVbbWV0aG9kLXVuYmluZGluZ11cbiAgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmIChlbC5hdHRhY2hFdmVudCkge1xuICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgaGFuZGxlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuICAgIGVsWydvbicgKyBldmVudF0gPSBoYW5kbGVyO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVFdmVudChlbCAvKjogP05vZGUqLywgZXZlbnQgLyo6IHN0cmluZyovLCBoYW5kbGVyIC8qOiBGdW5jdGlvbiovLCBpbnB1dE9wdGlvbnMgLyo6IE9iamVjdCovKSAvKjogdm9pZCove1xuICBpZiAoIWVsKSByZXR1cm47XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAuLi5pbnB1dE9wdGlvbnNcbiAgfTtcbiAgLy8gJEZsb3dJZ25vcmVbbWV0aG9kLXVuYmluZGluZ11cbiAgaWYgKGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmIChlbC5kZXRhY2hFdmVudCkge1xuICAgIGVsLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgaGFuZGxlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuICAgIGVsWydvbicgKyBldmVudF0gPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBvdXRlckhlaWdodChub2RlIC8qOiBIVE1MRWxlbWVudCovKSAvKjogbnVtYmVyKi97XG4gIC8vIFRoaXMgaXMgZGVsaWJlcmF0ZWx5IGV4Y2x1ZGluZyBtYXJnaW4gZm9yIG91ciBjYWxjdWxhdGlvbnMsIHNpbmNlIHdlIGFyZSB1c2luZ1xuICAvLyBvZmZzZXRUb3Agd2hpY2ggaXMgaW5jbHVkaW5nIG1hcmdpbi4gU2VlIGdldEJvdW5kUG9zaXRpb25cbiAgbGV0IGhlaWdodCA9IG5vZGUuY2xpZW50SGVpZ2h0O1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGhlaWdodCArPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCk7XG4gIGhlaWdodCArPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCk7XG4gIHJldHVybiBoZWlnaHQ7XG59XG5mdW5jdGlvbiBvdXRlcldpZHRoKG5vZGUgLyo6IEhUTUxFbGVtZW50Ki8pIC8qOiBudW1iZXIqL3tcbiAgLy8gVGhpcyBpcyBkZWxpYmVyYXRlbHkgZXhjbHVkaW5nIG1hcmdpbiBmb3Igb3VyIGNhbGN1bGF0aW9ucywgc2luY2Ugd2UgYXJlIHVzaW5nXG4gIC8vIG9mZnNldExlZnQgd2hpY2ggaXMgaW5jbHVkaW5nIG1hcmdpbi4gU2VlIGdldEJvdW5kUG9zaXRpb25cbiAgbGV0IHdpZHRoID0gbm9kZS5jbGllbnRXaWR0aDtcbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICB3aWR0aCArPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgpO1xuICB3aWR0aCArPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoKTtcbiAgcmV0dXJuIHdpZHRoO1xufVxuZnVuY3Rpb24gaW5uZXJIZWlnaHQobm9kZSAvKjogSFRNTEVsZW1lbnQqLykgLyo6IG51bWJlciove1xuICBsZXQgaGVpZ2h0ID0gbm9kZS5jbGllbnRIZWlnaHQ7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgaGVpZ2h0IC09ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3ApO1xuICBoZWlnaHQgLT0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUucGFkZGluZ0JvdHRvbSk7XG4gIHJldHVybiBoZWlnaHQ7XG59XG5mdW5jdGlvbiBpbm5lcldpZHRoKG5vZGUgLyo6IEhUTUxFbGVtZW50Ki8pIC8qOiBudW1iZXIqL3tcbiAgbGV0IHdpZHRoID0gbm9kZS5jbGllbnRXaWR0aDtcbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICB3aWR0aCAtPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5wYWRkaW5nTGVmdCk7XG4gIHdpZHRoIC09ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCk7XG4gIHJldHVybiB3aWR0aDtcbn1cbi8qOjogaW50ZXJmYWNlIEV2ZW50V2l0aE9mZnNldCB7XG4gIGNsaWVudFg6IG51bWJlciwgY2xpZW50WTogbnVtYmVyXG59Ki9cbi8vIEdldCBmcm9tIG9mZnNldFBhcmVudFxuZnVuY3Rpb24gb2Zmc2V0WFlGcm9tUGFyZW50KGV2dCAvKjogRXZlbnRXaXRoT2Zmc2V0Ki8sIG9mZnNldFBhcmVudCAvKjogSFRNTEVsZW1lbnQqLywgc2NhbGUgLyo6IG51bWJlciovKSAvKjogQ29udHJvbFBvc2l0aW9uKi97XG4gIGNvbnN0IGlzQm9keSA9IG9mZnNldFBhcmVudCA9PT0gb2Zmc2V0UGFyZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgY29uc3Qgb2Zmc2V0UGFyZW50UmVjdCA9IGlzQm9keSA/IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMFxuICB9IDogb2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB4ID0gKGV2dC5jbGllbnRYICsgb2Zmc2V0UGFyZW50LnNjcm9sbExlZnQgLSBvZmZzZXRQYXJlbnRSZWN0LmxlZnQpIC8gc2NhbGU7XG4gIGNvbnN0IHkgPSAoZXZ0LmNsaWVudFkgKyBvZmZzZXRQYXJlbnQuc2Nyb2xsVG9wIC0gb2Zmc2V0UGFyZW50UmVjdC50b3ApIC8gc2NhbGU7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDU1NUcmFuc2Zvcm0oY29udHJvbFBvcyAvKjogQ29udHJvbFBvc2l0aW9uKi8sIHBvc2l0aW9uT2Zmc2V0IC8qOiBQb3NpdGlvbk9mZnNldENvbnRyb2xQb3NpdGlvbiovKSAvKjogT2JqZWN0Ki97XG4gIGNvbnN0IHRyYW5zbGF0aW9uID0gZ2V0VHJhbnNsYXRpb24oY29udHJvbFBvcywgcG9zaXRpb25PZmZzZXQsICdweCcpO1xuICByZXR1cm4ge1xuICAgIFsoMCwgX2dldFByZWZpeC5icm93c2VyUHJlZml4VG9LZXkpKCd0cmFuc2Zvcm0nLCBfZ2V0UHJlZml4LmRlZmF1bHQpXTogdHJhbnNsYXRpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNWR1RyYW5zZm9ybShjb250cm9sUG9zIC8qOiBDb250cm9sUG9zaXRpb24qLywgcG9zaXRpb25PZmZzZXQgLyo6IFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uKi8pIC8qOiBzdHJpbmcqL3tcbiAgY29uc3QgdHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbihjb250cm9sUG9zLCBwb3NpdGlvbk9mZnNldCwgJycpO1xuICByZXR1cm4gdHJhbnNsYXRpb247XG59XG5mdW5jdGlvbiBnZXRUcmFuc2xhdGlvbihfcmVmIC8qOjogKi8sIHBvc2l0aW9uT2Zmc2V0IC8qOiBQb3NpdGlvbk9mZnNldENvbnRyb2xQb3NpdGlvbiovLCB1bml0U3VmZml4IC8qOiBzdHJpbmcqLykgLyo6IHN0cmluZyove1xuICBsZXQge1xuICAgIHgsXG4gICAgeVxuICB9IC8qOiBDb250cm9sUG9zaXRpb24qLyA9IF9yZWYgLyo6IENvbnRyb2xQb3NpdGlvbiovO1xuICBsZXQgdHJhbnNsYXRpb24gPSBgdHJhbnNsYXRlKCR7eH0ke3VuaXRTdWZmaXh9LCR7eX0ke3VuaXRTdWZmaXh9KWA7XG4gIGlmIChwb3NpdGlvbk9mZnNldCkge1xuICAgIGNvbnN0IGRlZmF1bHRYID0gYCR7dHlwZW9mIHBvc2l0aW9uT2Zmc2V0LnggPT09ICdzdHJpbmcnID8gcG9zaXRpb25PZmZzZXQueCA6IHBvc2l0aW9uT2Zmc2V0LnggKyB1bml0U3VmZml4fWA7XG4gICAgY29uc3QgZGVmYXVsdFkgPSBgJHt0eXBlb2YgcG9zaXRpb25PZmZzZXQueSA9PT0gJ3N0cmluZycgPyBwb3NpdGlvbk9mZnNldC55IDogcG9zaXRpb25PZmZzZXQueSArIHVuaXRTdWZmaXh9YDtcbiAgICB0cmFuc2xhdGlvbiA9IGB0cmFuc2xhdGUoJHtkZWZhdWx0WH0sICR7ZGVmYXVsdFl9KWAgKyB0cmFuc2xhdGlvbjtcbiAgfVxuICByZXR1cm4gdHJhbnNsYXRpb247XG59XG5mdW5jdGlvbiBnZXRUb3VjaChlIC8qOiBNb3VzZVRvdWNoRXZlbnQqLywgaWRlbnRpZmllciAvKjogbnVtYmVyKi8pIC8qOiA/e2NsaWVudFg6IG51bWJlciwgY2xpZW50WTogbnVtYmVyfSove1xuICByZXR1cm4gZS50YXJnZXRUb3VjaGVzICYmICgwLCBfc2hpbXMuZmluZEluQXJyYXkpKGUudGFyZ2V0VG91Y2hlcywgdCA9PiBpZGVudGlmaWVyID09PSB0LmlkZW50aWZpZXIpIHx8IGUuY2hhbmdlZFRvdWNoZXMgJiYgKDAsIF9zaGltcy5maW5kSW5BcnJheSkoZS5jaGFuZ2VkVG91Y2hlcywgdCA9PiBpZGVudGlmaWVyID09PSB0LmlkZW50aWZpZXIpO1xufVxuZnVuY3Rpb24gZ2V0VG91Y2hJZGVudGlmaWVyKGUgLyo6IE1vdXNlVG91Y2hFdmVudCovKSAvKjogP251bWJlciove1xuICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlc1swXSkgcmV0dXJuIGUudGFyZ2V0VG91Y2hlc1swXS5pZGVudGlmaWVyO1xuICBpZiAoZS5jaGFuZ2VkVG91Y2hlcyAmJiBlLmNoYW5nZWRUb3VjaGVzWzBdKSByZXR1cm4gZS5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyO1xufVxuXG4vLyBVc2VyLXNlbGVjdCBIYWNrczpcbi8vXG4vLyBVc2VmdWwgZm9yIHByZXZlbnRpbmcgYmx1ZSBoaWdobGlnaHRzIGFsbCBvdmVyIGV2ZXJ5dGhpbmcgd2hlbiBkcmFnZ2luZy5cblxuLy8gTm90ZSB3ZSdyZSBwYXNzaW5nIGBkb2N1bWVudGAgYi9jIHdlIGNvdWxkIGJlIGlmcmFtZWRcbmZ1bmN0aW9uIGFkZFVzZXJTZWxlY3RTdHlsZXMoZG9jIC8qOiA/RG9jdW1lbnQqLykge1xuICBpZiAoIWRvYykgcmV0dXJuO1xuICBsZXQgc3R5bGVFbCA9IGRvYy5nZXRFbGVtZW50QnlJZCgncmVhY3QtZHJhZ2dhYmxlLXN0eWxlLWVsJyk7XG4gIGlmICghc3R5bGVFbCkge1xuICAgIHN0eWxlRWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZUVsLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgIHN0eWxlRWwuaWQgPSAncmVhY3QtZHJhZ2dhYmxlLXN0eWxlLWVsJztcbiAgICBzdHlsZUVsLmlubmVySFRNTCA9ICcucmVhY3QtZHJhZ2dhYmxlLXRyYW5zcGFyZW50LXNlbGVjdGlvbiAqOjotbW96LXNlbGVjdGlvbiB7YWxsOiBpbmhlcml0O31cXG4nO1xuICAgIHN0eWxlRWwuaW5uZXJIVE1MICs9ICcucmVhY3QtZHJhZ2dhYmxlLXRyYW5zcGFyZW50LXNlbGVjdGlvbiAqOjpzZWxlY3Rpb24ge2FsbDogaW5oZXJpdDt9XFxuJztcbiAgICBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZUVsKTtcbiAgfVxuICBpZiAoZG9jLmJvZHkpIGFkZENsYXNzTmFtZShkb2MuYm9keSwgJ3JlYWN0LWRyYWdnYWJsZS10cmFuc3BhcmVudC1zZWxlY3Rpb24nKTtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlUmVtb3ZlVXNlclNlbGVjdFN0eWxlcyhkb2MgLyo6ID9Eb2N1bWVudCovKSB7XG4gIC8vIFByZXZlbnQgYSBwb3NzaWJsZSBcImZvcmNlZCByZWZsb3dcIlxuICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgcmVtb3ZlVXNlclNlbGVjdFN0eWxlcyhkb2MpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZVVzZXJTZWxlY3RTdHlsZXMoZG9jKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlVXNlclNlbGVjdFN0eWxlcyhkb2MgLyo6ID9Eb2N1bWVudCovKSB7XG4gIGlmICghZG9jKSByZXR1cm47XG4gIHRyeSB7XG4gICAgaWYgKGRvYy5ib2R5KSByZW1vdmVDbGFzc05hbWUoZG9jLmJvZHksICdyZWFjdC1kcmFnZ2FibGUtdHJhbnNwYXJlbnQtc2VsZWN0aW9uJyk7XG4gICAgLy8gJEZsb3dJZ25vcmU6IElFXG4gICAgaWYgKGRvYy5zZWxlY3Rpb24pIHtcbiAgICAgIC8vICRGbG93SWdub3JlOiBJRVxuICAgICAgZG9jLnNlbGVjdGlvbi5lbXB0eSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgc2VsZWN0aW9uIGNhdXNlZCBieSBzY3JvbGwsIHVubGVzcyBpdCdzIGEgZm9jdXNlZCBpbnB1dFxuICAgICAgLy8gKHdlIHVzZSBkb2MuZGVmYXVsdFZpZXcgaW4gY2FzZSB3ZSdyZSBpbiBhbiBpZnJhbWUpXG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAoZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdykuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi50eXBlICE9PSAnQ2FyZXQnKSB7XG4gICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBwcm9iYWJseSBJRVxuICB9XG59XG5mdW5jdGlvbiBhZGRDbGFzc05hbWUoZWwgLyo6IEhUTUxFbGVtZW50Ki8sIGNsYXNzTmFtZSAvKjogc3RyaW5nKi8pIHtcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWVsLmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKGAoPzpefFxcXFxzKSR7Y2xhc3NOYW1lfSg/IVxcXFxTKWApKSkge1xuICAgICAgZWwuY2xhc3NOYW1lICs9IGAgJHtjbGFzc05hbWV9YDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzTmFtZShlbCAvKjogSFRNTEVsZW1lbnQqLywgY2xhc3NOYW1lIC8qOiBzdHJpbmcqLykge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICB9IGVsc2Uge1xuICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoYCg/Ol58XFxcXHMpJHtjbGFzc05hbWV9KD8hXFxcXFMpYCwgJ2cnKSwgJycpO1xuICB9XG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWRkQ2xhc3NOYW1lIiwiYWRkRXZlbnQiLCJhZGRVc2VyU2VsZWN0U3R5bGVzIiwiY3JlYXRlQ1NTVHJhbnNmb3JtIiwiY3JlYXRlU1ZHVHJhbnNmb3JtIiwiZ2V0VG91Y2giLCJnZXRUb3VjaElkZW50aWZpZXIiLCJnZXRUcmFuc2xhdGlvbiIsImlubmVySGVpZ2h0IiwiaW5uZXJXaWR0aCIsIm1hdGNoZXNTZWxlY3RvciIsIm1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbyIsIm9mZnNldFhZRnJvbVBhcmVudCIsIm91dGVySGVpZ2h0Iiwib3V0ZXJXaWR0aCIsInJlbW92ZUNsYXNzTmFtZSIsInJlbW92ZUV2ZW50Iiwic2NoZWR1bGVSZW1vdmVVc2VyU2VsZWN0U3R5bGVzIiwiX3NoaW1zIiwicmVxdWlyZSIsIl9nZXRQcmVmaXgiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsImUiLCJ0IiwiV2Vha01hcCIsInIiLCJuIiwiX19lc01vZHVsZSIsIm8iLCJpIiwiZiIsIl9fcHJvdG9fXyIsImRlZmF1bHQiLCJoYXMiLCJnZXQiLCJzZXQiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJtYXRjaGVzU2VsZWN0b3JGdW5jIiwiZWwiLCJzZWxlY3RvciIsImZpbmRJbkFycmF5IiwibWV0aG9kIiwiaXNGdW5jdGlvbiIsImJhc2VOb2RlIiwibm9kZSIsInBhcmVudE5vZGUiLCJldmVudCIsImhhbmRsZXIiLCJpbnB1dE9wdGlvbnMiLCJvcHRpb25zIiwiY2FwdHVyZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXRhY2hFdmVudCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsImNvbXB1dGVkU3R5bGUiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJnZXRDb21wdXRlZFN0eWxlIiwiaW50IiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJSaWdodFdpZHRoIiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImV2dCIsIm9mZnNldFBhcmVudCIsInNjYWxlIiwiaXNCb2R5IiwiYm9keSIsIm9mZnNldFBhcmVudFJlY3QiLCJsZWZ0IiwidG9wIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsImNsaWVudFgiLCJzY3JvbGxMZWZ0IiwieSIsImNsaWVudFkiLCJzY3JvbGxUb3AiLCJjb250cm9sUG9zIiwicG9zaXRpb25PZmZzZXQiLCJ0cmFuc2xhdGlvbiIsImJyb3dzZXJQcmVmaXhUb0tleSIsIl9yZWYiLCJ1bml0U3VmZml4IiwiZGVmYXVsdFgiLCJkZWZhdWx0WSIsImlkZW50aWZpZXIiLCJ0YXJnZXRUb3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJkb2MiLCJzdHlsZUVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJjcmVhdGVFbGVtZW50IiwidHlwZSIsImlkIiwiaW5uZXJIVE1MIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJhcHBlbmRDaGlsZCIsIndpbmRvdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlbW92ZVVzZXJTZWxlY3RTdHlsZXMiLCJzZWxlY3Rpb24iLCJlbXB0eSIsImdldFNlbGVjdGlvbiIsInJlbW92ZUFsbFJhbmdlcyIsImNsYXNzTmFtZSIsImNsYXNzTGlzdCIsImFkZCIsIm1hdGNoIiwiUmVnRXhwIiwicmVtb3ZlIiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/domFns.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/getPrefix.js":
/*!************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/getPrefix.js ***!
  \************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.browserPrefixToKey = browserPrefixToKey;\nexports.browserPrefixToStyle = browserPrefixToStyle;\nexports[\"default\"] = void 0;\nexports.getPrefix = getPrefix;\nconst prefixes = [\n    \"Moz\",\n    \"Webkit\",\n    \"O\",\n    \"ms\"\n];\nfunction getPrefix() /*: string*/ {\n    let prop /*: string*/  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"transform\";\n    // Ensure we're running in an environment where there is actually a global\n    // `window` obj\n    if (true) return \"\";\n    // If we're in a pseudo-browser server-side environment, this access\n    // path may not exist, so bail out if it doesn't.\n    const style = window.document?.documentElement?.style;\n    if (!style) return \"\";\n    if (prop in style) return \"\";\n    for(let i = 0; i < prefixes.length; i++){\n        if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];\n    }\n    return \"\";\n}\nfunction browserPrefixToKey(prop /*: string*/ , prefix /*: string*/ ) /*: string*/ {\n    return prefix ? `${prefix}${kebabToTitleCase(prop)}` : prop;\n}\nfunction browserPrefixToStyle(prop /*: string*/ , prefix /*: string*/ ) /*: string*/ {\n    return prefix ? `-${prefix.toLowerCase()}-${prop}` : prop;\n}\nfunction kebabToTitleCase(str /*: string*/ ) /*: string*/ {\n    let out = \"\";\n    let shouldCapitalize = true;\n    for(let i = 0; i < str.length; i++){\n        if (shouldCapitalize) {\n            out += str[i].toUpperCase();\n            shouldCapitalize = false;\n        } else if (str[i] === \"-\") {\n            shouldCapitalize = true;\n        } else {\n            out += str[i];\n        }\n    }\n    return out;\n}\n// Default export is the prefix itself, like 'Moz', 'Webkit', etc\n// Note that you may have to re-test for certain things; for instance, Chrome 50\n// can handle unprefixed `transform`, but not unprefixed `user-select`\nvar _default = exports[\"default\"] = getPrefix();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRyYWdnYWJsZUA0LjUuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL2dldFByZWZpeC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUdFO0FBQzdCRiw0QkFBNEIsR0FBR0c7QUFDL0JILGtCQUFlLEdBQUcsS0FBSztBQUN2QkEsaUJBQWlCLEdBQUdLO0FBQ3BCLE1BQU1DLFdBQVc7SUFBQztJQUFPO0lBQVU7SUFBSztDQUFLO0FBQzdDLFNBQVNELFlBQVksVUFBVTtJQUM3QixJQUFJRSxLQUFLLFVBQVUsTUFBS0MsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDNUYsMEVBQTBFO0lBQzFFLGVBQWU7SUFDZixJQUFJLElBQWtCLEVBQWEsT0FBTztJQUUxQyxvRUFBb0U7SUFDcEUsaURBQWlEO0lBQ2pELE1BQU1HLFFBQVFDLE9BQU9DLFFBQVEsRUFBRUMsaUJBQWlCSDtJQUNoRCxJQUFJLENBQUNBLE9BQU8sT0FBTztJQUNuQixJQUFJSixRQUFRSSxPQUFPLE9BQU87SUFDMUIsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUlULFNBQVNHLE1BQU0sRUFBRU0sSUFBSztRQUN4QyxJQUFJYixtQkFBbUJLLE1BQU1ELFFBQVEsQ0FBQ1MsRUFBRSxLQUFLSixPQUFPLE9BQU9MLFFBQVEsQ0FBQ1MsRUFBRTtJQUN4RTtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNiLG1CQUFtQkssS0FBSyxVQUFVLEdBQVgsRUFBZVMsT0FBTyxVQUFVLEdBQVgsRUFBZSxVQUFVO0lBQzVFLE9BQU9BLFNBQVMsQ0FBQyxFQUFFQSxPQUFPLEVBQUVDLGlCQUFpQlYsTUFBTSxDQUFDLEdBQUdBO0FBQ3pEO0FBQ0EsU0FBU0oscUJBQXFCSSxLQUFLLFVBQVUsR0FBWCxFQUFlUyxPQUFPLFVBQVUsR0FBWCxFQUFlLFVBQVU7SUFDOUUsT0FBT0EsU0FBUyxDQUFDLENBQUMsRUFBRUEsT0FBT0UsV0FBVyxHQUFHLENBQUMsRUFBRVgsS0FBSyxDQUFDLEdBQUdBO0FBQ3ZEO0FBQ0EsU0FBU1UsaUJBQWlCRSxJQUFJLFVBQVUsR0FBWCxFQUFlLFVBQVU7SUFDcEQsSUFBSUMsTUFBTTtJQUNWLElBQUlDLG1CQUFtQjtJQUN2QixJQUFLLElBQUlOLElBQUksR0FBR0EsSUFBSUksSUFBSVYsTUFBTSxFQUFFTSxJQUFLO1FBQ25DLElBQUlNLGtCQUFrQjtZQUNwQkQsT0FBT0QsR0FBRyxDQUFDSixFQUFFLENBQUNPLFdBQVc7WUFDekJELG1CQUFtQjtRQUNyQixPQUFPLElBQUlGLEdBQUcsQ0FBQ0osRUFBRSxLQUFLLEtBQUs7WUFDekJNLG1CQUFtQjtRQUNyQixPQUFPO1lBQ0xELE9BQU9ELEdBQUcsQ0FBQ0osRUFBRTtRQUNmO0lBQ0Y7SUFDQSxPQUFPSztBQUNUO0FBRUEsaUVBQWlFO0FBQ2pFLGdGQUFnRjtBQUNoRixzRUFBc0U7QUFDdEUsSUFBSUcsV0FBV3ZCLGtCQUFlLEdBQUlLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1pZGl2aXovd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1kcmFnZ2FibGVANC41LjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9nZXRQcmVmaXguanM/NzQ1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYnJvd3NlclByZWZpeFRvS2V5ID0gYnJvd3NlclByZWZpeFRvS2V5O1xuZXhwb3J0cy5icm93c2VyUHJlZml4VG9TdHlsZSA9IGJyb3dzZXJQcmVmaXhUb1N0eWxlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRQcmVmaXggPSBnZXRQcmVmaXg7XG5jb25zdCBwcmVmaXhlcyA9IFsnTW96JywgJ1dlYmtpdCcsICdPJywgJ21zJ107XG5mdW5jdGlvbiBnZXRQcmVmaXgoKSAvKjogc3RyaW5nKi97XG4gIGxldCBwcm9wIC8qOiBzdHJpbmcqLyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3RyYW5zZm9ybSc7XG4gIC8vIEVuc3VyZSB3ZSdyZSBydW5uaW5nIGluIGFuIGVudmlyb25tZW50IHdoZXJlIHRoZXJlIGlzIGFjdHVhbGx5IGEgZ2xvYmFsXG4gIC8vIGB3aW5kb3dgIG9ialxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAnJztcblxuICAvLyBJZiB3ZSdyZSBpbiBhIHBzZXVkby1icm93c2VyIHNlcnZlci1zaWRlIGVudmlyb25tZW50LCB0aGlzIGFjY2Vzc1xuICAvLyBwYXRoIG1heSBub3QgZXhpc3QsIHNvIGJhaWwgb3V0IGlmIGl0IGRvZXNuJ3QuXG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmRvY3VtZW50Py5kb2N1bWVudEVsZW1lbnQ/LnN0eWxlO1xuICBpZiAoIXN0eWxlKSByZXR1cm4gJyc7XG4gIGlmIChwcm9wIGluIHN0eWxlKSByZXR1cm4gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYnJvd3NlclByZWZpeFRvS2V5KHByb3AsIHByZWZpeGVzW2ldKSBpbiBzdHlsZSkgcmV0dXJuIHByZWZpeGVzW2ldO1xuICB9XG4gIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGJyb3dzZXJQcmVmaXhUb0tleShwcm9wIC8qOiBzdHJpbmcqLywgcHJlZml4IC8qOiBzdHJpbmcqLykgLyo6IHN0cmluZyove1xuICByZXR1cm4gcHJlZml4ID8gYCR7cHJlZml4fSR7a2ViYWJUb1RpdGxlQ2FzZShwcm9wKX1gIDogcHJvcDtcbn1cbmZ1bmN0aW9uIGJyb3dzZXJQcmVmaXhUb1N0eWxlKHByb3AgLyo6IHN0cmluZyovLCBwcmVmaXggLyo6IHN0cmluZyovKSAvKjogc3RyaW5nKi97XG4gIHJldHVybiBwcmVmaXggPyBgLSR7cHJlZml4LnRvTG93ZXJDYXNlKCl9LSR7cHJvcH1gIDogcHJvcDtcbn1cbmZ1bmN0aW9uIGtlYmFiVG9UaXRsZUNhc2Uoc3RyIC8qOiBzdHJpbmcqLykgLyo6IHN0cmluZyove1xuICBsZXQgb3V0ID0gJyc7XG4gIGxldCBzaG91bGRDYXBpdGFsaXplID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc2hvdWxkQ2FwaXRhbGl6ZSkge1xuICAgICAgb3V0ICs9IHN0cltpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgc2hvdWxkQ2FwaXRhbGl6ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSAnLScpIHtcbiAgICAgIHNob3VsZENhcGl0YWxpemUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gc3RyW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vLyBEZWZhdWx0IGV4cG9ydCBpcyB0aGUgcHJlZml4IGl0c2VsZiwgbGlrZSAnTW96JywgJ1dlYmtpdCcsIGV0Y1xuLy8gTm90ZSB0aGF0IHlvdSBtYXkgaGF2ZSB0byByZS10ZXN0IGZvciBjZXJ0YWluIHRoaW5nczsgZm9yIGluc3RhbmNlLCBDaHJvbWUgNTBcbi8vIGNhbiBoYW5kbGUgdW5wcmVmaXhlZCBgdHJhbnNmb3JtYCwgYnV0IG5vdCB1bnByZWZpeGVkIGB1c2VyLXNlbGVjdGBcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdCA9IChnZXRQcmVmaXgoKSAvKjogc3RyaW5nKi8pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImJyb3dzZXJQcmVmaXhUb0tleSIsImJyb3dzZXJQcmVmaXhUb1N0eWxlIiwiZGVmYXVsdCIsImdldFByZWZpeCIsInByZWZpeGVzIiwicHJvcCIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsInN0eWxlIiwid2luZG93IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJpIiwicHJlZml4Iiwia2ViYWJUb1RpdGxlQ2FzZSIsInRvTG93ZXJDYXNlIiwic3RyIiwib3V0Iiwic2hvdWxkQ2FwaXRhbGl6ZSIsInRvVXBwZXJDYXNlIiwiX2RlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/getPrefix.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/log.js":
/*!******************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/log.js ***!
  \******************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = log;\n/*eslint no-console:0*/ function log() {\n    if (false) {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRyYWdnYWJsZUA0LjUuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL2xvZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEIscUJBQXFCLEdBQ3JCLFNBQVNBO0lBQ1AsSUFBSUMsS0FBU0EsRUFBRUMsRUFBMEJDO0FBQzNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1pZGl2aXovd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1kcmFnZ2FibGVANC41LjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9sb2cuanM/MGE1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGxvZztcbi8qZXNsaW50IG5vLWNvbnNvbGU6MCovXG5mdW5jdGlvbiBsb2coKSB7XG4gIGlmICh1bmRlZmluZWQpIGNvbnNvbGUubG9nKC4uLmFyZ3VtZW50cyk7XG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsImxvZyIsInVuZGVmaW5lZCIsImNvbnNvbGUiLCJhcmd1bWVudHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/log.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/positionFns.js":
/*!**************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/positionFns.js ***!
  \**************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.canDragX = canDragX;\nexports.canDragY = canDragY;\nexports.createCoreData = createCoreData;\nexports.createDraggableData = createDraggableData;\nexports.getBoundPosition = getBoundPosition;\nexports.getControlPosition = getControlPosition;\nexports.snapToGrid = snapToGrid;\nvar _shims = __webpack_require__(/*! ./shims */ \"(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _domFns = __webpack_require__(/*! ./domFns */ \"(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/domFns.js\");\n/*:: import type Draggable from '../Draggable';*/ /*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/ /*:: import type DraggableCore from '../DraggableCore';*/ function getBoundPosition(draggable /*: Draggable*/ , x /*: number*/ , y /*: number*/ ) /*: [number, number]*/ {\n    // If no bounds, short-circuit and move on\n    if (!draggable.props.bounds) return [\n        x,\n        y\n    ];\n    // Clone new bounds\n    let { bounds } = draggable.props;\n    bounds = typeof bounds === \"string\" ? bounds : cloneBounds(bounds);\n    const node = findDOMNode(draggable);\n    if (typeof bounds === \"string\") {\n        const { ownerDocument } = node;\n        const ownerWindow = ownerDocument.defaultView;\n        let boundNode;\n        if (bounds === \"parent\") {\n            boundNode = node.parentNode;\n        } else {\n            // Flow assigns the wrong return type (Node) for getRootNode(),\n            // so we cast it to one of the correct types (Element).\n            // The others are Document and ShadowRoot.\n            // All three implement querySelector() so it's safe to call.\n            const rootNode = node.getRootNode();\n            boundNode = rootNode.querySelector(bounds);\n        }\n        if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n            throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n        }\n        const boundNodeEl /*: HTMLElement*/  = boundNode; // for Flow, can't seem to refine correctly\n        const nodeStyle = ownerWindow.getComputedStyle(node);\n        const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);\n        // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n        bounds = {\n            left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n            top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n            right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n            bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n        };\n    }\n    // Keep x and y below right and bottom limits...\n    if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\n    if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);\n    // But above left and top limits.\n    if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\n    if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\n    return [\n        x,\n        y\n    ];\n}\nfunction snapToGrid(grid /*: [number, number]*/ , pendingX /*: number*/ , pendingY /*: number*/ ) /*: [number, number]*/ {\n    const x = Math.round(pendingX / grid[0]) * grid[0];\n    const y = Math.round(pendingY / grid[1]) * grid[1];\n    return [\n        x,\n        y\n    ];\n}\nfunction canDragX(draggable /*: Draggable*/ ) /*: boolean*/ {\n    return draggable.props.axis === \"both\" || draggable.props.axis === \"x\";\n}\nfunction canDragY(draggable /*: Draggable*/ ) /*: boolean*/ {\n    return draggable.props.axis === \"both\" || draggable.props.axis === \"y\";\n}\n// Get {x, y} positions from event.\nfunction getControlPosition(e /*: MouseTouchEvent*/ , touchIdentifier /*: ?number*/ , draggableCore /*: DraggableCore*/ ) /*: ?ControlPosition*/ {\n    const touchObj = typeof touchIdentifier === \"number\" ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n    if (typeof touchIdentifier === \"number\" && !touchObj) return null; // not the right touch\n    const node = findDOMNode(draggableCore);\n    // User can provide an offsetParent if desired.\n    const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n    return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n}\n// Create an data object exposed by <DraggableCore>'s events\nfunction createCoreData(draggable /*: DraggableCore*/ , x /*: number*/ , y /*: number*/ ) /*: DraggableData*/ {\n    const isStart = !(0, _shims.isNum)(draggable.lastX);\n    const node = findDOMNode(draggable);\n    if (isStart) {\n        // If this is our first move, use the x and y as last coords.\n        return {\n            node,\n            deltaX: 0,\n            deltaY: 0,\n            lastX: x,\n            lastY: y,\n            x,\n            y\n        };\n    } else {\n        // Otherwise calculate proper values.\n        return {\n            node,\n            deltaX: x - draggable.lastX,\n            deltaY: y - draggable.lastY,\n            lastX: draggable.lastX,\n            lastY: draggable.lastY,\n            x,\n            y\n        };\n    }\n}\n// Create an data exposed by <Draggable>'s events\nfunction createDraggableData(draggable /*: Draggable*/ , coreData /*: DraggableData*/ ) /*: DraggableData*/ {\n    const scale = draggable.props.scale;\n    return {\n        node: coreData.node,\n        x: draggable.state.x + coreData.deltaX / scale,\n        y: draggable.state.y + coreData.deltaY / scale,\n        deltaX: coreData.deltaX / scale,\n        deltaY: coreData.deltaY / scale,\n        lastX: draggable.state.x,\n        lastY: draggable.state.y\n    };\n}\n// A lot faster than stringify/parse\nfunction cloneBounds(bounds /*: Bounds*/ ) /*: Bounds*/ {\n    return {\n        left: bounds.left,\n        top: bounds.top,\n        right: bounds.right,\n        bottom: bounds.bottom\n    };\n}\nfunction findDOMNode(draggable /*: Draggable | DraggableCore*/ ) /*: HTMLElement*/ {\n    const node = draggable.findDOMNode();\n    if (!node) {\n        throw new Error(\"<DraggableCore>: Unmounted during event!\");\n    }\n    // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n    return node;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRyYWdnYWJsZUA0LjUuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL3Bvc2l0aW9uRm5zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxnQkFBZ0IsR0FBR0U7QUFDbkJGLGdCQUFnQixHQUFHRztBQUNuQkgsc0JBQXNCLEdBQUdJO0FBQ3pCSiwyQkFBMkIsR0FBR0s7QUFDOUJMLHdCQUF3QixHQUFHTTtBQUMzQk4sMEJBQTBCLEdBQUdPO0FBQzdCUCxrQkFBa0IsR0FBR1E7QUFDckIsSUFBSUMsU0FBU0MsbUJBQU9BLENBQUMsdUtBQVM7QUFDOUIsSUFBSUMsVUFBVUQsbUJBQU9BLENBQUMseUtBQVU7QUFDaEMsK0NBQStDLEdBQy9DLDBGQUEwRixHQUMxRix1REFBdUQsR0FDdkQsU0FBU0osaUJBQWlCTSxVQUFVLGFBQWEsR0FBZCxFQUFrQkMsRUFBRSxVQUFVLEdBQVgsRUFBZUMsRUFBRSxVQUFVLEdBQVgsRUFBZSxvQkFBb0I7SUFDdkcsMENBQTBDO0lBQzFDLElBQUksQ0FBQ0YsVUFBVUcsS0FBSyxDQUFDQyxNQUFNLEVBQUUsT0FBTztRQUFDSDtRQUFHQztLQUFFO0lBRTFDLG1CQUFtQjtJQUNuQixJQUFJLEVBQ0ZFLE1BQU0sRUFDUCxHQUFHSixVQUFVRyxLQUFLO0lBQ25CQyxTQUFTLE9BQU9BLFdBQVcsV0FBV0EsU0FBU0MsWUFBWUQ7SUFDM0QsTUFBTUUsT0FBT0MsWUFBWVA7SUFDekIsSUFBSSxPQUFPSSxXQUFXLFVBQVU7UUFDOUIsTUFBTSxFQUNKSSxhQUFhLEVBQ2QsR0FBR0Y7UUFDSixNQUFNRyxjQUFjRCxjQUFjRSxXQUFXO1FBQzdDLElBQUlDO1FBQ0osSUFBSVAsV0FBVyxVQUFVO1lB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QUFDQSxTQUFTN0IsWUFBWVAsVUFBVSw2QkFBNkIsR0FBOUIsRUFBa0MsZUFBZTtJQUM3RSxNQUFNTSxPQUFPTixVQUFVTyxXQUFXO0lBQ2xDLElBQUksQ0FBQ0QsTUFBTTtRQUNULE1BQU0sSUFBSVcsTUFBTTtJQUNsQjtJQUNBLG1FQUFtRTtJQUNuRSxPQUFPWDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1pZGl2aXovd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1kcmFnZ2FibGVANC41LjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9wb3NpdGlvbkZucy5qcz84YzI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jYW5EcmFnWCA9IGNhbkRyYWdYO1xuZXhwb3J0cy5jYW5EcmFnWSA9IGNhbkRyYWdZO1xuZXhwb3J0cy5jcmVhdGVDb3JlRGF0YSA9IGNyZWF0ZUNvcmVEYXRhO1xuZXhwb3J0cy5jcmVhdGVEcmFnZ2FibGVEYXRhID0gY3JlYXRlRHJhZ2dhYmxlRGF0YTtcbmV4cG9ydHMuZ2V0Qm91bmRQb3NpdGlvbiA9IGdldEJvdW5kUG9zaXRpb247XG5leHBvcnRzLmdldENvbnRyb2xQb3NpdGlvbiA9IGdldENvbnRyb2xQb3NpdGlvbjtcbmV4cG9ydHMuc25hcFRvR3JpZCA9IHNuYXBUb0dyaWQ7XG52YXIgX3NoaW1zID0gcmVxdWlyZShcIi4vc2hpbXNcIik7XG52YXIgX2RvbUZucyA9IHJlcXVpcmUoXCIuL2RvbUZuc1wiKTtcbi8qOjogaW1wb3J0IHR5cGUgRHJhZ2dhYmxlIGZyb20gJy4uL0RyYWdnYWJsZSc7Ki9cbi8qOjogaW1wb3J0IHR5cGUge0JvdW5kcywgQ29udHJvbFBvc2l0aW9uLCBEcmFnZ2FibGVEYXRhLCBNb3VzZVRvdWNoRXZlbnR9IGZyb20gJy4vdHlwZXMnOyovXG4vKjo6IGltcG9ydCB0eXBlIERyYWdnYWJsZUNvcmUgZnJvbSAnLi4vRHJhZ2dhYmxlQ29yZSc7Ki9cbmZ1bmN0aW9uIGdldEJvdW5kUG9zaXRpb24oZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGUqLywgeCAvKjogbnVtYmVyKi8sIHkgLyo6IG51bWJlciovKSAvKjogW251bWJlciwgbnVtYmVyXSove1xuICAvLyBJZiBubyBib3VuZHMsIHNob3J0LWNpcmN1aXQgYW5kIG1vdmUgb25cbiAgaWYgKCFkcmFnZ2FibGUucHJvcHMuYm91bmRzKSByZXR1cm4gW3gsIHldO1xuXG4gIC8vIENsb25lIG5ldyBib3VuZHNcbiAgbGV0IHtcbiAgICBib3VuZHNcbiAgfSA9IGRyYWdnYWJsZS5wcm9wcztcbiAgYm91bmRzID0gdHlwZW9mIGJvdW5kcyA9PT0gJ3N0cmluZycgPyBib3VuZHMgOiBjbG9uZUJvdW5kcyhib3VuZHMpO1xuICBjb25zdCBub2RlID0gZmluZERPTU5vZGUoZHJhZ2dhYmxlKTtcbiAgaWYgKHR5cGVvZiBib3VuZHMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJEb2N1bWVudFxuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IG93bmVyV2luZG93ID0gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICBsZXQgYm91bmROb2RlO1xuICAgIGlmIChib3VuZHMgPT09ICdwYXJlbnQnKSB7XG4gICAgICBib3VuZE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsb3cgYXNzaWducyB0aGUgd3JvbmcgcmV0dXJuIHR5cGUgKE5vZGUpIGZvciBnZXRSb290Tm9kZSgpLFxuICAgICAgLy8gc28gd2UgY2FzdCBpdCB0byBvbmUgb2YgdGhlIGNvcnJlY3QgdHlwZXMgKEVsZW1lbnQpLlxuICAgICAgLy8gVGhlIG90aGVycyBhcmUgRG9jdW1lbnQgYW5kIFNoYWRvd1Jvb3QuXG4gICAgICAvLyBBbGwgdGhyZWUgaW1wbGVtZW50IHF1ZXJ5U2VsZWN0b3IoKSBzbyBpdCdzIHNhZmUgdG8gY2FsbC5cbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gKChub2RlLmdldFJvb3ROb2RlKCkgLyo6IGFueSovKSAvKjogRWxlbWVudCovKTtcbiAgICAgIGJvdW5kTm9kZSA9IHJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3IoYm91bmRzKTtcbiAgICB9XG4gICAgaWYgKCEoYm91bmROb2RlIGluc3RhbmNlb2Ygb3duZXJXaW5kb3cuSFRNTEVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBzZWxlY3RvciBcIicgKyBib3VuZHMgKyAnXCIgY291bGQgbm90IGZpbmQgYW4gZWxlbWVudC4nKTtcbiAgICB9XG4gICAgY29uc3QgYm91bmROb2RlRWwgLyo6IEhUTUxFbGVtZW50Ki8gPSBib3VuZE5vZGU7IC8vIGZvciBGbG93LCBjYW4ndCBzZWVtIHRvIHJlZmluZSBjb3JyZWN0bHlcbiAgICBjb25zdCBub2RlU3R5bGUgPSBvd25lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IGJvdW5kTm9kZVN0eWxlID0gb3duZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShib3VuZE5vZGVFbCk7XG4gICAgLy8gQ29tcHV0ZSBib3VuZHMuIFRoaXMgaXMgYSBwYWluIHdpdGggcGFkZGluZyBhbmQgb2Zmc2V0cyBidXQgdGhpcyBnZXRzIGl0IGV4YWN0bHkgcmlnaHQuXG4gICAgYm91bmRzID0ge1xuICAgICAgbGVmdDogLW5vZGUub2Zmc2V0TGVmdCArICgwLCBfc2hpbXMuaW50KShib3VuZE5vZGVTdHlsZS5wYWRkaW5nTGVmdCkgKyAoMCwgX3NoaW1zLmludCkobm9kZVN0eWxlLm1hcmdpbkxlZnQpLFxuICAgICAgdG9wOiAtbm9kZS5vZmZzZXRUb3AgKyAoMCwgX3NoaW1zLmludCkoYm91bmROb2RlU3R5bGUucGFkZGluZ1RvcCkgKyAoMCwgX3NoaW1zLmludCkobm9kZVN0eWxlLm1hcmdpblRvcCksXG4gICAgICByaWdodDogKDAsIF9kb21GbnMuaW5uZXJXaWR0aCkoYm91bmROb2RlRWwpIC0gKDAsIF9kb21GbnMub3V0ZXJXaWR0aCkobm9kZSkgLSBub2RlLm9mZnNldExlZnQgKyAoMCwgX3NoaW1zLmludCkoYm91bmROb2RlU3R5bGUucGFkZGluZ1JpZ2h0KSAtICgwLCBfc2hpbXMuaW50KShub2RlU3R5bGUubWFyZ2luUmlnaHQpLFxuICAgICAgYm90dG9tOiAoMCwgX2RvbUZucy5pbm5lckhlaWdodCkoYm91bmROb2RlRWwpIC0gKDAsIF9kb21GbnMub3V0ZXJIZWlnaHQpKG5vZGUpIC0gbm9kZS5vZmZzZXRUb3AgKyAoMCwgX3NoaW1zLmludCkoYm91bmROb2RlU3R5bGUucGFkZGluZ0JvdHRvbSkgLSAoMCwgX3NoaW1zLmludCkobm9kZVN0eWxlLm1hcmdpbkJvdHRvbSlcbiAgICB9O1xuICB9XG5cbiAgLy8gS2VlcCB4IGFuZCB5IGJlbG93IHJpZ2h0IGFuZCBib3R0b20gbGltaXRzLi4uXG4gIGlmICgoMCwgX3NoaW1zLmlzTnVtKShib3VuZHMucmlnaHQpKSB4ID0gTWF0aC5taW4oeCwgYm91bmRzLnJpZ2h0KTtcbiAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy5ib3R0b20pKSB5ID0gTWF0aC5taW4oeSwgYm91bmRzLmJvdHRvbSk7XG5cbiAgLy8gQnV0IGFib3ZlIGxlZnQgYW5kIHRvcCBsaW1pdHMuXG4gIGlmICgoMCwgX3NoaW1zLmlzTnVtKShib3VuZHMubGVmdCkpIHggPSBNYXRoLm1heCh4LCBib3VuZHMubGVmdCk7XG4gIGlmICgoMCwgX3NoaW1zLmlzTnVtKShib3VuZHMudG9wKSkgeSA9IE1hdGgubWF4KHksIGJvdW5kcy50b3ApO1xuICByZXR1cm4gW3gsIHldO1xufVxuZnVuY3Rpb24gc25hcFRvR3JpZChncmlkIC8qOiBbbnVtYmVyLCBudW1iZXJdKi8sIHBlbmRpbmdYIC8qOiBudW1iZXIqLywgcGVuZGluZ1kgLyo6IG51bWJlciovKSAvKjogW251bWJlciwgbnVtYmVyXSove1xuICBjb25zdCB4ID0gTWF0aC5yb3VuZChwZW5kaW5nWCAvIGdyaWRbMF0pICogZ3JpZFswXTtcbiAgY29uc3QgeSA9IE1hdGgucm91bmQocGVuZGluZ1kgLyBncmlkWzFdKSAqIGdyaWRbMV07XG4gIHJldHVybiBbeCwgeV07XG59XG5mdW5jdGlvbiBjYW5EcmFnWChkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSovKSAvKjogYm9vbGVhbiove1xuICByZXR1cm4gZHJhZ2dhYmxlLnByb3BzLmF4aXMgPT09ICdib3RoJyB8fCBkcmFnZ2FibGUucHJvcHMuYXhpcyA9PT0gJ3gnO1xufVxuZnVuY3Rpb24gY2FuRHJhZ1koZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGUqLykgLyo6IGJvb2xlYW4qL3tcbiAgcmV0dXJuIGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAnYm90aCcgfHwgZHJhZ2dhYmxlLnByb3BzLmF4aXMgPT09ICd5Jztcbn1cblxuLy8gR2V0IHt4LCB5fSBwb3NpdGlvbnMgZnJvbSBldmVudC5cbmZ1bmN0aW9uIGdldENvbnRyb2xQb3NpdGlvbihlIC8qOiBNb3VzZVRvdWNoRXZlbnQqLywgdG91Y2hJZGVudGlmaWVyIC8qOiA/bnVtYmVyKi8sIGRyYWdnYWJsZUNvcmUgLyo6IERyYWdnYWJsZUNvcmUqLykgLyo6ID9Db250cm9sUG9zaXRpb24qL3tcbiAgY29uc3QgdG91Y2hPYmogPSB0eXBlb2YgdG91Y2hJZGVudGlmaWVyID09PSAnbnVtYmVyJyA/ICgwLCBfZG9tRm5zLmdldFRvdWNoKShlLCB0b3VjaElkZW50aWZpZXIpIDogbnVsbDtcbiAgaWYgKHR5cGVvZiB0b3VjaElkZW50aWZpZXIgPT09ICdudW1iZXInICYmICF0b3VjaE9iaikgcmV0dXJuIG51bGw7IC8vIG5vdCB0aGUgcmlnaHQgdG91Y2hcbiAgY29uc3Qgbm9kZSA9IGZpbmRET01Ob2RlKGRyYWdnYWJsZUNvcmUpO1xuICAvLyBVc2VyIGNhbiBwcm92aWRlIGFuIG9mZnNldFBhcmVudCBpZiBkZXNpcmVkLlxuICBjb25zdCBvZmZzZXRQYXJlbnQgPSBkcmFnZ2FibGVDb3JlLnByb3BzLm9mZnNldFBhcmVudCB8fCBub2RlLm9mZnNldFBhcmVudCB8fCBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgcmV0dXJuICgwLCBfZG9tRm5zLm9mZnNldFhZRnJvbVBhcmVudCkodG91Y2hPYmogfHwgZSwgb2Zmc2V0UGFyZW50LCBkcmFnZ2FibGVDb3JlLnByb3BzLnNjYWxlKTtcbn1cblxuLy8gQ3JlYXRlIGFuIGRhdGEgb2JqZWN0IGV4cG9zZWQgYnkgPERyYWdnYWJsZUNvcmU+J3MgZXZlbnRzXG5mdW5jdGlvbiBjcmVhdGVDb3JlRGF0YShkcmFnZ2FibGUgLyo6IERyYWdnYWJsZUNvcmUqLywgeCAvKjogbnVtYmVyKi8sIHkgLyo6IG51bWJlciovKSAvKjogRHJhZ2dhYmxlRGF0YSove1xuICBjb25zdCBpc1N0YXJ0ID0gISgwLCBfc2hpbXMuaXNOdW0pKGRyYWdnYWJsZS5sYXN0WCk7XG4gIGNvbnN0IG5vZGUgPSBmaW5kRE9NTm9kZShkcmFnZ2FibGUpO1xuICBpZiAoaXNTdGFydCkge1xuICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IG1vdmUsIHVzZSB0aGUgeCBhbmQgeSBhcyBsYXN0IGNvb3Jkcy5cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZSxcbiAgICAgIGRlbHRhWDogMCxcbiAgICAgIGRlbHRhWTogMCxcbiAgICAgIGxhc3RYOiB4LFxuICAgICAgbGFzdFk6IHksXG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlIGNhbGN1bGF0ZSBwcm9wZXIgdmFsdWVzLlxuICAgIHJldHVybiB7XG4gICAgICBub2RlLFxuICAgICAgZGVsdGFYOiB4IC0gZHJhZ2dhYmxlLmxhc3RYLFxuICAgICAgZGVsdGFZOiB5IC0gZHJhZ2dhYmxlLmxhc3RZLFxuICAgICAgbGFzdFg6IGRyYWdnYWJsZS5sYXN0WCxcbiAgICAgIGxhc3RZOiBkcmFnZ2FibGUubGFzdFksXG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cbn1cblxuLy8gQ3JlYXRlIGFuIGRhdGEgZXhwb3NlZCBieSA8RHJhZ2dhYmxlPidzIGV2ZW50c1xuZnVuY3Rpb24gY3JlYXRlRHJhZ2dhYmxlRGF0YShkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSovLCBjb3JlRGF0YSAvKjogRHJhZ2dhYmxlRGF0YSovKSAvKjogRHJhZ2dhYmxlRGF0YSove1xuICBjb25zdCBzY2FsZSA9IGRyYWdnYWJsZS5wcm9wcy5zY2FsZTtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBjb3JlRGF0YS5ub2RlLFxuICAgIHg6IGRyYWdnYWJsZS5zdGF0ZS54ICsgY29yZURhdGEuZGVsdGFYIC8gc2NhbGUsXG4gICAgeTogZHJhZ2dhYmxlLnN0YXRlLnkgKyBjb3JlRGF0YS5kZWx0YVkgLyBzY2FsZSxcbiAgICBkZWx0YVg6IGNvcmVEYXRhLmRlbHRhWCAvIHNjYWxlLFxuICAgIGRlbHRhWTogY29yZURhdGEuZGVsdGFZIC8gc2NhbGUsXG4gICAgbGFzdFg6IGRyYWdnYWJsZS5zdGF0ZS54LFxuICAgIGxhc3RZOiBkcmFnZ2FibGUuc3RhdGUueVxuICB9O1xufVxuXG4vLyBBIGxvdCBmYXN0ZXIgdGhhbiBzdHJpbmdpZnkvcGFyc2VcbmZ1bmN0aW9uIGNsb25lQm91bmRzKGJvdW5kcyAvKjogQm91bmRzKi8pIC8qOiBCb3VuZHMqL3tcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBib3VuZHMubGVmdCxcbiAgICB0b3A6IGJvdW5kcy50b3AsXG4gICAgcmlnaHQ6IGJvdW5kcy5yaWdodCxcbiAgICBib3R0b206IGJvdW5kcy5ib3R0b21cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlIHwgRHJhZ2dhYmxlQ29yZSovKSAvKjogSFRNTEVsZW1lbnQqL3tcbiAgY29uc3Qgbm9kZSA9IGRyYWdnYWJsZS5maW5kRE9NTm9kZSgpO1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJzxEcmFnZ2FibGVDb3JlPjogVW5tb3VudGVkIGR1cmluZyBldmVudCEnKTtcbiAgfVxuICAvLyAkRmxvd0lnbm9yZSB3ZSBjYW4ndCBhc3NlcnQgb24gSFRNTEVsZW1lbnQgZHVlIHRvIHRlc3RzLi4uIEZJWE1FXG4gIHJldHVybiBub2RlO1xufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNhbkRyYWdYIiwiY2FuRHJhZ1kiLCJjcmVhdGVDb3JlRGF0YSIsImNyZWF0ZURyYWdnYWJsZURhdGEiLCJnZXRCb3VuZFBvc2l0aW9uIiwiZ2V0Q29udHJvbFBvc2l0aW9uIiwic25hcFRvR3JpZCIsIl9zaGltcyIsInJlcXVpcmUiLCJfZG9tRm5zIiwiZHJhZ2dhYmxlIiwieCIsInkiLCJwcm9wcyIsImJvdW5kcyIsImNsb25lQm91bmRzIiwibm9kZSIsImZpbmRET01Ob2RlIiwib3duZXJEb2N1bWVudCIsIm93bmVyV2luZG93IiwiZGVmYXVsdFZpZXciLCJib3VuZE5vZGUiLCJwYXJlbnROb2RlIiwicm9vdE5vZGUiLCJnZXRSb290Tm9kZSIsInF1ZXJ5U2VsZWN0b3IiLCJIVE1MRWxlbWVudCIsIkVycm9yIiwiYm91bmROb2RlRWwiLCJub2RlU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiYm91bmROb2RlU3R5bGUiLCJsZWZ0Iiwib2Zmc2V0TGVmdCIsImludCIsInBhZGRpbmdMZWZ0IiwibWFyZ2luTGVmdCIsInRvcCIsIm9mZnNldFRvcCIsInBhZGRpbmdUb3AiLCJtYXJnaW5Ub3AiLCJyaWdodCIsImlubmVyV2lkdGgiLCJvdXRlcldpZHRoIiwicGFkZGluZ1JpZ2h0IiwibWFyZ2luUmlnaHQiLCJib3R0b20iLCJpbm5lckhlaWdodCIsIm91dGVySGVpZ2h0IiwicGFkZGluZ0JvdHRvbSIsIm1hcmdpbkJvdHRvbSIsImlzTnVtIiwiTWF0aCIsIm1pbiIsIm1heCIsImdyaWQiLCJwZW5kaW5nWCIsInBlbmRpbmdZIiwicm91bmQiLCJheGlzIiwiZSIsInRvdWNoSWRlbnRpZmllciIsImRyYWdnYWJsZUNvcmUiLCJ0b3VjaE9iaiIsImdldFRvdWNoIiwib2Zmc2V0UGFyZW50IiwiYm9keSIsIm9mZnNldFhZRnJvbVBhcmVudCIsInNjYWxlIiwiaXNTdGFydCIsImxhc3RYIiwiZGVsdGFYIiwiZGVsdGFZIiwibGFzdFkiLCJjb3JlRGF0YSIsInN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/positionFns.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/shims.js":
/*!********************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/shims.js ***!
  \********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.dontSetMe = dontSetMe;\nexports.findInArray = findInArray;\nexports.int = int;\nexports.isFunction = isFunction;\nexports.isNum = isNum;\n// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc\nfunction findInArray(array /*: Array<any> | TouchList*/ , callback /*: Function*/ ) /*: any*/ {\n    for(let i = 0, length = array.length; i < length; i++){\n        if (callback.apply(callback, [\n            array[i],\n            i,\n            array\n        ])) return array[i];\n    }\n}\nfunction isFunction(func /*: any*/ ) /*: boolean %checks*/ {\n    // $FlowIgnore[method-unbinding]\n    return typeof func === \"function\" || Object.prototype.toString.call(func) === \"[object Function]\";\n}\nfunction isNum(num /*: any*/ ) /*: boolean %checks*/ {\n    return typeof num === \"number\" && !isNaN(num);\n}\nfunction int(a /*: string*/ ) /*: number*/ {\n    return parseInt(a, 10);\n}\nfunction dontSetMe(props /*: Object*/ , propName /*: string*/ , componentName /*: string*/ ) /*: ?Error*/ {\n    if (props[propName]) {\n        return new Error(`Invalid prop ${propName} passed to ${componentName} - do not set this, set it on the child.`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRyYWdnYWJsZUA0LjUuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL3NoaW1zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxpQkFBaUIsR0FBR0U7QUFDcEJGLG1CQUFtQixHQUFHRztBQUN0QkgsV0FBVyxHQUFHSTtBQUNkSixrQkFBa0IsR0FBR0s7QUFDckJMLGFBQWEsR0FBR007QUFDaEIscUVBQXFFO0FBQ3JFLFNBQVNILFlBQVlJLE1BQU0sMEJBQTBCLEdBQTNCLEVBQStCQyxTQUFTLFlBQVksR0FBYixFQUFpQixPQUFPO0lBQ3ZGLElBQUssSUFBSUMsSUFBSSxHQUFHQyxTQUFTSCxNQUFNRyxNQUFNLEVBQUVELElBQUlDLFFBQVFELElBQUs7UUFDdEQsSUFBSUQsU0FBU0csS0FBSyxDQUFDSCxVQUFVO1lBQUNELEtBQUssQ0FBQ0UsRUFBRTtZQUFFQTtZQUFHRjtTQUFNLEdBQUcsT0FBT0EsS0FBSyxDQUFDRSxFQUFFO0lBQ3JFO0FBQ0Y7QUFDQSxTQUFTSixXQUFXTyxLQUFLLE9BQU8sR0FBUixFQUFZLG1CQUFtQjtJQUNyRCxnQ0FBZ0M7SUFDaEMsT0FBTyxPQUFPQSxTQUFTLGNBQWNkLE9BQU9lLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNILFVBQVU7QUFDaEY7QUFDQSxTQUFTTixNQUFNVSxJQUFJLE9BQU8sR0FBUixFQUFZLG1CQUFtQjtJQUMvQyxPQUFPLE9BQU9BLFFBQVEsWUFBWSxDQUFDQyxNQUFNRDtBQUMzQztBQUNBLFNBQVNaLElBQUljLEVBQUUsVUFBVSxHQUFYLEVBQWUsVUFBVTtJQUNyQyxPQUFPQyxTQUFTRCxHQUFHO0FBQ3JCO0FBQ0EsU0FBU2hCLFVBQVVrQixNQUFNLFVBQVUsR0FBWCxFQUFlQyxTQUFTLFVBQVUsR0FBWCxFQUFlQyxjQUFjLFVBQVUsR0FBWCxFQUFlLFVBQVU7SUFDbEcsSUFBSUYsS0FBSyxDQUFDQyxTQUFTLEVBQUU7UUFDbkIsT0FBTyxJQUFJRSxNQUFNLENBQUMsYUFBYSxFQUFFRixTQUFTLFdBQVcsRUFBRUMsY0FBYyx3Q0FBd0MsQ0FBQztJQUNoSDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1pZGl2aXovd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1kcmFnZ2FibGVANC41LjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9zaGltcy5qcz85Mzc4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kb250U2V0TWUgPSBkb250U2V0TWU7XG5leHBvcnRzLmZpbmRJbkFycmF5ID0gZmluZEluQXJyYXk7XG5leHBvcnRzLmludCA9IGludDtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzTnVtID0gaXNOdW07XG4vLyBAY3JlZGl0cyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9yb2dvemhuaWtvZmYvYTQzY2ZlZDI3YzQxZTRlNjhjZGNcbmZ1bmN0aW9uIGZpbmRJbkFycmF5KGFycmF5IC8qOiBBcnJheTxhbnk+IHwgVG91Y2hMaXN0Ki8sIGNhbGxiYWNrIC8qOiBGdW5jdGlvbiovKSAvKjogYW55Ki97XG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChjYWxsYmFjay5hcHBseShjYWxsYmFjaywgW2FycmF5W2ldLCBpLCBhcnJheV0pKSByZXR1cm4gYXJyYXlbaV07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuYyAvKjogYW55Ki8pIC8qOiBib29sZWFuICVjaGVja3MqL3tcbiAgLy8gJEZsb3dJZ25vcmVbbWV0aG9kLXVuYmluZGluZ11cbiAgcmV0dXJuIHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmdW5jKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cbmZ1bmN0aW9uIGlzTnVtKG51bSAvKjogYW55Ki8pIC8qOiBib29sZWFuICVjaGVja3MqL3tcbiAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdudW1iZXInICYmICFpc05hTihudW0pO1xufVxuZnVuY3Rpb24gaW50KGEgLyo6IHN0cmluZyovKSAvKjogbnVtYmVyKi97XG4gIHJldHVybiBwYXJzZUludChhLCAxMCk7XG59XG5mdW5jdGlvbiBkb250U2V0TWUocHJvcHMgLyo6IE9iamVjdCovLCBwcm9wTmFtZSAvKjogc3RyaW5nKi8sIGNvbXBvbmVudE5hbWUgLyo6IHN0cmluZyovKSAvKjogP0Vycm9yKi97XG4gIGlmIChwcm9wc1twcm9wTmFtZV0pIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKGBJbnZhbGlkIHByb3AgJHtwcm9wTmFtZX0gcGFzc2VkIHRvICR7Y29tcG9uZW50TmFtZX0gLSBkbyBub3Qgc2V0IHRoaXMsIHNldCBpdCBvbiB0aGUgY2hpbGQuYCk7XG4gIH1cbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkb250U2V0TWUiLCJmaW5kSW5BcnJheSIsImludCIsImlzRnVuY3Rpb24iLCJpc051bSIsImFycmF5IiwiY2FsbGJhY2siLCJpIiwibGVuZ3RoIiwiYXBwbHkiLCJmdW5jIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwibnVtIiwiaXNOYU4iLCJhIiwicGFyc2VJbnQiLCJwcm9wcyIsInByb3BOYW1lIiwiY29tcG9uZW50TmFtZSIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/react-draggable@4.5.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-draggable/build/cjs/utils/shims.js\n");

/***/ })

};
;