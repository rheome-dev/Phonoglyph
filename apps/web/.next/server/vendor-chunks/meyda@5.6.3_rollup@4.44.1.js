"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/meyda@5.6.3_rollup@4.44.1";
exports.ids = ["vendor-chunks/meyda@5.6.3_rollup@4.44.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/meyda@5.6.3_rollup@4.44.1/node_modules/meyda/dist/node/main.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/meyda@5.6.3_rollup@4.44.1/node_modules/meyda/dist/node/main.js ***!
  \***********************************************************************************************/
/***/ ((module) => {

eval("\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise */ function __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction blackman(size) {\n    var blackmanBuffer = new Float32Array(size);\n    var coeff1 = 2 * Math.PI / (size - 1);\n    var coeff2 = 2 * coeff1;\n    //According to http://uk.mathworks.com/help/signal/ref/blackman.html\n    //first half of the window\n    for(var i = 0; i < size / 2; i++){\n        blackmanBuffer[i] = 0.42 - 0.5 * Math.cos(i * coeff1) + 0.08 * Math.cos(i * coeff2);\n    }\n    //second half of the window\n    for(var i = Math.ceil(size / 2); i > 0; i--){\n        blackmanBuffer[size - i] = blackmanBuffer[i - 1];\n    }\n    return blackmanBuffer;\n}\nfunction sine(size) {\n    var coeff = Math.PI / (size - 1);\n    var sineBuffer = new Float32Array(size);\n    for(var i = 0; i < size; i++){\n        sineBuffer[i] = Math.sin(coeff * i);\n    }\n    return sineBuffer;\n}\nfunction hanning(size) {\n    var hanningBuffer = new Float32Array(size);\n    for(var i = 0; i < size; i++){\n        // According to the R documentation\n        // http://ugrad.stat.ubc.ca/R/library/e1071/html/hanning.window.html\n        hanningBuffer[i] = 0.5 - 0.5 * Math.cos(2 * Math.PI * i / (size - 1));\n    }\n    return hanningBuffer;\n}\nfunction hamming(size) {\n    var hammingBuffer = new Float32Array(size);\n    for(var i = 0; i < size; i++){\n        //According to http://uk.mathworks.com/help/signal/ref/hamming.html\n        hammingBuffer[i] = 0.54 - 0.46 * Math.cos(2 * Math.PI * (i / size - 1));\n    }\n    return hammingBuffer;\n}\nvar windowing = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    blackman: blackman,\n    hamming: hamming,\n    hanning: hanning,\n    sine: sine\n});\nvar windows = {};\nfunction isPowerOfTwo(num) {\n    while(num % 2 === 0 && num > 1){\n        num /= 2;\n    }\n    return num === 1;\n}\nfunction pointwiseBufferMult(a, b) {\n    var c = [];\n    for(var i = 0; i < Math.min(a.length, b.length); i++){\n        c[i] = a[i] * b[i];\n    }\n    return c;\n}\nfunction applyWindow(signal, windowname) {\n    if (windowname !== \"rect\") {\n        if (windowname === \"\" || !windowname) windowname = \"hanning\";\n        if (!windows[windowname]) windows[windowname] = {};\n        if (!windows[windowname][signal.length]) {\n            try {\n                windows[windowname][signal.length] = windowing[windowname](signal.length);\n            } catch (e) {\n                throw new Error(\"Invalid windowing function\");\n            }\n        }\n        signal = pointwiseBufferMult(signal, windows[windowname][signal.length]);\n    }\n    return signal;\n}\nfunction createBarkScale(length, sampleRate, bufferSize) {\n    var barkScale = new Float32Array(length);\n    for(var i = 0; i < barkScale.length; i++){\n        barkScale[i] = i * sampleRate / bufferSize;\n        barkScale[i] = 13 * Math.atan(barkScale[i] / 1315.8) + 3.5 * Math.atan(Math.pow(barkScale[i] / 7518, 2));\n    }\n    return barkScale;\n}\nfunction arrayToTyped(t) {\n    // utility to convert arrays to typed F32 arrays\n    return Float32Array.from(t);\n}\nfunction _melToFreq(melValue) {\n    var freqValue = 700 * (Math.exp(melValue / 1125) - 1);\n    return freqValue;\n}\nfunction _freqToMel(freqValue) {\n    var melValue = 1125 * Math.log(1 + freqValue / 700);\n    return melValue;\n}\nfunction createMelFilterBank(numFilters, sampleRate, bufferSize) {\n    //the +2 is the upper and lower limits\n    var melValues = new Float32Array(numFilters + 2);\n    var melValuesInFreq = new Float32Array(numFilters + 2);\n    //Generate limits in Hz - from 0 to the nyquist.\n    var lowerLimitFreq = 0;\n    var upperLimitFreq = sampleRate / 2;\n    //Convert the limits to Mel\n    var lowerLimitMel = _freqToMel(lowerLimitFreq);\n    var upperLimitMel = _freqToMel(upperLimitFreq);\n    //Find the range\n    var range = upperLimitMel - lowerLimitMel;\n    //Find the range as part of the linear interpolation\n    var valueToAdd = range / (numFilters + 1);\n    var fftBinsOfFreq = new Array(numFilters + 2);\n    for(var i = 0; i < melValues.length; i++){\n        // Initialising the mel frequencies\n        // They're a linear interpolation between the lower and upper limits.\n        melValues[i] = i * valueToAdd;\n        // Convert back to Hz\n        melValuesInFreq[i] = _melToFreq(melValues[i]);\n        // Find the corresponding bins\n        fftBinsOfFreq[i] = Math.floor((bufferSize + 1) * melValuesInFreq[i] / sampleRate);\n    }\n    var filterBank = new Array(numFilters);\n    for(var j = 0; j < filterBank.length; j++){\n        // Create a two dimensional array of size numFilters * (buffersize/2)+1\n        // pre-populating the arrays with 0s.\n        filterBank[j] = new Array(bufferSize / 2 + 1).fill(0);\n        //creating the lower and upper slopes for each bin\n        for(var i = fftBinsOfFreq[j]; i < fftBinsOfFreq[j + 1]; i++){\n            filterBank[j][i] = (i - fftBinsOfFreq[j]) / (fftBinsOfFreq[j + 1] - fftBinsOfFreq[j]);\n        }\n        for(var i = fftBinsOfFreq[j + 1]; i < fftBinsOfFreq[j + 2]; i++){\n            filterBank[j][i] = (fftBinsOfFreq[j + 2] - i) / (fftBinsOfFreq[j + 2] - fftBinsOfFreq[j + 1]);\n        }\n    }\n    return filterBank;\n}\nfunction hzToOctaves(freq, A440) {\n    return Math.log2(16 * freq / A440);\n}\nfunction normalizeByColumn(a) {\n    var emptyRow = a[0].map(function() {\n        return 0;\n    });\n    var colDenominators = a.reduce(function(acc, row) {\n        row.forEach(function(cell, j) {\n            acc[j] += Math.pow(cell, 2);\n        });\n        return acc;\n    }, emptyRow).map(Math.sqrt);\n    return a.map(function(row, i) {\n        return row.map(function(v, j) {\n            return v / (colDenominators[j] || 1);\n        });\n    });\n}\nfunction createChromaFilterBank(numFilters, sampleRate, bufferSize, centerOctave, octaveWidth, baseC, A440) {\n    if (centerOctave === void 0) {\n        centerOctave = 5;\n    }\n    if (octaveWidth === void 0) {\n        octaveWidth = 2;\n    }\n    if (baseC === void 0) {\n        baseC = true;\n    }\n    if (A440 === void 0) {\n        A440 = 440;\n    }\n    var numOutputBins = Math.floor(bufferSize / 2) + 1;\n    var frequencyBins = new Array(bufferSize).fill(0).map(function(_, i) {\n        return numFilters * hzToOctaves(sampleRate * i / bufferSize, A440);\n    });\n    // Set a value for the 0 Hz bin that is 1.5 octaves below bin 1\n    // (so chroma is 50% rotated from bin 1, and bin width is broad)\n    frequencyBins[0] = frequencyBins[1] - 1.5 * numFilters;\n    var binWidthBins = frequencyBins.slice(1).map(function(v, i) {\n        return Math.max(v - frequencyBins[i]);\n    }, 1).concat([\n        1\n    ]);\n    var halfNumFilters = Math.round(numFilters / 2);\n    var filterPeaks = new Array(numFilters).fill(0).map(function(_, i) {\n        return frequencyBins.map(function(frq) {\n            return (10 * numFilters + halfNumFilters + frq - i) % numFilters - halfNumFilters;\n        });\n    });\n    var weights = filterPeaks.map(function(row, i) {\n        return row.map(function(_, j) {\n            return Math.exp(-0.5 * Math.pow(2 * filterPeaks[i][j] / binWidthBins[j], 2));\n        });\n    });\n    weights = normalizeByColumn(weights);\n    if (octaveWidth) {\n        var octaveWeights = frequencyBins.map(function(v) {\n            return Math.exp(-0.5 * Math.pow((v / numFilters - centerOctave) / octaveWidth, 2));\n        });\n        weights = weights.map(function(row) {\n            return row.map(function(cell, j) {\n                return cell * octaveWeights[j];\n            });\n        });\n    }\n    if (baseC) {\n        weights = __spreadArray(__spreadArray([], weights.slice(3), true), weights.slice(0, 3), true);\n    }\n    return weights.map(function(row) {\n        return row.slice(0, numOutputBins);\n    });\n}\nfunction frame(buffer, frameLength, hopLength) {\n    if (buffer.length < frameLength) {\n        throw new Error(\"Buffer is too short for frame length\");\n    }\n    if (hopLength < 1) {\n        throw new Error(\"Hop length cannot be less that 1\");\n    }\n    if (frameLength < 1) {\n        throw new Error(\"Frame length cannot be less that 1\");\n    }\n    var numFrames = 1 + Math.floor((buffer.length - frameLength) / hopLength);\n    return new Array(numFrames).fill(0).map(function(_, i) {\n        return buffer.slice(i * hopLength, i * hopLength + frameLength);\n    });\n}\nfunction rms(_a) {\n    var signal = _a.signal;\n    // Keeping this bad runtime typecheck for consistency\n    if (typeof signal !== \"object\") {\n        throw new TypeError();\n    }\n    var rms = 0;\n    for(var i = 0; i < signal.length; i++){\n        rms += Math.pow(signal[i], 2);\n    }\n    rms = rms / signal.length;\n    rms = Math.sqrt(rms);\n    return rms;\n}\nfunction energy(_a) {\n    var signal = _a.signal;\n    if (typeof signal !== \"object\") {\n        throw new TypeError();\n    }\n    var energy = 0;\n    for(var i = 0; i < signal.length; i++){\n        energy += Math.pow(Math.abs(signal[i]), 2);\n    }\n    return energy;\n}\nfunction spectralSlope(_a) {\n    var ampSpectrum = _a.ampSpectrum, sampleRate = _a.sampleRate, bufferSize = _a.bufferSize;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    //linear regression\n    var ampSum = 0;\n    var freqSum = 0;\n    var freqs = new Float32Array(ampSpectrum.length);\n    var powFreqSum = 0;\n    var ampFreqSum = 0;\n    for(var i = 0; i < ampSpectrum.length; i++){\n        ampSum += ampSpectrum[i];\n        var curFreq = i * sampleRate / bufferSize;\n        freqs[i] = curFreq;\n        powFreqSum += curFreq * curFreq;\n        freqSum += curFreq;\n        ampFreqSum += curFreq * ampSpectrum[i];\n    }\n    return (ampSpectrum.length * ampFreqSum - freqSum * ampSum) / (ampSum * (powFreqSum - Math.pow(freqSum, 2)));\n}\nfunction mu(i, amplitudeSpect) {\n    var numerator = 0;\n    var denominator = 0;\n    for(var k = 0; k < amplitudeSpect.length; k++){\n        numerator += Math.pow(k, i) * Math.abs(amplitudeSpect[k]);\n        denominator += amplitudeSpect[k];\n    }\n    return numerator / denominator;\n}\nfunction spectralCentroid(_a) {\n    var ampSpectrum = _a.ampSpectrum;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    return mu(1, ampSpectrum);\n}\nfunction spectralRolloff(_a) {\n    var ampSpectrum = _a.ampSpectrum, sampleRate = _a.sampleRate;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    var ampspec = ampSpectrum;\n    //calculate nyquist bin\n    var nyqBin = sampleRate / (2 * (ampspec.length - 1));\n    var ec = 0;\n    for(var i = 0; i < ampspec.length; i++){\n        ec += ampspec[i];\n    }\n    var threshold = 0.99 * ec;\n    var n = ampspec.length - 1;\n    while(ec > threshold && n >= 0){\n        ec -= ampspec[n];\n        --n;\n    }\n    return (n + 1) * nyqBin;\n}\nfunction spectralFlatness(_a) {\n    var ampSpectrum = _a.ampSpectrum;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    var numerator = 0;\n    var denominator = 0;\n    for(var i = 0; i < ampSpectrum.length; i++){\n        numerator += Math.log(ampSpectrum[i]);\n        denominator += ampSpectrum[i];\n    }\n    return Math.exp(numerator / ampSpectrum.length) * ampSpectrum.length / denominator;\n}\nfunction spectralSpread(_a) {\n    var ampSpectrum = _a.ampSpectrum;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    return Math.sqrt(mu(2, ampSpectrum) - Math.pow(mu(1, ampSpectrum), 2));\n}\nfunction spectralSkewness(_a) {\n    var ampSpectrum = _a.ampSpectrum;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    var mu1 = mu(1, ampSpectrum);\n    var mu2 = mu(2, ampSpectrum);\n    var mu3 = mu(3, ampSpectrum);\n    var numerator = 2 * Math.pow(mu1, 3) - 3 * mu1 * mu2 + mu3;\n    var denominator = Math.pow(Math.sqrt(mu2 - Math.pow(mu1, 2)), 3);\n    return numerator / denominator;\n}\nfunction spectralKurtosis(_a) {\n    var ampSpectrum = _a.ampSpectrum;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    var ampspec = ampSpectrum;\n    var mu1 = mu(1, ampspec);\n    var mu2 = mu(2, ampspec);\n    var mu3 = mu(3, ampspec);\n    var mu4 = mu(4, ampspec);\n    var numerator = -3 * Math.pow(mu1, 4) + 6 * mu1 * mu2 - 4 * mu1 * mu3 + mu4;\n    var denominator = Math.pow(Math.sqrt(mu2 - Math.pow(mu1, 2)), 4);\n    return numerator / denominator;\n}\nfunction zcr(_a) {\n    var signal = _a.signal;\n    if (typeof signal !== \"object\") {\n        throw new TypeError();\n    }\n    var zcr = 0;\n    for(var i = 1; i < signal.length; i++){\n        if (signal[i - 1] >= 0 && signal[i] < 0 || signal[i - 1] < 0 && signal[i] >= 0) {\n            zcr++;\n        }\n    }\n    return zcr;\n}\nfunction loudness(_a) {\n    var ampSpectrum = _a.ampSpectrum, barkScale = _a.barkScale, _b = _a.numberOfBarkBands, numberOfBarkBands = _b === void 0 ? 24 : _b;\n    if (typeof ampSpectrum !== \"object\" || typeof barkScale !== \"object\") {\n        throw new TypeError();\n    }\n    var NUM_BARK_BANDS = numberOfBarkBands;\n    var specific = new Float32Array(NUM_BARK_BANDS);\n    var total = 0;\n    var normalisedSpectrum = ampSpectrum;\n    var bbLimits = new Int32Array(NUM_BARK_BANDS + 1);\n    bbLimits[0] = 0;\n    var currentBandEnd = barkScale[normalisedSpectrum.length - 1] / NUM_BARK_BANDS;\n    var currentBand = 1;\n    for(var i = 0; i < normalisedSpectrum.length; i++){\n        while(barkScale[i] > currentBandEnd){\n            bbLimits[currentBand++] = i;\n            currentBandEnd = currentBand * barkScale[normalisedSpectrum.length - 1] / NUM_BARK_BANDS;\n        }\n    }\n    bbLimits[NUM_BARK_BANDS] = normalisedSpectrum.length - 1;\n    //process\n    for(var i = 0; i < NUM_BARK_BANDS; i++){\n        var sum = 0;\n        for(var j = bbLimits[i]; j < bbLimits[i + 1]; j++){\n            sum += normalisedSpectrum[j];\n        }\n        specific[i] = Math.pow(sum, 0.23);\n    }\n    //get total loudness\n    for(var i = 0; i < specific.length; i++){\n        total += specific[i];\n    }\n    return {\n        specific: specific,\n        total: total\n    };\n}\nfunction perceptualSpread(_a) {\n    var ampSpectrum = _a.ampSpectrum, barkScale = _a.barkScale;\n    var loudnessValue = loudness({\n        ampSpectrum: ampSpectrum,\n        barkScale: barkScale\n    });\n    var max = 0;\n    for(var i = 0; i < loudnessValue.specific.length; i++){\n        if (loudnessValue.specific[i] > max) {\n            max = loudnessValue.specific[i];\n        }\n    }\n    var spread = Math.pow((loudnessValue.total - max) / loudnessValue.total, 2);\n    return spread;\n}\nfunction perceptualSharpness(_a) {\n    var ampSpectrum = _a.ampSpectrum, barkScale = _a.barkScale;\n    var loudnessValue = loudness({\n        ampSpectrum: ampSpectrum,\n        barkScale: barkScale\n    });\n    var spec = loudnessValue.specific;\n    var output = 0;\n    for(var i = 0; i < spec.length; i++){\n        if (i < 15) {\n            output += (i + 1) * spec[i + 1];\n        } else {\n            output += 0.066 * Math.exp(0.171 * (i + 1));\n        }\n    }\n    output *= 0.11 / loudnessValue.total;\n    return output;\n}\nfunction extractPowerSpectrum(_a) {\n    var ampSpectrum = _a.ampSpectrum;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    var powerSpectrum = new Float32Array(ampSpectrum.length);\n    for(var i = 0; i < powerSpectrum.length; i++){\n        powerSpectrum[i] = Math.pow(ampSpectrum[i], 2);\n    }\n    return powerSpectrum;\n}\nfunction extractMelBands(_a) {\n    var ampSpectrum = _a.ampSpectrum, melFilterBank = _a.melFilterBank, bufferSize = _a.bufferSize;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError(\"Valid ampSpectrum is required to generate melBands\");\n    }\n    if (typeof melFilterBank !== \"object\") {\n        throw new TypeError(\"Valid melFilterBank is required to generate melBands\");\n    }\n    var powSpec = extractPowerSpectrum({\n        ampSpectrum: ampSpectrum\n    });\n    var numFilters = melFilterBank.length;\n    var filtered = Array(numFilters);\n    var loggedMelBands = new Float32Array(numFilters);\n    for(var i = 0; i < loggedMelBands.length; i++){\n        filtered[i] = new Float32Array(bufferSize / 2);\n        loggedMelBands[i] = 0;\n        for(var j = 0; j < bufferSize / 2; j++){\n            //point-wise multiplication between power spectrum and filterbanks.\n            filtered[i][j] = melFilterBank[i][j] * powSpec[j];\n            //summing up all of the coefficients into one array\n            loggedMelBands[i] += filtered[i][j];\n        }\n        //log each coefficient.\n        loggedMelBands[i] = Math.log(loggedMelBands[i] + 1);\n    }\n    return Array.prototype.slice.call(loggedMelBands);\n}\nfunction getDefaultExportFromCjs(x1) {\n    return x1 && x1.__esModule && Object.prototype.hasOwnProperty.call(x1, \"default\") ? x1[\"default\"] : x1;\n}\n/*===========================================================================*\\\n * Discrete Cosine Transform\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Mel-scale and its related coefficients used in\n * human speech analysis.\n\\*===========================================================================*/ var cosMap = null;\n// Builds a cosine map for the given input size. This allows multiple input sizes to be memoized automagically\n// if you want to run the DCT over and over.\nvar memoizeCosines = function(N) {\n    cosMap = cosMap || {};\n    cosMap[N] = new Array(N * N);\n    var PI_N = Math.PI / N;\n    for(var k = 0; k < N; k++){\n        for(var n = 0; n < N; n++){\n            cosMap[N][n + k * N] = Math.cos(PI_N * (n + 0.5) * k);\n        }\n    }\n};\nfunction dct$2(signal, scale) {\n    var L = signal.length;\n    scale = scale || 2;\n    if (!cosMap || !cosMap[L]) memoizeCosines(L);\n    var coefficients = signal.map(function() {\n        return 0;\n    });\n    return coefficients.map(function(__, ix) {\n        return scale * signal.reduce(function(prev, cur, ix_, arr) {\n            return prev + cur * cosMap[L][ix_ + ix * L];\n        }, 0);\n    });\n}\nvar dct_1 = dct$2;\nvar dct = dct_1;\nvar dct$1 = /*@__PURE__*/ getDefaultExportFromCjs(dct);\nfunction mfcc(_a) {\n    // Tutorial from:\n    // http://practicalcryptography.com/miscellaneous/machine-learning\n    // /guide-mel-frequency-cepstral-coefficients-mfccs/\n    // @ts-ignore\n    var ampSpectrum = _a.ampSpectrum, melFilterBank = _a.melFilterBank, numberOfMFCCCoefficients = _a.numberOfMFCCCoefficients, bufferSize = _a.bufferSize;\n    var _numberOfMFCCCoefficients = Math.min(40, Math.max(1, numberOfMFCCCoefficients || 13));\n    var numFilters = melFilterBank.length;\n    if (numFilters < _numberOfMFCCCoefficients) {\n        throw new Error(\"Insufficient filter bank for requested number of coefficients\");\n    }\n    var loggedMelBandsArray = extractMelBands({\n        ampSpectrum: ampSpectrum,\n        melFilterBank: melFilterBank,\n        bufferSize: bufferSize\n    });\n    var mfccs = dct$1(loggedMelBandsArray).slice(0, _numberOfMFCCCoefficients);\n    return mfccs;\n}\nfunction chroma(_a) {\n    var ampSpectrum = _a.ampSpectrum, chromaFilterBank = _a.chromaFilterBank;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError(\"Valid ampSpectrum is required to generate chroma\");\n    }\n    if (typeof chromaFilterBank !== \"object\") {\n        throw new TypeError(\"Valid chromaFilterBank is required to generate chroma\");\n    }\n    var chromagram = chromaFilterBank.map(function(row, i) {\n        return ampSpectrum.reduce(function(acc, v, j) {\n            return acc + v * row[j];\n        }, 0);\n    });\n    var maxVal = Math.max.apply(Math, chromagram);\n    return maxVal ? chromagram.map(function(v) {\n        return v / maxVal;\n    }) : chromagram;\n}\n// This file isn't being typechecked at all because there are major issues with it.\n// See #852 for details. Once that's merged, this file should be typechecked.\n// @ts-nocheck\nfunction spectralFlux(_a) {\n    var signal = _a.signal, previousSignal = _a.previousSignal, bufferSize = _a.bufferSize;\n    if (typeof signal !== \"object\" || typeof previousSignal != \"object\") {\n        throw new TypeError();\n    }\n    var sf = 0;\n    for(var i = -(bufferSize / 2); i < signal.length / 2 - 1; i++){\n        x = Math.abs(signal[i]) - Math.abs(previousSignal[i]);\n        sf += (x + Math.abs(x)) / 2;\n    }\n    return sf;\n}\nfunction spectralCrest(_a) {\n    var ampSpectrum = _a.ampSpectrum;\n    if (typeof ampSpectrum !== \"object\") {\n        throw new TypeError();\n    }\n    var rms = 0;\n    var peak = -Infinity;\n    ampSpectrum.forEach(function(x1) {\n        rms += Math.pow(x1, 2);\n        peak = x1 > peak ? x1 : peak;\n    });\n    rms = rms / ampSpectrum.length;\n    rms = Math.sqrt(rms);\n    return peak / rms;\n}\nvar buffer = function(args) {\n    return args.signal;\n};\nvar complexSpectrum = function(args) {\n    return args.complexSpectrum;\n};\nvar amplitudeSpectrum = function(args) {\n    return args.ampSpectrum;\n};\nvar extractors = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    amplitudeSpectrum: amplitudeSpectrum,\n    buffer: buffer,\n    chroma: chroma,\n    complexSpectrum: complexSpectrum,\n    energy: energy,\n    loudness: loudness,\n    melBands: extractMelBands,\n    mfcc: mfcc,\n    perceptualSharpness: perceptualSharpness,\n    perceptualSpread: perceptualSpread,\n    powerSpectrum: extractPowerSpectrum,\n    rms: rms,\n    spectralCentroid: spectralCentroid,\n    spectralCrest: spectralCrest,\n    spectralFlatness: spectralFlatness,\n    spectralFlux: spectralFlux,\n    spectralKurtosis: spectralKurtosis,\n    spectralRolloff: spectralRolloff,\n    spectralSkewness: spectralSkewness,\n    spectralSlope: spectralSlope,\n    spectralSpread: spectralSpread,\n    zcr: zcr\n});\n// memoization of the reversal of different lengths.\nfunction _toConsumableArray(arr) {\n    if (Array.isArray(arr)) {\n        for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++){\n            arr2[i] = arr[i];\n        }\n        return arr2;\n    } else {\n        return Array.from(arr);\n    }\n}\nvar memoizedReversal = {};\nvar memoizedZeroBuffers = {};\nvar constructComplexArray = function constructComplexArray(signal) {\n    var complexSignal = {};\n    complexSignal.real = signal.real === undefined ? signal.slice() : signal.real.slice();\n    var bufferSize = complexSignal.real.length;\n    if (memoizedZeroBuffers[bufferSize] === undefined) {\n        memoizedZeroBuffers[bufferSize] = Array.apply(null, Array(bufferSize)).map(Number.prototype.valueOf, 0);\n    }\n    complexSignal.imag = memoizedZeroBuffers[bufferSize].slice();\n    return complexSignal;\n};\nvar bitReverseArray = function bitReverseArray(N) {\n    if (memoizedReversal[N] === undefined) {\n        var maxBinaryLength = (N - 1).toString(2).length; //get the binary length of the largest index.\n        var templateBinary = \"0\".repeat(maxBinaryLength); //create a template binary of that length.\n        var reversed = {};\n        for(var n = 0; n < N; n++){\n            var currBinary = n.toString(2); //get binary value of current index.\n            //prepend zeros from template to current binary. This makes binary values of all indices have the same length.\n            currBinary = templateBinary.substr(currBinary.length) + currBinary;\n            currBinary = [].concat(_toConsumableArray(currBinary)).reverse().join(\"\"); //reverse\n            reversed[n] = parseInt(currBinary, 2); //convert to decimal\n        }\n        memoizedReversal[N] = reversed; //save\n    }\n    return memoizedReversal[N];\n};\n// complex multiplication\nvar multiply = function multiply(a, b) {\n    return {\n        \"real\": a.real * b.real - a.imag * b.imag,\n        \"imag\": a.real * b.imag + a.imag * b.real\n    };\n};\n// complex addition\nvar add = function add(a, b) {\n    return {\n        \"real\": a.real + b.real,\n        \"imag\": a.imag + b.imag\n    };\n};\n// complex subtraction\nvar subtract = function subtract(a, b) {\n    return {\n        \"real\": a.real - b.real,\n        \"imag\": a.imag - b.imag\n    };\n};\n// euler's identity e^x = cos(x) + sin(x)\nvar euler = function euler(kn, N) {\n    var x1 = -2 * Math.PI * kn / N;\n    return {\n        \"real\": Math.cos(x1),\n        \"imag\": Math.sin(x1)\n    };\n};\n// complex conjugate\nvar conj = function conj(a) {\n    a.imag *= -1;\n    return a;\n};\nvar utils$1 = {\n    bitReverseArray: bitReverseArray,\n    multiply: multiply,\n    add: add,\n    subtract: subtract,\n    euler: euler,\n    conj: conj,\n    constructComplexArray: constructComplexArray\n};\nvar utils = utils$1;\n// real to complex fft\nvar fft = function fft(signal) {\n    var complexSignal = {};\n    if (signal.real === undefined || signal.imag === undefined) {\n        complexSignal = utils.constructComplexArray(signal);\n    } else {\n        complexSignal.real = signal.real.slice();\n        complexSignal.imag = signal.imag.slice();\n    }\n    var N = complexSignal.real.length;\n    var logN = Math.log2(N);\n    if (Math.round(logN) != logN) throw new Error(\"Input size must be a power of 2.\");\n    if (complexSignal.real.length != complexSignal.imag.length) {\n        throw new Error(\"Real and imaginary components must have the same length.\");\n    }\n    var bitReversedIndices = utils.bitReverseArray(N);\n    // sort array\n    var ordered = {\n        \"real\": [],\n        \"imag\": []\n    };\n    for(var i = 0; i < N; i++){\n        ordered.real[bitReversedIndices[i]] = complexSignal.real[i];\n        ordered.imag[bitReversedIndices[i]] = complexSignal.imag[i];\n    }\n    for(var _i = 0; _i < N; _i++){\n        complexSignal.real[_i] = ordered.real[_i];\n        complexSignal.imag[_i] = ordered.imag[_i];\n    }\n    // iterate over the number of stages\n    for(var n = 1; n <= logN; n++){\n        var currN = Math.pow(2, n);\n        // find twiddle factors\n        for(var k = 0; k < currN / 2; k++){\n            var twiddle = utils.euler(k, currN);\n            // on each block of FT, implement the butterfly diagram\n            for(var m = 0; m < N / currN; m++){\n                var currEvenIndex = currN * m + k;\n                var currOddIndex = currN * m + k + currN / 2;\n                var currEvenIndexSample = {\n                    \"real\": complexSignal.real[currEvenIndex],\n                    \"imag\": complexSignal.imag[currEvenIndex]\n                };\n                var currOddIndexSample = {\n                    \"real\": complexSignal.real[currOddIndex],\n                    \"imag\": complexSignal.imag[currOddIndex]\n                };\n                var odd = utils.multiply(twiddle, currOddIndexSample);\n                var subtractionResult = utils.subtract(currEvenIndexSample, odd);\n                complexSignal.real[currOddIndex] = subtractionResult.real;\n                complexSignal.imag[currOddIndex] = subtractionResult.imag;\n                var additionResult = utils.add(odd, currEvenIndexSample);\n                complexSignal.real[currEvenIndex] = additionResult.real;\n                complexSignal.imag[currEvenIndex] = additionResult.imag;\n            }\n        }\n    }\n    return complexSignal;\n};\n// complex to real ifft\nvar ifft = function ifft(signal) {\n    if (signal.real === undefined || signal.imag === undefined) {\n        throw new Error(\"IFFT only accepts a complex input.\");\n    }\n    var N = signal.real.length;\n    var complexSignal = {\n        \"real\": [],\n        \"imag\": []\n    };\n    //take complex conjugate in order to be able to use the regular FFT for IFFT\n    for(var i = 0; i < N; i++){\n        var currentSample = {\n            \"real\": signal.real[i],\n            \"imag\": signal.imag[i]\n        };\n        var conjugateSample = utils.conj(currentSample);\n        complexSignal.real[i] = conjugateSample.real;\n        complexSignal.imag[i] = conjugateSample.imag;\n    }\n    //compute\n    var X = fft(complexSignal);\n    //normalize\n    complexSignal.real = X.real.map(function(val) {\n        return val / N;\n    });\n    complexSignal.imag = X.imag.map(function(val) {\n        return val / N;\n    });\n    return complexSignal;\n};\nvar fft_1 = {\n    fft: fft,\n    ifft: ifft\n};\n/**\n * Meyda's interface to the Web Audio API. MeydaAnalyzer abstracts an API on\n * top of the Web Audio API's ScriptProcessorNode, running the Meyda audio\n * feature extractors inside that context.\n *\n * MeydaAnalyzer's constructor should not be called directly - MeydaAnalyzer\n * objects should be generated using the {@link createMeydaAnalyzer}\n * factory function in the main Meyda class.\n *\n * Options are of type {@link MeydaAnalyzerOptions}.\n *\n * @example\n * ```javascript\n * const analyzer = Meyda.createMeydaAnalyzer({\n *   \"audioContext\": audioContext,\n *   \"source\": source,\n *   \"bufferSize\": 512,\n *   \"featureExtractors\": [\"rms\"],\n *   \"inputs\": 2,\n *   \"numberOfMFCCCoefficients\": 20\n *   \"callback\": features => {\n *     levelRangeElement.value = features.rms;\n *   }\n * });\n * ```\n */ var MeydaAnalyzer = /** @class */ function() {\n    /** @hidden */ function MeydaAnalyzer(options, _this) {\n        var _this_1 = this;\n        this._m = _this;\n        if (!options.audioContext) {\n            throw this._m.errors.noAC;\n        } else if (options.bufferSize && !isPowerOfTwo(options.bufferSize)) {\n            throw this._m._errors.notPow2;\n        } else if (!options.source) {\n            throw this._m._errors.noSource;\n        }\n        this._m.audioContext = options.audioContext;\n        // TODO: validate options\n        this._m.bufferSize = options.bufferSize || this._m.bufferSize || 256;\n        this._m.hopSize = options.hopSize || this._m.hopSize || this._m.bufferSize;\n        this._m.sampleRate = options.sampleRate || this._m.audioContext.sampleRate || 44100;\n        this._m.callback = options.callback;\n        this._m.windowingFunction = options.windowingFunction || \"hanning\";\n        this._m.featureExtractors = extractors;\n        this._m.EXTRACTION_STARTED = options.startImmediately || false;\n        this._m.channel = typeof options.channel === \"number\" ? options.channel : 0;\n        this._m.inputs = options.inputs || 1;\n        this._m.outputs = options.outputs || 1;\n        this._m.numberOfMFCCCoefficients = options.numberOfMFCCCoefficients || this._m.numberOfMFCCCoefficients || 13;\n        this._m.numberOfBarkBands = options.numberOfBarkBands || this._m.numberOfBarkBands || 24;\n        //create nodes\n        this._m.spn = this._m.audioContext.createScriptProcessor(this._m.bufferSize, this._m.inputs, this._m.outputs);\n        this._m.spn.connect(this._m.audioContext.destination);\n        this._m._featuresToExtract = options.featureExtractors || [];\n        //always recalculate BS and MFB when a new Meyda analyzer is created.\n        this._m.barkScale = createBarkScale(this._m.bufferSize, this._m.sampleRate, this._m.bufferSize);\n        this._m.melFilterBank = createMelFilterBank(Math.max(this._m.melBands, this._m.numberOfMFCCCoefficients), this._m.sampleRate, this._m.bufferSize);\n        this._m.inputData = null;\n        this._m.previousInputData = null;\n        this._m.frame = null;\n        this._m.previousFrame = null;\n        this.setSource(options.source);\n        this._m.spn.onaudioprocess = function(e) {\n            var buffer;\n            if (_this_1._m.inputData !== null) {\n                _this_1._m.previousInputData = _this_1._m.inputData;\n            }\n            _this_1._m.inputData = e.inputBuffer.getChannelData(_this_1._m.channel);\n            if (!_this_1._m.previousInputData) {\n                buffer = _this_1._m.inputData;\n            } else {\n                buffer = new Float32Array(_this_1._m.previousInputData.length + _this_1._m.inputData.length - _this_1._m.hopSize);\n                buffer.set(_this_1._m.previousInputData.slice(_this_1._m.hopSize));\n                buffer.set(_this_1._m.inputData, _this_1._m.previousInputData.length - _this_1._m.hopSize);\n            }\n            var frames = frame(buffer, _this_1._m.bufferSize, _this_1._m.hopSize);\n            frames.forEach(function(f) {\n                _this_1._m.frame = f;\n                var features = _this_1._m.extract(_this_1._m._featuresToExtract, _this_1._m.frame, _this_1._m.previousFrame);\n                // call callback if applicable\n                if (typeof _this_1._m.callback === \"function\" && _this_1._m.EXTRACTION_STARTED) {\n                    _this_1._m.callback(features);\n                }\n                _this_1._m.previousFrame = _this_1._m.frame;\n            });\n        };\n    }\n    /**\n     * Start feature extraction\n     * The audio features will be passed to the callback function that was defined\n     * in the MeydaOptions that were passed to the factory when constructing the\n     * MeydaAnalyzer.\n     * @param {(string|Array.<string>)} [features]\n     * Change the features that Meyda is extracting. Defaults to the features that\n     * were set upon construction in the options parameter.\n     * @example\n     * ```javascript\n     * analyzer.start('chroma');\n     * ```\n     */ MeydaAnalyzer.prototype.start = function(features) {\n        this._m._featuresToExtract = features || this._m._featuresToExtract;\n        this._m.EXTRACTION_STARTED = true;\n    };\n    /**\n     * Stop feature extraction.\n     * @example\n     * ```javascript\n     * analyzer.stop();\n     * ```\n     */ MeydaAnalyzer.prototype.stop = function() {\n        this._m.EXTRACTION_STARTED = false;\n    };\n    /**\n     * Set the Audio Node for Meyda to listen to.\n     * @param {AudioNode} source - The Audio Node for Meyda to listen to\n     * @example\n     * ```javascript\n     * analyzer.setSource(audioSourceNode);\n     * ```\n     */ MeydaAnalyzer.prototype.setSource = function(source) {\n        this._m.source && this._m.source.disconnect(this._m.spn);\n        this._m.source = source;\n        this._m.source.connect(this._m.spn);\n    };\n    /**\n     * Set the channel of the audio node for Meyda to listen to\n     * @param {number} channel - the index of the channel on the input audio node\n     * for Meyda to listen to.\n     * @example\n     * ```javascript\n     * analyzer.setChannel(0);\n     * ```\n     */ MeydaAnalyzer.prototype.setChannel = function(channel) {\n        if (channel <= this._m.inputs) {\n            this._m.channel = channel;\n        } else {\n            console.error(\"Channel \".concat(channel, \" does not exist. Make sure you've provided a value for 'inputs' that is greater than \").concat(channel, \" when instantiating the MeydaAnalyzer\"));\n        }\n    };\n    /**\n     * Get a set of features from the current frame.\n     * @param {(string|Array.<string>)} [features]\n     * Change the features that Meyda is extracting\n     * @example\n     * ```javascript\n     * analyzer.get('spectralFlatness');\n     * ```\n     */ MeydaAnalyzer.prototype.get = function(features) {\n        if (this._m.inputData) {\n            return this._m.extract(features || this._m._featuresToExtract, this._m.inputData, this._m.previousInputData);\n        } else {\n            return null;\n        }\n    };\n    return MeydaAnalyzer;\n}();\n/**\n * This file contains the default export for Meyda, you probably want to check\n * out {@link default}\n *\n * @module Meyda\n */ var Meyda = {\n    audioContext: null,\n    spn: null,\n    bufferSize: 512,\n    sampleRate: 44100,\n    melBands: 26,\n    chromaBands: 12,\n    callback: null,\n    windowingFunction: \"hanning\",\n    featureExtractors: extractors,\n    EXTRACTION_STARTED: false,\n    numberOfMFCCCoefficients: 13,\n    numberOfBarkBands: 24,\n    _featuresToExtract: [],\n    windowing: applyWindow,\n    /** @hidden */ _errors: {\n        notPow2: new Error(\"Meyda: Buffer size must be a power of 2, e.g. 64 or 512\"),\n        featureUndef: new Error(\"Meyda: No features defined.\"),\n        invalidFeatureFmt: new Error(\"Meyda: Invalid feature format\"),\n        invalidInput: new Error(\"Meyda: Invalid input.\"),\n        noAC: new Error(\"Meyda: No AudioContext specified.\"),\n        noSource: new Error(\"Meyda: No source node specified.\")\n    },\n    /**\n     * @summary\n     * Create a MeydaAnalyzer\n     *\n     * A factory function for creating a MeydaAnalyzer, the interface for using\n     * Meyda in the context of Web Audio.\n     *\n     * ```javascript\n     * const analyzer = Meyda.createMeydaAnalyzer({\n     *   \"audioContext\": audioContext,\n     *   \"source\": source,\n     *   \"bufferSize\": 512,\n     *   \"featureExtractors\": [\"rms\"],\n     *   \"inputs\": 2,\n     *   \"callback\": features => {\n     *     levelRangeElement.value = features.rms;\n     *   }\n     * });\n     * ```\n     */ createMeydaAnalyzer: createMeydaAnalyzer,\n    /**\n     * List available audio feature extractors. Return format provides the key to\n     * be used in selecting the extractor in the extract methods\n     */ listAvailableFeatureExtractors: listAvailableFeatureExtractors,\n    /**\n     * Extract an audio feature from a buffer\n     *\n     * Unless `meyda.windowingFunction` is set otherwise, `extract` will\n     * internally apply a hanning window to the buffer prior to conversion into\n     * the frequency domain.\n     *\n     * ```javascript\n     * meyda.bufferSize = 2048;\n     * const features = meyda.extract(['zcr', 'spectralCentroid'], signal);\n     * ```\n     */ extract: function(feature, signal, previousSignal) {\n        var _this = this;\n        if (!signal) throw this._errors.invalidInput;\n        else if (typeof signal != \"object\") throw this._errors.invalidInput;\n        else if (!feature) throw this._errors.featureUndef;\n        else if (!isPowerOfTwo(signal.length)) throw this._errors.notPow2;\n        if (typeof this.barkScale == \"undefined\" || this.barkScale.length != this.bufferSize) {\n            this.barkScale = createBarkScale(this.bufferSize, this.sampleRate, this.bufferSize);\n        }\n        // Recalculate mel bank if buffer length changed\n        if (typeof this.melFilterBank == \"undefined\" || this.barkScale.length != this.bufferSize || this.melFilterBank.length != this.melBands) {\n            this.melFilterBank = createMelFilterBank(Math.max(this.melBands, this.numberOfMFCCCoefficients), this.sampleRate, this.bufferSize);\n        }\n        // Recalculate chroma bank if buffer length changed\n        if (typeof this.chromaFilterBank == \"undefined\" || this.chromaFilterBank.length != this.chromaBands) {\n            this.chromaFilterBank = createChromaFilterBank(this.chromaBands, this.sampleRate, this.bufferSize);\n        }\n        if (\"buffer\" in signal && typeof signal.buffer == \"undefined\") {\n            //signal is a normal array, convert to F32A\n            this.signal = arrayToTyped(signal);\n        } else {\n            this.signal = signal;\n        }\n        var preparedSignal = prepareSignalWithSpectrum(signal, this.windowingFunction, this.bufferSize);\n        this.signal = preparedSignal.windowedSignal;\n        this.complexSpectrum = preparedSignal.complexSpectrum;\n        this.ampSpectrum = preparedSignal.ampSpectrum;\n        if (previousSignal) {\n            var preparedSignal_1 = prepareSignalWithSpectrum(previousSignal, this.windowingFunction, this.bufferSize);\n            this.previousSignal = preparedSignal_1.windowedSignal;\n            this.previousComplexSpectrum = preparedSignal_1.complexSpectrum;\n            this.previousAmpSpectrum = preparedSignal_1.ampSpectrum;\n        }\n        var extract = function(feature) {\n            return _this.featureExtractors[feature]({\n                ampSpectrum: _this.ampSpectrum,\n                chromaFilterBank: _this.chromaFilterBank,\n                complexSpectrum: _this.complexSpectrum,\n                signal: _this.signal,\n                bufferSize: _this.bufferSize,\n                sampleRate: _this.sampleRate,\n                barkScale: _this.barkScale,\n                melFilterBank: _this.melFilterBank,\n                previousSignal: _this.previousSignal,\n                previousAmpSpectrum: _this.previousAmpSpectrum,\n                previousComplexSpectrum: _this.previousComplexSpectrum,\n                numberOfMFCCCoefficients: _this.numberOfMFCCCoefficients,\n                numberOfBarkBands: _this.numberOfBarkBands\n            });\n        };\n        if (typeof feature === \"object\") {\n            return feature.reduce(function(acc, el) {\n                var _a;\n                return Object.assign({}, acc, (_a = {}, _a[el] = extract(el), _a));\n            }, {});\n        } else if (typeof feature === \"string\") {\n            return extract(feature);\n        } else {\n            throw this._errors.invalidFeatureFmt;\n        }\n    }\n};\nvar prepareSignalWithSpectrum = function(signal, windowingFunction, bufferSize) {\n    var preparedSignal = {};\n    if (typeof signal.buffer == \"undefined\") {\n        //signal is a normal array, convert to F32A\n        preparedSignal.signal = arrayToTyped(signal);\n    } else {\n        preparedSignal.signal = signal;\n    }\n    preparedSignal.windowedSignal = applyWindow(preparedSignal.signal, windowingFunction);\n    preparedSignal.complexSpectrum = fft_1.fft(preparedSignal.windowedSignal);\n    preparedSignal.ampSpectrum = new Float32Array(bufferSize / 2);\n    for(var i = 0; i < bufferSize / 2; i++){\n        preparedSignal.ampSpectrum[i] = Math.sqrt(Math.pow(preparedSignal.complexSpectrum.real[i], 2) + Math.pow(preparedSignal.complexSpectrum.imag[i], 2));\n    }\n    return preparedSignal;\n};\n/**\n * List available audio feature extractors. Return format provides the key to\n * be used in selecting the extractor in the extract methods\n */ function listAvailableFeatureExtractors() {\n    return Object.keys(this.featureExtractors);\n}\n/**\n * Create a MeydaAnalyzer\n *\n * A factory function for creating a MeydaAnalyzer, the interface for using\n * Meyda in the context of Web Audio.\n *\n * ```javascript\n * const analyzer = Meyda.createMeydaAnalyzer({\n *   \"audioContext\": audioContext,\n *   \"source\": source,\n *   \"bufferSize\": 512,\n *   \"featureExtractors\": [\"rms\"],\n *   \"inputs\": 2,\n *   \"callback\": features => {\n *     levelRangeElement.value = features.rms;\n *   }\n * });\n * ```\n */ function createMeydaAnalyzer(options) {\n    return new MeydaAnalyzer(options, Object.assign({}, Meyda));\n}\n// @ts-ignore\nif (false) {}\nmodule.exports = Meyda;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21leWRhQDUuNi4zX3JvbGx1cEA0LjQ0LjEvbm9kZV9tb2R1bGVzL21leWRhL2Rpc3Qvbm9kZS9tYWluLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUE7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBQzlFLDJCQUEyQixHQUczQixTQUFTQSxjQUFjQyxFQUFFLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUNqQyxJQUFJQSxRQUFRQyxVQUFVQyxNQUFNLEtBQUssR0FBRyxJQUFLLElBQUlDLElBQUksR0FBR0MsSUFBSUwsS0FBS0csTUFBTSxFQUFFRyxJQUFJRixJQUFJQyxHQUFHRCxJQUFLO1FBQ2pGLElBQUlFLE1BQU0sQ0FBRUYsQ0FBQUEsS0FBS0osSUFBRyxHQUFJO1lBQ3BCLElBQUksQ0FBQ00sSUFBSUEsS0FBS0MsTUFBTUMsU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQ1YsTUFBTSxHQUFHSTtZQUNsREUsRUFBRSxDQUFDRixFQUFFLEdBQUdKLElBQUksQ0FBQ0ksRUFBRTtRQUNuQjtJQUNKO0lBQ0EsT0FBT0wsR0FBR1ksTUFBTSxDQUFDTCxNQUFNQyxNQUFNQyxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDVjtBQUN0RDtBQUVBLFNBQVNZLFNBQVNDLElBQUk7SUFDbEIsSUFBSUMsaUJBQWlCLElBQUlDLGFBQWFGO0lBQ3RDLElBQUlHLFNBQVMsSUFBS0MsS0FBS0MsRUFBRSxHQUFLTCxDQUFBQSxPQUFPO0lBQ3JDLElBQUlNLFNBQVMsSUFBSUg7SUFDakIsb0VBQW9FO0lBQ3BFLDBCQUEwQjtJQUMxQixJQUFLLElBQUlaLElBQUksR0FBR0EsSUFBSVMsT0FBTyxHQUFHVCxJQUFLO1FBQy9CVSxjQUFjLENBQUNWLEVBQUUsR0FDYixPQUFPLE1BQU1hLEtBQUtHLEdBQUcsQ0FBQ2hCLElBQUlZLFVBQVUsT0FBT0MsS0FBS0csR0FBRyxDQUFDaEIsSUFBSWU7SUFDaEU7SUFDQSwyQkFBMkI7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O0FBQ0EsYUFBYTtBQUNiLElBQUksS0FBNkIsRUFDN0JpQixFQUFxQmpCO0FBRXpCa0IsT0FBT0MsT0FBTyxHQUFHbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWlkaXZpei93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21leWRhQDUuNi4zX3JvbGx1cEA0LjQ0LjEvbm9kZV9tb2R1bGVzL21leWRhL2Rpc3Qvbm9kZS9tYWluLmpzPzA5YzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XG5cbmZ1bmN0aW9uIGJsYWNrbWFuKHNpemUpIHtcbiAgICB2YXIgYmxhY2ttYW5CdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgIHZhciBjb2VmZjEgPSAoMiAqIE1hdGguUEkpIC8gKHNpemUgLSAxKTtcbiAgICB2YXIgY29lZmYyID0gMiAqIGNvZWZmMTtcbiAgICAvL0FjY29yZGluZyB0byBodHRwOi8vdWsubWF0aHdvcmtzLmNvbS9oZWxwL3NpZ25hbC9yZWYvYmxhY2ttYW4uaHRtbFxuICAgIC8vZmlyc3QgaGFsZiBvZiB0aGUgd2luZG93XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplIC8gMjsgaSsrKSB7XG4gICAgICAgIGJsYWNrbWFuQnVmZmVyW2ldID1cbiAgICAgICAgICAgIDAuNDIgLSAwLjUgKiBNYXRoLmNvcyhpICogY29lZmYxKSArIDAuMDggKiBNYXRoLmNvcyhpICogY29lZmYyKTtcbiAgICB9XG4gICAgLy9zZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93XG4gICAgZm9yICh2YXIgaSA9IE1hdGguY2VpbChzaXplIC8gMik7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgYmxhY2ttYW5CdWZmZXJbc2l6ZSAtIGldID0gYmxhY2ttYW5CdWZmZXJbaSAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gYmxhY2ttYW5CdWZmZXI7XG59XG5mdW5jdGlvbiBzaW5lKHNpemUpIHtcbiAgICB2YXIgY29lZmYgPSBNYXRoLlBJIC8gKHNpemUgLSAxKTtcbiAgICB2YXIgc2luZUJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgc2luZUJ1ZmZlcltpXSA9IE1hdGguc2luKGNvZWZmICogaSk7XG4gICAgfVxuICAgIHJldHVybiBzaW5lQnVmZmVyO1xufVxuZnVuY3Rpb24gaGFubmluZyhzaXplKSB7XG4gICAgdmFyIGhhbm5pbmdCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgUiBkb2N1bWVudGF0aW9uXG4gICAgICAgIC8vIGh0dHA6Ly91Z3JhZC5zdGF0LnViYy5jYS9SL2xpYnJhcnkvZTEwNzEvaHRtbC9oYW5uaW5nLndpbmRvdy5odG1sXG4gICAgICAgIGhhbm5pbmdCdWZmZXJbaV0gPSAwLjUgLSAwLjUgKiBNYXRoLmNvcygoMiAqIE1hdGguUEkgKiBpKSAvIChzaXplIC0gMSkpO1xuICAgIH1cbiAgICByZXR1cm4gaGFubmluZ0J1ZmZlcjtcbn1cbmZ1bmN0aW9uIGhhbW1pbmcoc2l6ZSkge1xuICAgIHZhciBoYW1taW5nQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAvL0FjY29yZGluZyB0byBodHRwOi8vdWsubWF0aHdvcmtzLmNvbS9oZWxwL3NpZ25hbC9yZWYvaGFtbWluZy5odG1sXG4gICAgICAgIGhhbW1pbmdCdWZmZXJbaV0gPSAwLjU0IC0gMC40NiAqIE1hdGguY29zKDIgKiBNYXRoLlBJICogKGkgLyBzaXplIC0gMSkpO1xuICAgIH1cbiAgICByZXR1cm4gaGFtbWluZ0J1ZmZlcjtcbn1cblxudmFyIHdpbmRvd2luZyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYmxhY2ttYW46IGJsYWNrbWFuLFxuICAgIGhhbW1pbmc6IGhhbW1pbmcsXG4gICAgaGFubmluZzogaGFubmluZyxcbiAgICBzaW5lOiBzaW5lXG59KTtcblxudmFyIHdpbmRvd3MgPSB7fTtcbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byhudW0pIHtcbiAgICB3aGlsZSAobnVtICUgMiA9PT0gMCAmJiBudW0gPiAxKSB7XG4gICAgICAgIG51bSAvPSAyO1xuICAgIH1cbiAgICByZXR1cm4gbnVtID09PSAxO1xufVxuZnVuY3Rpb24gcG9pbnR3aXNlQnVmZmVyTXVsdChhLCBiKSB7XG4gICAgdmFyIGMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7IGkrKykge1xuICAgICAgICBjW2ldID0gYVtpXSAqIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuZnVuY3Rpb24gYXBwbHlXaW5kb3coc2lnbmFsLCB3aW5kb3duYW1lKSB7XG4gICAgaWYgKHdpbmRvd25hbWUgIT09IFwicmVjdFwiKSB7XG4gICAgICAgIGlmICh3aW5kb3duYW1lID09PSBcIlwiIHx8ICF3aW5kb3duYW1lKVxuICAgICAgICAgICAgd2luZG93bmFtZSA9IFwiaGFubmluZ1wiO1xuICAgICAgICBpZiAoIXdpbmRvd3Nbd2luZG93bmFtZV0pXG4gICAgICAgICAgICB3aW5kb3dzW3dpbmRvd25hbWVdID0ge307XG4gICAgICAgIGlmICghd2luZG93c1t3aW5kb3duYW1lXVtzaWduYWwubGVuZ3RoXSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dzW3dpbmRvd25hbWVdW3NpZ25hbC5sZW5ndGhdID0gd2luZG93aW5nW3dpbmRvd25hbWVdKHNpZ25hbC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHdpbmRvd2luZyBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaWduYWwgPSBwb2ludHdpc2VCdWZmZXJNdWx0KHNpZ25hbCwgd2luZG93c1t3aW5kb3duYW1lXVtzaWduYWwubGVuZ3RoXSk7XG4gICAgfVxuICAgIHJldHVybiBzaWduYWw7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXJrU2NhbGUobGVuZ3RoLCBzYW1wbGVSYXRlLCBidWZmZXJTaXplKSB7XG4gICAgdmFyIGJhcmtTY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhcmtTY2FsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBiYXJrU2NhbGVbaV0gPSAoaSAqIHNhbXBsZVJhdGUpIC8gYnVmZmVyU2l6ZTtcbiAgICAgICAgYmFya1NjYWxlW2ldID1cbiAgICAgICAgICAgIDEzICogTWF0aC5hdGFuKGJhcmtTY2FsZVtpXSAvIDEzMTUuOCkgK1xuICAgICAgICAgICAgICAgIDMuNSAqIE1hdGguYXRhbihNYXRoLnBvdyhiYXJrU2NhbGVbaV0gLyA3NTE4LCAyKSk7XG4gICAgfVxuICAgIHJldHVybiBiYXJrU2NhbGU7XG59XG5mdW5jdGlvbiBhcnJheVRvVHlwZWQodCkge1xuICAgIC8vIHV0aWxpdHkgdG8gY29udmVydCBhcnJheXMgdG8gdHlwZWQgRjMyIGFycmF5c1xuICAgIHJldHVybiBGbG9hdDMyQXJyYXkuZnJvbSh0KTtcbn1cbmZ1bmN0aW9uIF9tZWxUb0ZyZXEobWVsVmFsdWUpIHtcbiAgICB2YXIgZnJlcVZhbHVlID0gNzAwICogKE1hdGguZXhwKG1lbFZhbHVlIC8gMTEyNSkgLSAxKTtcbiAgICByZXR1cm4gZnJlcVZhbHVlO1xufVxuZnVuY3Rpb24gX2ZyZXFUb01lbChmcmVxVmFsdWUpIHtcbiAgICB2YXIgbWVsVmFsdWUgPSAxMTI1ICogTWF0aC5sb2coMSArIGZyZXFWYWx1ZSAvIDcwMCk7XG4gICAgcmV0dXJuIG1lbFZhbHVlO1xufVxuZnVuY3Rpb24gY3JlYXRlTWVsRmlsdGVyQmFuayhudW1GaWx0ZXJzLCBzYW1wbGVSYXRlLCBidWZmZXJTaXplKSB7XG4gICAgLy90aGUgKzIgaXMgdGhlIHVwcGVyIGFuZCBsb3dlciBsaW1pdHNcbiAgICB2YXIgbWVsVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShudW1GaWx0ZXJzICsgMik7XG4gICAgdmFyIG1lbFZhbHVlc0luRnJlcSA9IG5ldyBGbG9hdDMyQXJyYXkobnVtRmlsdGVycyArIDIpO1xuICAgIC8vR2VuZXJhdGUgbGltaXRzIGluIEh6IC0gZnJvbSAwIHRvIHRoZSBueXF1aXN0LlxuICAgIHZhciBsb3dlckxpbWl0RnJlcSA9IDA7XG4gICAgdmFyIHVwcGVyTGltaXRGcmVxID0gc2FtcGxlUmF0ZSAvIDI7XG4gICAgLy9Db252ZXJ0IHRoZSBsaW1pdHMgdG8gTWVsXG4gICAgdmFyIGxvd2VyTGltaXRNZWwgPSBfZnJlcVRvTWVsKGxvd2VyTGltaXRGcmVxKTtcbiAgICB2YXIgdXBwZXJMaW1pdE1lbCA9IF9mcmVxVG9NZWwodXBwZXJMaW1pdEZyZXEpO1xuICAgIC8vRmluZCB0aGUgcmFuZ2VcbiAgICB2YXIgcmFuZ2UgPSB1cHBlckxpbWl0TWVsIC0gbG93ZXJMaW1pdE1lbDtcbiAgICAvL0ZpbmQgdGhlIHJhbmdlIGFzIHBhcnQgb2YgdGhlIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgdmFyIHZhbHVlVG9BZGQgPSByYW5nZSAvIChudW1GaWx0ZXJzICsgMSk7XG4gICAgdmFyIGZmdEJpbnNPZkZyZXEgPSBuZXcgQXJyYXkobnVtRmlsdGVycyArIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVsVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEluaXRpYWxpc2luZyB0aGUgbWVsIGZyZXF1ZW5jaWVzXG4gICAgICAgIC8vIFRoZXkncmUgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHRoZSBsb3dlciBhbmQgdXBwZXIgbGltaXRzLlxuICAgICAgICBtZWxWYWx1ZXNbaV0gPSBpICogdmFsdWVUb0FkZDtcbiAgICAgICAgLy8gQ29udmVydCBiYWNrIHRvIEh6XG4gICAgICAgIG1lbFZhbHVlc0luRnJlcVtpXSA9IF9tZWxUb0ZyZXEobWVsVmFsdWVzW2ldKTtcbiAgICAgICAgLy8gRmluZCB0aGUgY29ycmVzcG9uZGluZyBiaW5zXG4gICAgICAgIGZmdEJpbnNPZkZyZXFbaV0gPSBNYXRoLmZsb29yKCgoYnVmZmVyU2l6ZSArIDEpICogbWVsVmFsdWVzSW5GcmVxW2ldKSAvIHNhbXBsZVJhdGUpO1xuICAgIH1cbiAgICB2YXIgZmlsdGVyQmFuayA9IG5ldyBBcnJheShudW1GaWx0ZXJzKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpbHRlckJhbmsubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5IG9mIHNpemUgbnVtRmlsdGVycyAqIChidWZmZXJzaXplLzIpKzFcbiAgICAgICAgLy8gcHJlLXBvcHVsYXRpbmcgdGhlIGFycmF5cyB3aXRoIDBzLlxuICAgICAgICBmaWx0ZXJCYW5rW2pdID0gbmV3IEFycmF5KGJ1ZmZlclNpemUgLyAyICsgMSkuZmlsbCgwKTtcbiAgICAgICAgLy9jcmVhdGluZyB0aGUgbG93ZXIgYW5kIHVwcGVyIHNsb3BlcyBmb3IgZWFjaCBiaW5cbiAgICAgICAgZm9yICh2YXIgaSA9IGZmdEJpbnNPZkZyZXFbal07IGkgPCBmZnRCaW5zT2ZGcmVxW2ogKyAxXTsgaSsrKSB7XG4gICAgICAgICAgICBmaWx0ZXJCYW5rW2pdW2ldID1cbiAgICAgICAgICAgICAgICAoaSAtIGZmdEJpbnNPZkZyZXFbal0pIC8gKGZmdEJpbnNPZkZyZXFbaiArIDFdIC0gZmZ0Qmluc09mRnJlcVtqXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IGZmdEJpbnNPZkZyZXFbaiArIDFdOyBpIDwgZmZ0Qmluc09mRnJlcVtqICsgMl07IGkrKykge1xuICAgICAgICAgICAgZmlsdGVyQmFua1tqXVtpXSA9XG4gICAgICAgICAgICAgICAgKGZmdEJpbnNPZkZyZXFbaiArIDJdIC0gaSkgL1xuICAgICAgICAgICAgICAgICAgICAoZmZ0Qmluc09mRnJlcVtqICsgMl0gLSBmZnRCaW5zT2ZGcmVxW2ogKyAxXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlckJhbms7XG59XG5mdW5jdGlvbiBoelRvT2N0YXZlcyhmcmVxLCBBNDQwKSB7XG4gICAgcmV0dXJuIE1hdGgubG9nMigoMTYgKiBmcmVxKSAvIEE0NDApO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQnlDb2x1bW4oYSkge1xuICAgIHZhciBlbXB0eVJvdyA9IGFbMF0ubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH0pO1xuICAgIHZhciBjb2xEZW5vbWluYXRvcnMgPSBhXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcm93KSB7XG4gICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsLCBqKSB7XG4gICAgICAgICAgICBhY2Nbal0gKz0gTWF0aC5wb3coY2VsbCwgMik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIGVtcHR5Um93KVxuICAgICAgICAubWFwKE1hdGguc3FydCk7XG4gICAgcmV0dXJuIGEubWFwKGZ1bmN0aW9uIChyb3csIGkpIHsgcmV0dXJuIHJvdy5tYXAoZnVuY3Rpb24gKHYsIGopIHsgcmV0dXJuIHYgLyAoY29sRGVub21pbmF0b3JzW2pdIHx8IDEpOyB9KTsgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDaHJvbWFGaWx0ZXJCYW5rKG51bUZpbHRlcnMsIHNhbXBsZVJhdGUsIGJ1ZmZlclNpemUsIGNlbnRlck9jdGF2ZSwgb2N0YXZlV2lkdGgsIGJhc2VDLCBBNDQwKSB7XG4gICAgaWYgKGNlbnRlck9jdGF2ZSA9PT0gdm9pZCAwKSB7IGNlbnRlck9jdGF2ZSA9IDU7IH1cbiAgICBpZiAob2N0YXZlV2lkdGggPT09IHZvaWQgMCkgeyBvY3RhdmVXaWR0aCA9IDI7IH1cbiAgICBpZiAoYmFzZUMgPT09IHZvaWQgMCkgeyBiYXNlQyA9IHRydWU7IH1cbiAgICBpZiAoQTQ0MCA9PT0gdm9pZCAwKSB7IEE0NDAgPSA0NDA7IH1cbiAgICB2YXIgbnVtT3V0cHV0QmlucyA9IE1hdGguZmxvb3IoYnVmZmVyU2l6ZSAvIDIpICsgMTtcbiAgICB2YXIgZnJlcXVlbmN5QmlucyA9IG5ldyBBcnJheShidWZmZXJTaXplKVxuICAgICAgICAuZmlsbCgwKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiBudW1GaWx0ZXJzICogaHpUb09jdGF2ZXMoKHNhbXBsZVJhdGUgKiBpKSAvIGJ1ZmZlclNpemUsIEE0NDApOyB9KTtcbiAgICAvLyBTZXQgYSB2YWx1ZSBmb3IgdGhlIDAgSHogYmluIHRoYXQgaXMgMS41IG9jdGF2ZXMgYmVsb3cgYmluIDFcbiAgICAvLyAoc28gY2hyb21hIGlzIDUwJSByb3RhdGVkIGZyb20gYmluIDEsIGFuZCBiaW4gd2lkdGggaXMgYnJvYWQpXG4gICAgZnJlcXVlbmN5Qmluc1swXSA9IGZyZXF1ZW5jeUJpbnNbMV0gLSAxLjUgKiBudW1GaWx0ZXJzO1xuICAgIHZhciBiaW5XaWR0aEJpbnMgPSBmcmVxdWVuY3lCaW5zXG4gICAgICAgIC5zbGljZSgxKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiBNYXRoLm1heCh2IC0gZnJlcXVlbmN5Qmluc1tpXSk7IH0sIDEpXG4gICAgICAgIC5jb25jYXQoWzFdKTtcbiAgICB2YXIgaGFsZk51bUZpbHRlcnMgPSBNYXRoLnJvdW5kKG51bUZpbHRlcnMgLyAyKTtcbiAgICB2YXIgZmlsdGVyUGVha3MgPSBuZXcgQXJyYXkobnVtRmlsdGVycylcbiAgICAgICAgLmZpbGwoMClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoXywgaSkge1xuICAgICAgICByZXR1cm4gZnJlcXVlbmN5Qmlucy5tYXAoZnVuY3Rpb24gKGZycSkge1xuICAgICAgICAgICAgcmV0dXJuICgoMTAgKiBudW1GaWx0ZXJzICsgaGFsZk51bUZpbHRlcnMgKyBmcnEgLSBpKSAlIG51bUZpbHRlcnMpIC1cbiAgICAgICAgICAgICAgICBoYWxmTnVtRmlsdGVycztcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIHdlaWdodHMgPSBmaWx0ZXJQZWFrcy5tYXAoZnVuY3Rpb24gKHJvdywgaSkge1xuICAgICAgICByZXR1cm4gcm93Lm1hcChmdW5jdGlvbiAoXywgaikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZXhwKC0wLjUgKiBNYXRoLnBvdygoMiAqIGZpbHRlclBlYWtzW2ldW2pdKSAvIGJpbldpZHRoQmluc1tqXSwgMikpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB3ZWlnaHRzID0gbm9ybWFsaXplQnlDb2x1bW4od2VpZ2h0cyk7XG4gICAgaWYgKG9jdGF2ZVdpZHRoKSB7XG4gICAgICAgIHZhciBvY3RhdmVXZWlnaHRzID0gZnJlcXVlbmN5Qmlucy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmV4cCgtMC41ICogTWF0aC5wb3coKHYgLyBudW1GaWx0ZXJzIC0gY2VudGVyT2N0YXZlKSAvIG9jdGF2ZVdpZHRoLCAyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB3ZWlnaHRzID0gd2VpZ2h0cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHJvdy5tYXAoZnVuY3Rpb24gKGNlbGwsIGopIHsgcmV0dXJuIGNlbGwgKiBvY3RhdmVXZWlnaHRzW2pdOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChiYXNlQykge1xuICAgICAgICB3ZWlnaHRzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCB3ZWlnaHRzLnNsaWNlKDMpLCB0cnVlKSwgd2VpZ2h0cy5zbGljZSgwLCAzKSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB3ZWlnaHRzLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3cuc2xpY2UoMCwgbnVtT3V0cHV0Qmlucyk7IH0pO1xufVxuZnVuY3Rpb24gZnJhbWUoYnVmZmVyLCBmcmFtZUxlbmd0aCwgaG9wTGVuZ3RoKSB7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCBmcmFtZUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIgaXMgdG9vIHNob3J0IGZvciBmcmFtZSBsZW5ndGhcIik7XG4gICAgfVxuICAgIGlmIChob3BMZW5ndGggPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhvcCBsZW5ndGggY2Fubm90IGJlIGxlc3MgdGhhdCAxXCIpO1xuICAgIH1cbiAgICBpZiAoZnJhbWVMZW5ndGggPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyYW1lIGxlbmd0aCBjYW5ub3QgYmUgbGVzcyB0aGF0IDFcIik7XG4gICAgfVxuICAgIHZhciBudW1GcmFtZXMgPSAxICsgTWF0aC5mbG9vcigoYnVmZmVyLmxlbmd0aCAtIGZyYW1lTGVuZ3RoKSAvIGhvcExlbmd0aCk7XG4gICAgcmV0dXJuIG5ldyBBcnJheShudW1GcmFtZXMpXG4gICAgICAgIC5maWxsKDApXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuIGJ1ZmZlci5zbGljZShpICogaG9wTGVuZ3RoLCBpICogaG9wTGVuZ3RoICsgZnJhbWVMZW5ndGgpOyB9KTtcbn1cblxuZnVuY3Rpb24gcm1zIChfYSkge1xuICAgIHZhciBzaWduYWwgPSBfYS5zaWduYWw7XG4gICAgLy8gS2VlcGluZyB0aGlzIGJhZCBydW50aW1lIHR5cGVjaGVjayBmb3IgY29uc2lzdGVuY3lcbiAgICBpZiAodHlwZW9mIHNpZ25hbCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIHZhciBybXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJtcyArPSBNYXRoLnBvdyhzaWduYWxbaV0sIDIpO1xuICAgIH1cbiAgICBybXMgPSBybXMgLyBzaWduYWwubGVuZ3RoO1xuICAgIHJtcyA9IE1hdGguc3FydChybXMpO1xuICAgIHJldHVybiBybXM7XG59XG5cbmZ1bmN0aW9uIGVuZXJneSAoX2EpIHtcbiAgICB2YXIgc2lnbmFsID0gX2Euc2lnbmFsO1xuICAgIGlmICh0eXBlb2Ygc2lnbmFsICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIGVuZXJneSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZW5lcmd5ICs9IE1hdGgucG93KE1hdGguYWJzKHNpZ25hbFtpXSksIDIpO1xuICAgIH1cbiAgICByZXR1cm4gZW5lcmd5O1xufVxuXG5mdW5jdGlvbiBzcGVjdHJhbFNsb3BlIChfYSkge1xuICAgIHZhciBhbXBTcGVjdHJ1bSA9IF9hLmFtcFNwZWN0cnVtLCBzYW1wbGVSYXRlID0gX2Euc2FtcGxlUmF0ZSwgYnVmZmVyU2l6ZSA9IF9hLmJ1ZmZlclNpemU7XG4gICAgaWYgKHR5cGVvZiBhbXBTcGVjdHJ1bSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIC8vbGluZWFyIHJlZ3Jlc3Npb25cbiAgICB2YXIgYW1wU3VtID0gMDtcbiAgICB2YXIgZnJlcVN1bSA9IDA7XG4gICAgdmFyIGZyZXFzID0gbmV3IEZsb2F0MzJBcnJheShhbXBTcGVjdHJ1bS5sZW5ndGgpO1xuICAgIHZhciBwb3dGcmVxU3VtID0gMDtcbiAgICB2YXIgYW1wRnJlcVN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbXBTcGVjdHJ1bS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhbXBTdW0gKz0gYW1wU3BlY3RydW1baV07XG4gICAgICAgIHZhciBjdXJGcmVxID0gKGkgKiBzYW1wbGVSYXRlKSAvIGJ1ZmZlclNpemU7XG4gICAgICAgIGZyZXFzW2ldID0gY3VyRnJlcTtcbiAgICAgICAgcG93RnJlcVN1bSArPSBjdXJGcmVxICogY3VyRnJlcTtcbiAgICAgICAgZnJlcVN1bSArPSBjdXJGcmVxO1xuICAgICAgICBhbXBGcmVxU3VtICs9IGN1ckZyZXEgKiBhbXBTcGVjdHJ1bVtpXTtcbiAgICB9XG4gICAgcmV0dXJuICgoYW1wU3BlY3RydW0ubGVuZ3RoICogYW1wRnJlcVN1bSAtIGZyZXFTdW0gKiBhbXBTdW0pIC9cbiAgICAgICAgKGFtcFN1bSAqIChwb3dGcmVxU3VtIC0gTWF0aC5wb3coZnJlcVN1bSwgMikpKSk7XG59XG5cbmZ1bmN0aW9uIG11KGksIGFtcGxpdHVkZVNwZWN0KSB7XG4gICAgdmFyIG51bWVyYXRvciA9IDA7XG4gICAgdmFyIGRlbm9taW5hdG9yID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGFtcGxpdHVkZVNwZWN0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgIG51bWVyYXRvciArPSBNYXRoLnBvdyhrLCBpKSAqIE1hdGguYWJzKGFtcGxpdHVkZVNwZWN0W2tdKTtcbiAgICAgICAgZGVub21pbmF0b3IgKz0gYW1wbGl0dWRlU3BlY3Rba107XG4gICAgfVxuICAgIHJldHVybiBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbn1cblxuZnVuY3Rpb24gc3BlY3RyYWxDZW50cm9pZCAoX2EpIHtcbiAgICB2YXIgYW1wU3BlY3RydW0gPSBfYS5hbXBTcGVjdHJ1bTtcbiAgICBpZiAodHlwZW9mIGFtcFNwZWN0cnVtICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIG11KDEsIGFtcFNwZWN0cnVtKTtcbn1cblxuZnVuY3Rpb24gc3BlY3RyYWxSb2xsb2ZmIChfYSkge1xuICAgIHZhciBhbXBTcGVjdHJ1bSA9IF9hLmFtcFNwZWN0cnVtLCBzYW1wbGVSYXRlID0gX2Euc2FtcGxlUmF0ZTtcbiAgICBpZiAodHlwZW9mIGFtcFNwZWN0cnVtICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIGFtcHNwZWMgPSBhbXBTcGVjdHJ1bTtcbiAgICAvL2NhbGN1bGF0ZSBueXF1aXN0IGJpblxuICAgIHZhciBueXFCaW4gPSBzYW1wbGVSYXRlIC8gKDIgKiAoYW1wc3BlYy5sZW5ndGggLSAxKSk7XG4gICAgdmFyIGVjID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtcHNwZWMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWMgKz0gYW1wc3BlY1tpXTtcbiAgICB9XG4gICAgdmFyIHRocmVzaG9sZCA9IDAuOTkgKiBlYztcbiAgICB2YXIgbiA9IGFtcHNwZWMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoZWMgPiB0aHJlc2hvbGQgJiYgbiA+PSAwKSB7XG4gICAgICAgIGVjIC09IGFtcHNwZWNbbl07XG4gICAgICAgIC0tbjtcbiAgICB9XG4gICAgcmV0dXJuIChuICsgMSkgKiBueXFCaW47XG59XG5cbmZ1bmN0aW9uIHNwZWN0cmFsRmxhdG5lc3MgKF9hKSB7XG4gICAgdmFyIGFtcFNwZWN0cnVtID0gX2EuYW1wU3BlY3RydW07XG4gICAgaWYgKHR5cGVvZiBhbXBTcGVjdHJ1bSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIHZhciBudW1lcmF0b3IgPSAwO1xuICAgIHZhciBkZW5vbWluYXRvciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbXBTcGVjdHJ1bS5sZW5ndGg7IGkrKykge1xuICAgICAgICBudW1lcmF0b3IgKz0gTWF0aC5sb2coYW1wU3BlY3RydW1baV0pO1xuICAgICAgICBkZW5vbWluYXRvciArPSBhbXBTcGVjdHJ1bVtpXTtcbiAgICB9XG4gICAgcmV0dXJuICgoTWF0aC5leHAobnVtZXJhdG9yIC8gYW1wU3BlY3RydW0ubGVuZ3RoKSAqIGFtcFNwZWN0cnVtLmxlbmd0aCkgL1xuICAgICAgICBkZW5vbWluYXRvcik7XG59XG5cbmZ1bmN0aW9uIHNwZWN0cmFsU3ByZWFkIChfYSkge1xuICAgIHZhciBhbXBTcGVjdHJ1bSA9IF9hLmFtcFNwZWN0cnVtO1xuICAgIGlmICh0eXBlb2YgYW1wU3BlY3RydW0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KG11KDIsIGFtcFNwZWN0cnVtKSAtIE1hdGgucG93KG11KDEsIGFtcFNwZWN0cnVtKSwgMikpO1xufVxuXG5mdW5jdGlvbiBzcGVjdHJhbFNrZXduZXNzIChfYSkge1xuICAgIHZhciBhbXBTcGVjdHJ1bSA9IF9hLmFtcFNwZWN0cnVtO1xuICAgIGlmICh0eXBlb2YgYW1wU3BlY3RydW0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgbXUxID0gbXUoMSwgYW1wU3BlY3RydW0pO1xuICAgIHZhciBtdTIgPSBtdSgyLCBhbXBTcGVjdHJ1bSk7XG4gICAgdmFyIG11MyA9IG11KDMsIGFtcFNwZWN0cnVtKTtcbiAgICB2YXIgbnVtZXJhdG9yID0gMiAqIE1hdGgucG93KG11MSwgMykgLSAzICogbXUxICogbXUyICsgbXUzO1xuICAgIHZhciBkZW5vbWluYXRvciA9IE1hdGgucG93KE1hdGguc3FydChtdTIgLSBNYXRoLnBvdyhtdTEsIDIpKSwgMyk7XG4gICAgcmV0dXJuIG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xufVxuXG5mdW5jdGlvbiBzcGVjdHJhbEt1cnRvc2lzIChfYSkge1xuICAgIHZhciBhbXBTcGVjdHJ1bSA9IF9hLmFtcFNwZWN0cnVtO1xuICAgIGlmICh0eXBlb2YgYW1wU3BlY3RydW0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgYW1wc3BlYyA9IGFtcFNwZWN0cnVtO1xuICAgIHZhciBtdTEgPSBtdSgxLCBhbXBzcGVjKTtcbiAgICB2YXIgbXUyID0gbXUoMiwgYW1wc3BlYyk7XG4gICAgdmFyIG11MyA9IG11KDMsIGFtcHNwZWMpO1xuICAgIHZhciBtdTQgPSBtdSg0LCBhbXBzcGVjKTtcbiAgICB2YXIgbnVtZXJhdG9yID0gLTMgKiBNYXRoLnBvdyhtdTEsIDQpICsgNiAqIG11MSAqIG11MiAtIDQgKiBtdTEgKiBtdTMgKyBtdTQ7XG4gICAgdmFyIGRlbm9taW5hdG9yID0gTWF0aC5wb3coTWF0aC5zcXJ0KG11MiAtIE1hdGgucG93KG11MSwgMikpLCA0KTtcbiAgICByZXR1cm4gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG59XG5cbmZ1bmN0aW9uIHpjciAoX2EpIHtcbiAgICB2YXIgc2lnbmFsID0gX2Euc2lnbmFsO1xuICAgIGlmICh0eXBlb2Ygc2lnbmFsICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIHpjciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaWduYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKChzaWduYWxbaSAtIDFdID49IDAgJiYgc2lnbmFsW2ldIDwgMCkgfHxcbiAgICAgICAgICAgIChzaWduYWxbaSAtIDFdIDwgMCAmJiBzaWduYWxbaV0gPj0gMCkpIHtcbiAgICAgICAgICAgIHpjcisrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB6Y3I7XG59XG5cbmZ1bmN0aW9uIGxvdWRuZXNzIChfYSkge1xuICAgIHZhciBhbXBTcGVjdHJ1bSA9IF9hLmFtcFNwZWN0cnVtLCBiYXJrU2NhbGUgPSBfYS5iYXJrU2NhbGUsIF9iID0gX2EubnVtYmVyT2ZCYXJrQmFuZHMsIG51bWJlck9mQmFya0JhbmRzID0gX2IgPT09IHZvaWQgMCA/IDI0IDogX2I7XG4gICAgaWYgKHR5cGVvZiBhbXBTcGVjdHJ1bSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYmFya1NjYWxlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIE5VTV9CQVJLX0JBTkRTID0gbnVtYmVyT2ZCYXJrQmFuZHM7XG4gICAgdmFyIHNwZWNpZmljID0gbmV3IEZsb2F0MzJBcnJheShOVU1fQkFSS19CQU5EUyk7XG4gICAgdmFyIHRvdGFsID0gMDtcbiAgICB2YXIgbm9ybWFsaXNlZFNwZWN0cnVtID0gYW1wU3BlY3RydW07XG4gICAgdmFyIGJiTGltaXRzID0gbmV3IEludDMyQXJyYXkoTlVNX0JBUktfQkFORFMgKyAxKTtcbiAgICBiYkxpbWl0c1swXSA9IDA7XG4gICAgdmFyIGN1cnJlbnRCYW5kRW5kID0gYmFya1NjYWxlW25vcm1hbGlzZWRTcGVjdHJ1bS5sZW5ndGggLSAxXSAvIE5VTV9CQVJLX0JBTkRTO1xuICAgIHZhciBjdXJyZW50QmFuZCA9IDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3JtYWxpc2VkU3BlY3RydW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd2hpbGUgKGJhcmtTY2FsZVtpXSA+IGN1cnJlbnRCYW5kRW5kKSB7XG4gICAgICAgICAgICBiYkxpbWl0c1tjdXJyZW50QmFuZCsrXSA9IGk7XG4gICAgICAgICAgICBjdXJyZW50QmFuZEVuZCA9XG4gICAgICAgICAgICAgICAgKGN1cnJlbnRCYW5kICogYmFya1NjYWxlW25vcm1hbGlzZWRTcGVjdHJ1bS5sZW5ndGggLSAxXSkgL1xuICAgICAgICAgICAgICAgICAgICBOVU1fQkFSS19CQU5EUztcbiAgICAgICAgfVxuICAgIH1cbiAgICBiYkxpbWl0c1tOVU1fQkFSS19CQU5EU10gPSBub3JtYWxpc2VkU3BlY3RydW0ubGVuZ3RoIC0gMTtcbiAgICAvL3Byb2Nlc3NcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5VTV9CQVJLX0JBTkRTOyBpKyspIHtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSBiYkxpbWl0c1tpXTsgaiA8IGJiTGltaXRzW2kgKyAxXTsgaisrKSB7XG4gICAgICAgICAgICBzdW0gKz0gbm9ybWFsaXNlZFNwZWN0cnVtW2pdO1xuICAgICAgICB9XG4gICAgICAgIHNwZWNpZmljW2ldID0gTWF0aC5wb3coc3VtLCAwLjIzKTtcbiAgICB9XG4gICAgLy9nZXQgdG90YWwgbG91ZG5lc3NcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNpZmljLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRvdGFsICs9IHNwZWNpZmljW2ldO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzcGVjaWZpYzogc3BlY2lmaWMsXG4gICAgICAgIHRvdGFsOiB0b3RhbCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwZXJjZXB0dWFsU3ByZWFkIChfYSkge1xuICAgIHZhciBhbXBTcGVjdHJ1bSA9IF9hLmFtcFNwZWN0cnVtLCBiYXJrU2NhbGUgPSBfYS5iYXJrU2NhbGU7XG4gICAgdmFyIGxvdWRuZXNzVmFsdWUgPSBsb3VkbmVzcyh7IGFtcFNwZWN0cnVtOiBhbXBTcGVjdHJ1bSwgYmFya1NjYWxlOiBiYXJrU2NhbGUgfSk7XG4gICAgdmFyIG1heCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb3VkbmVzc1ZhbHVlLnNwZWNpZmljLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsb3VkbmVzc1ZhbHVlLnNwZWNpZmljW2ldID4gbWF4KSB7XG4gICAgICAgICAgICBtYXggPSBsb3VkbmVzc1ZhbHVlLnNwZWNpZmljW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzcHJlYWQgPSBNYXRoLnBvdygobG91ZG5lc3NWYWx1ZS50b3RhbCAtIG1heCkgLyBsb3VkbmVzc1ZhbHVlLnRvdGFsLCAyKTtcbiAgICByZXR1cm4gc3ByZWFkO1xufVxuXG5mdW5jdGlvbiBwZXJjZXB0dWFsU2hhcnBuZXNzIChfYSkge1xuICAgIHZhciBhbXBTcGVjdHJ1bSA9IF9hLmFtcFNwZWN0cnVtLCBiYXJrU2NhbGUgPSBfYS5iYXJrU2NhbGU7XG4gICAgdmFyIGxvdWRuZXNzVmFsdWUgPSBsb3VkbmVzcyh7IGFtcFNwZWN0cnVtOiBhbXBTcGVjdHJ1bSwgYmFya1NjYWxlOiBiYXJrU2NhbGUgfSk7XG4gICAgdmFyIHNwZWMgPSBsb3VkbmVzc1ZhbHVlLnNwZWNpZmljO1xuICAgIHZhciBvdXRwdXQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA8IDE1KSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gKGkgKyAxKSAqIHNwZWNbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ICs9IDAuMDY2ICogTWF0aC5leHAoMC4xNzEgKiAoaSArIDEpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvdXRwdXQgKj0gMC4xMSAvIGxvdWRuZXNzVmFsdWUudG90YWw7XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFBvd2VyU3BlY3RydW0gKF9hKSB7XG4gICAgdmFyIGFtcFNwZWN0cnVtID0gX2EuYW1wU3BlY3RydW07XG4gICAgaWYgKHR5cGVvZiBhbXBTcGVjdHJ1bSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIHZhciBwb3dlclNwZWN0cnVtID0gbmV3IEZsb2F0MzJBcnJheShhbXBTcGVjdHJ1bS5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG93ZXJTcGVjdHJ1bS5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb3dlclNwZWN0cnVtW2ldID0gTWF0aC5wb3coYW1wU3BlY3RydW1baV0sIDIpO1xuICAgIH1cbiAgICByZXR1cm4gcG93ZXJTcGVjdHJ1bTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdE1lbEJhbmRzIChfYSkge1xuICAgIHZhciBhbXBTcGVjdHJ1bSA9IF9hLmFtcFNwZWN0cnVtLCBtZWxGaWx0ZXJCYW5rID0gX2EubWVsRmlsdGVyQmFuaywgYnVmZmVyU2l6ZSA9IF9hLmJ1ZmZlclNpemU7XG4gICAgaWYgKHR5cGVvZiBhbXBTcGVjdHJ1bSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVmFsaWQgYW1wU3BlY3RydW0gaXMgcmVxdWlyZWQgdG8gZ2VuZXJhdGUgbWVsQmFuZHNcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWVsRmlsdGVyQmFuayAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVmFsaWQgbWVsRmlsdGVyQmFuayBpcyByZXF1aXJlZCB0byBnZW5lcmF0ZSBtZWxCYW5kc1wiKTtcbiAgICB9XG4gICAgdmFyIHBvd1NwZWMgPSBleHRyYWN0UG93ZXJTcGVjdHJ1bSh7IGFtcFNwZWN0cnVtOiBhbXBTcGVjdHJ1bSB9KTtcbiAgICB2YXIgbnVtRmlsdGVycyA9IG1lbEZpbHRlckJhbmsubGVuZ3RoO1xuICAgIHZhciBmaWx0ZXJlZCA9IEFycmF5KG51bUZpbHRlcnMpO1xuICAgIHZhciBsb2dnZWRNZWxCYW5kcyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtRmlsdGVycyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dnZWRNZWxCYW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmaWx0ZXJlZFtpXSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyU2l6ZSAvIDIpO1xuICAgICAgICBsb2dnZWRNZWxCYW5kc1tpXSA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYnVmZmVyU2l6ZSAvIDI7IGorKykge1xuICAgICAgICAgICAgLy9wb2ludC13aXNlIG11bHRpcGxpY2F0aW9uIGJldHdlZW4gcG93ZXIgc3BlY3RydW0gYW5kIGZpbHRlcmJhbmtzLlxuICAgICAgICAgICAgZmlsdGVyZWRbaV1bal0gPSBtZWxGaWx0ZXJCYW5rW2ldW2pdICogcG93U3BlY1tqXTtcbiAgICAgICAgICAgIC8vc3VtbWluZyB1cCBhbGwgb2YgdGhlIGNvZWZmaWNpZW50cyBpbnRvIG9uZSBhcnJheVxuICAgICAgICAgICAgbG9nZ2VkTWVsQmFuZHNbaV0gKz0gZmlsdGVyZWRbaV1bal07XG4gICAgICAgIH1cbiAgICAgICAgLy9sb2cgZWFjaCBjb2VmZmljaWVudC5cbiAgICAgICAgbG9nZ2VkTWVsQmFuZHNbaV0gPSBNYXRoLmxvZyhsb2dnZWRNZWxCYW5kc1tpXSArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobG9nZ2VkTWVsQmFuZHMpO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSpcXFxuICogRGlzY3JldGUgQ29zaW5lIFRyYW5zZm9ybVxuICpcbiAqIChjKSBWYWlsIFN5c3RlbXMuIEpvc2h1YSBKdW5nIGFuZCBCZW4gQnJ5YW4uIDIwMTVcbiAqXG4gKiBUaGlzIGNvZGUgaXMgbm90IGRlc2lnbmVkIHRvIGJlIGhpZ2hseSBvcHRpbWl6ZWQgYnV0IGFzIGFuIGVkdWNhdGlvbmFsXG4gKiB0b29sIHRvIHVuZGVyc3RhbmQgdGhlIE1lbC1zY2FsZSBhbmQgaXRzIHJlbGF0ZWQgY29lZmZpY2llbnRzIHVzZWQgaW5cbiAqIGh1bWFuIHNwZWVjaCBhbmFseXNpcy5cblxcKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbnZhciBjb3NNYXAgPSBudWxsO1xuXG4vLyBCdWlsZHMgYSBjb3NpbmUgbWFwIGZvciB0aGUgZ2l2ZW4gaW5wdXQgc2l6ZS4gVGhpcyBhbGxvd3MgbXVsdGlwbGUgaW5wdXQgc2l6ZXMgdG8gYmUgbWVtb2l6ZWQgYXV0b21hZ2ljYWxseVxuLy8gaWYgeW91IHdhbnQgdG8gcnVuIHRoZSBEQ1Qgb3ZlciBhbmQgb3Zlci5cbnZhciBtZW1vaXplQ29zaW5lcyA9IGZ1bmN0aW9uKE4pIHtcbiAgY29zTWFwID0gY29zTWFwIHx8IHt9O1xuICBjb3NNYXBbTl0gPSBuZXcgQXJyYXkoTipOKTtcblxuICB2YXIgUElfTiA9IE1hdGguUEkgLyBOO1xuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgTjsgaysrKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBOOyBuKyspIHtcbiAgICAgIGNvc01hcFtOXVtuICsgKGsgKiBOKV0gPSBNYXRoLmNvcyhQSV9OICogKG4gKyAwLjUpICogayk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBkY3QkMihzaWduYWwsIHNjYWxlKSB7XG4gIHZhciBMID0gc2lnbmFsLmxlbmd0aDtcbiAgc2NhbGUgPSBzY2FsZSB8fCAyO1xuXG4gIGlmICghY29zTWFwIHx8ICFjb3NNYXBbTF0pIG1lbW9pemVDb3NpbmVzKEwpO1xuXG4gIHZhciBjb2VmZmljaWVudHMgPSBzaWduYWwubWFwKGZ1bmN0aW9uICgpIHtyZXR1cm4gMDt9KTtcblxuICByZXR1cm4gY29lZmZpY2llbnRzLm1hcChmdW5jdGlvbiAoX18sIGl4KSB7XG4gICAgcmV0dXJuIHNjYWxlICogc2lnbmFsLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyLCBpeF8sIGFycikge1xuICAgICAgcmV0dXJuIHByZXYgKyAoY3VyICogY29zTWFwW0xdW2l4XyArIChpeCAqIEwpXSk7XG4gICAgfSwgMCk7XG4gIH0pO1xufVxudmFyIGRjdF8xID0gZGN0JDI7XG5cbnZhciBkY3QgPSBkY3RfMTtcblxudmFyIGRjdCQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGRjdCk7XG5cbmZ1bmN0aW9uIG1mY2MgKF9hKSB7XG4gICAgLy8gVHV0b3JpYWwgZnJvbTpcbiAgICAvLyBodHRwOi8vcHJhY3RpY2FsY3J5cHRvZ3JhcGh5LmNvbS9taXNjZWxsYW5lb3VzL21hY2hpbmUtbGVhcm5pbmdcbiAgICAvLyAvZ3VpZGUtbWVsLWZyZXF1ZW5jeS1jZXBzdHJhbC1jb2VmZmljaWVudHMtbWZjY3MvXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBhbXBTcGVjdHJ1bSA9IF9hLmFtcFNwZWN0cnVtLCBtZWxGaWx0ZXJCYW5rID0gX2EubWVsRmlsdGVyQmFuaywgbnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzID0gX2EubnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzLCBidWZmZXJTaXplID0gX2EuYnVmZmVyU2l6ZTtcbiAgICB2YXIgX251bWJlck9mTUZDQ0NvZWZmaWNpZW50cyA9IE1hdGgubWluKDQwLCBNYXRoLm1heCgxLCBudW1iZXJPZk1GQ0NDb2VmZmljaWVudHMgfHwgMTMpKTtcbiAgICB2YXIgbnVtRmlsdGVycyA9IG1lbEZpbHRlckJhbmsubGVuZ3RoO1xuICAgIGlmIChudW1GaWx0ZXJzIDwgX251bWJlck9mTUZDQ0NvZWZmaWNpZW50cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnN1ZmZpY2llbnQgZmlsdGVyIGJhbmsgZm9yIHJlcXVlc3RlZCBudW1iZXIgb2YgY29lZmZpY2llbnRzXCIpO1xuICAgIH1cbiAgICB2YXIgbG9nZ2VkTWVsQmFuZHNBcnJheSA9IGV4dHJhY3RNZWxCYW5kcyh7XG4gICAgICAgIGFtcFNwZWN0cnVtOiBhbXBTcGVjdHJ1bSxcbiAgICAgICAgbWVsRmlsdGVyQmFuazogbWVsRmlsdGVyQmFuayxcbiAgICAgICAgYnVmZmVyU2l6ZTogYnVmZmVyU2l6ZSxcbiAgICB9KTtcbiAgICB2YXIgbWZjY3MgPSBkY3QkMShsb2dnZWRNZWxCYW5kc0FycmF5KS5zbGljZSgwLCBfbnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzKTtcbiAgICByZXR1cm4gbWZjY3M7XG59XG5cbmZ1bmN0aW9uIGNocm9tYSAoX2EpIHtcbiAgICB2YXIgYW1wU3BlY3RydW0gPSBfYS5hbXBTcGVjdHJ1bSwgY2hyb21hRmlsdGVyQmFuayA9IF9hLmNocm9tYUZpbHRlckJhbms7XG4gICAgaWYgKHR5cGVvZiBhbXBTcGVjdHJ1bSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVmFsaWQgYW1wU3BlY3RydW0gaXMgcmVxdWlyZWQgdG8gZ2VuZXJhdGUgY2hyb21hXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNocm9tYUZpbHRlckJhbmsgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbGlkIGNocm9tYUZpbHRlckJhbmsgaXMgcmVxdWlyZWQgdG8gZ2VuZXJhdGUgY2hyb21hXCIpO1xuICAgIH1cbiAgICB2YXIgY2hyb21hZ3JhbSA9IGNocm9tYUZpbHRlckJhbmsubWFwKGZ1bmN0aW9uIChyb3csIGkpIHtcbiAgICAgICAgcmV0dXJuIGFtcFNwZWN0cnVtLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2LCBqKSB7IHJldHVybiBhY2MgKyB2ICogcm93W2pdOyB9LCAwKTtcbiAgICB9KTtcbiAgICB2YXIgbWF4VmFsID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgY2hyb21hZ3JhbSk7XG4gICAgcmV0dXJuIG1heFZhbCA/IGNocm9tYWdyYW0ubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2IC8gbWF4VmFsOyB9KSA6IGNocm9tYWdyYW07XG59XG5cbi8vIFRoaXMgZmlsZSBpc24ndCBiZWluZyB0eXBlY2hlY2tlZCBhdCBhbGwgYmVjYXVzZSB0aGVyZSBhcmUgbWFqb3IgaXNzdWVzIHdpdGggaXQuXG4vLyBTZWUgIzg1MiBmb3IgZGV0YWlscy4gT25jZSB0aGF0J3MgbWVyZ2VkLCB0aGlzIGZpbGUgc2hvdWxkIGJlIHR5cGVjaGVja2VkLlxuLy8gQHRzLW5vY2hlY2tcbmZ1bmN0aW9uIHNwZWN0cmFsRmx1eCAoX2EpIHtcbiAgICB2YXIgc2lnbmFsID0gX2Euc2lnbmFsLCBwcmV2aW91c1NpZ25hbCA9IF9hLnByZXZpb3VzU2lnbmFsLCBidWZmZXJTaXplID0gX2EuYnVmZmVyU2l6ZTtcbiAgICBpZiAodHlwZW9mIHNpZ25hbCAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcHJldmlvdXNTaWduYWwgIT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIHZhciBzZiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IC0oYnVmZmVyU2l6ZSAvIDIpOyBpIDwgc2lnbmFsLmxlbmd0aCAvIDIgLSAxOyBpKyspIHtcbiAgICAgICAgeCA9IE1hdGguYWJzKHNpZ25hbFtpXSkgLSBNYXRoLmFicyhwcmV2aW91c1NpZ25hbFtpXSk7XG4gICAgICAgIHNmICs9ICh4ICsgTWF0aC5hYnMoeCkpIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIHNmO1xufVxuXG5mdW5jdGlvbiBzcGVjdHJhbENyZXN0IChfYSkge1xuICAgIHZhciBhbXBTcGVjdHJ1bSA9IF9hLmFtcFNwZWN0cnVtO1xuICAgIGlmICh0eXBlb2YgYW1wU3BlY3RydW0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgcm1zID0gMDtcbiAgICB2YXIgcGVhayA9IC1JbmZpbml0eTtcbiAgICBhbXBTcGVjdHJ1bS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJtcyArPSBNYXRoLnBvdyh4LCAyKTtcbiAgICAgICAgcGVhayA9IHggPiBwZWFrID8geCA6IHBlYWs7XG4gICAgfSk7XG4gICAgcm1zID0gcm1zIC8gYW1wU3BlY3RydW0ubGVuZ3RoO1xuICAgIHJtcyA9IE1hdGguc3FydChybXMpO1xuICAgIHJldHVybiBwZWFrIC8gcm1zO1xufVxuXG52YXIgYnVmZmVyID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5zaWduYWw7XG59O1xudmFyIGNvbXBsZXhTcGVjdHJ1bSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MuY29tcGxleFNwZWN0cnVtO1xufTtcbnZhciBhbXBsaXR1ZGVTcGVjdHJ1bSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MuYW1wU3BlY3RydW07XG59O1xuXG52YXIgZXh0cmFjdG9ycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYW1wbGl0dWRlU3BlY3RydW06IGFtcGxpdHVkZVNwZWN0cnVtLFxuICAgIGJ1ZmZlcjogYnVmZmVyLFxuICAgIGNocm9tYTogY2hyb21hLFxuICAgIGNvbXBsZXhTcGVjdHJ1bTogY29tcGxleFNwZWN0cnVtLFxuICAgIGVuZXJneTogZW5lcmd5LFxuICAgIGxvdWRuZXNzOiBsb3VkbmVzcyxcbiAgICBtZWxCYW5kczogZXh0cmFjdE1lbEJhbmRzLFxuICAgIG1mY2M6IG1mY2MsXG4gICAgcGVyY2VwdHVhbFNoYXJwbmVzczogcGVyY2VwdHVhbFNoYXJwbmVzcyxcbiAgICBwZXJjZXB0dWFsU3ByZWFkOiBwZXJjZXB0dWFsU3ByZWFkLFxuICAgIHBvd2VyU3BlY3RydW06IGV4dHJhY3RQb3dlclNwZWN0cnVtLFxuICAgIHJtczogcm1zLFxuICAgIHNwZWN0cmFsQ2VudHJvaWQ6IHNwZWN0cmFsQ2VudHJvaWQsXG4gICAgc3BlY3RyYWxDcmVzdDogc3BlY3RyYWxDcmVzdCxcbiAgICBzcGVjdHJhbEZsYXRuZXNzOiBzcGVjdHJhbEZsYXRuZXNzLFxuICAgIHNwZWN0cmFsRmx1eDogc3BlY3RyYWxGbHV4LFxuICAgIHNwZWN0cmFsS3VydG9zaXM6IHNwZWN0cmFsS3VydG9zaXMsXG4gICAgc3BlY3RyYWxSb2xsb2ZmOiBzcGVjdHJhbFJvbGxvZmYsXG4gICAgc3BlY3RyYWxTa2V3bmVzczogc3BlY3RyYWxTa2V3bmVzcyxcbiAgICBzcGVjdHJhbFNsb3BlOiBzcGVjdHJhbFNsb3BlLFxuICAgIHNwZWN0cmFsU3ByZWFkOiBzcGVjdHJhbFNwcmVhZCxcbiAgICB6Y3I6IHpjclxufSk7XG5cbi8vIG1lbW9pemF0aW9uIG9mIHRoZSByZXZlcnNhbCBvZiBkaWZmZXJlbnQgbGVuZ3Rocy5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBtZW1vaXplZFJldmVyc2FsID0ge307XG52YXIgbWVtb2l6ZWRaZXJvQnVmZmVycyA9IHt9O1xuXG52YXIgY29uc3RydWN0Q29tcGxleEFycmF5ID0gZnVuY3Rpb24gY29uc3RydWN0Q29tcGxleEFycmF5KHNpZ25hbCkge1xuICB2YXIgY29tcGxleFNpZ25hbCA9IHt9O1xuXG4gIGNvbXBsZXhTaWduYWwucmVhbCA9IHNpZ25hbC5yZWFsID09PSB1bmRlZmluZWQgPyBzaWduYWwuc2xpY2UoKSA6IHNpZ25hbC5yZWFsLnNsaWNlKCk7XG5cbiAgdmFyIGJ1ZmZlclNpemUgPSBjb21wbGV4U2lnbmFsLnJlYWwubGVuZ3RoO1xuXG4gIGlmIChtZW1vaXplZFplcm9CdWZmZXJzW2J1ZmZlclNpemVdID09PSB1bmRlZmluZWQpIHtcbiAgICBtZW1vaXplZFplcm9CdWZmZXJzW2J1ZmZlclNpemVdID0gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoYnVmZmVyU2l6ZSkpLm1hcChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YsIDApO1xuICB9XG5cbiAgY29tcGxleFNpZ25hbC5pbWFnID0gbWVtb2l6ZWRaZXJvQnVmZmVyc1tidWZmZXJTaXplXS5zbGljZSgpO1xuXG4gIHJldHVybiBjb21wbGV4U2lnbmFsO1xufTtcblxudmFyIGJpdFJldmVyc2VBcnJheSA9IGZ1bmN0aW9uIGJpdFJldmVyc2VBcnJheShOKSB7XG4gIGlmIChtZW1vaXplZFJldmVyc2FsW05dID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbWF4QmluYXJ5TGVuZ3RoID0gKE4gLSAxKS50b1N0cmluZygyKS5sZW5ndGg7IC8vZ2V0IHRoZSBiaW5hcnkgbGVuZ3RoIG9mIHRoZSBsYXJnZXN0IGluZGV4LlxuICAgIHZhciB0ZW1wbGF0ZUJpbmFyeSA9ICcwJy5yZXBlYXQobWF4QmluYXJ5TGVuZ3RoKTsgLy9jcmVhdGUgYSB0ZW1wbGF0ZSBiaW5hcnkgb2YgdGhhdCBsZW5ndGguXG4gICAgdmFyIHJldmVyc2VkID0ge307XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBOOyBuKyspIHtcbiAgICAgIHZhciBjdXJyQmluYXJ5ID0gbi50b1N0cmluZygyKTsgLy9nZXQgYmluYXJ5IHZhbHVlIG9mIGN1cnJlbnQgaW5kZXguXG5cbiAgICAgIC8vcHJlcGVuZCB6ZXJvcyBmcm9tIHRlbXBsYXRlIHRvIGN1cnJlbnQgYmluYXJ5LiBUaGlzIG1ha2VzIGJpbmFyeSB2YWx1ZXMgb2YgYWxsIGluZGljZXMgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gICAgICBjdXJyQmluYXJ5ID0gdGVtcGxhdGVCaW5hcnkuc3Vic3RyKGN1cnJCaW5hcnkubGVuZ3RoKSArIGN1cnJCaW5hcnk7XG5cbiAgICAgIGN1cnJCaW5hcnkgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGN1cnJCaW5hcnkpKS5yZXZlcnNlKCkuam9pbignJyk7IC8vcmV2ZXJzZVxuICAgICAgcmV2ZXJzZWRbbl0gPSBwYXJzZUludChjdXJyQmluYXJ5LCAyKTsgLy9jb252ZXJ0IHRvIGRlY2ltYWxcbiAgICB9XG4gICAgbWVtb2l6ZWRSZXZlcnNhbFtOXSA9IHJldmVyc2VkOyAvL3NhdmVcbiAgfVxuICByZXR1cm4gbWVtb2l6ZWRSZXZlcnNhbFtOXTtcbn07XG5cbi8vIGNvbXBsZXggbXVsdGlwbGljYXRpb25cbnZhciBtdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KGEsIGIpIHtcbiAgcmV0dXJuIHtcbiAgICAncmVhbCc6IGEucmVhbCAqIGIucmVhbCAtIGEuaW1hZyAqIGIuaW1hZyxcbiAgICAnaW1hZyc6IGEucmVhbCAqIGIuaW1hZyArIGEuaW1hZyAqIGIucmVhbFxuICB9O1xufTtcblxuLy8gY29tcGxleCBhZGRpdGlvblxudmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gIHJldHVybiB7XG4gICAgJ3JlYWwnOiBhLnJlYWwgKyBiLnJlYWwsXG4gICAgJ2ltYWcnOiBhLmltYWcgKyBiLmltYWdcbiAgfTtcbn07XG5cbi8vIGNvbXBsZXggc3VidHJhY3Rpb25cbnZhciBzdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIpIHtcbiAgcmV0dXJuIHtcbiAgICAncmVhbCc6IGEucmVhbCAtIGIucmVhbCxcbiAgICAnaW1hZyc6IGEuaW1hZyAtIGIuaW1hZ1xuICB9O1xufTtcblxuLy8gZXVsZXIncyBpZGVudGl0eSBlXnggPSBjb3MoeCkgKyBzaW4oeClcbnZhciBldWxlciA9IGZ1bmN0aW9uIGV1bGVyKGtuLCBOKSB7XG4gIHZhciB4ID0gLTIgKiBNYXRoLlBJICoga24gLyBOO1xuICByZXR1cm4geyAncmVhbCc6IE1hdGguY29zKHgpLCAnaW1hZyc6IE1hdGguc2luKHgpIH07XG59O1xuXG4vLyBjb21wbGV4IGNvbmp1Z2F0ZVxudmFyIGNvbmogPSBmdW5jdGlvbiBjb25qKGEpIHtcbiAgYS5pbWFnICo9IC0xO1xuICByZXR1cm4gYTtcbn07XG5cbnZhciB1dGlscyQxID0ge1xuICBiaXRSZXZlcnNlQXJyYXk6IGJpdFJldmVyc2VBcnJheSxcbiAgbXVsdGlwbHk6IG11bHRpcGx5LFxuICBhZGQ6IGFkZCxcbiAgc3VidHJhY3Q6IHN1YnRyYWN0LFxuICBldWxlcjogZXVsZXIsXG4gIGNvbmo6IGNvbmosXG4gIGNvbnN0cnVjdENvbXBsZXhBcnJheTogY29uc3RydWN0Q29tcGxleEFycmF5XG59O1xuXG52YXIgdXRpbHMgPSB1dGlscyQxO1xuXG4vLyByZWFsIHRvIGNvbXBsZXggZmZ0XG52YXIgZmZ0ID0gZnVuY3Rpb24gZmZ0KHNpZ25hbCkge1xuXG4gIHZhciBjb21wbGV4U2lnbmFsID0ge307XG5cbiAgaWYgKHNpZ25hbC5yZWFsID09PSB1bmRlZmluZWQgfHwgc2lnbmFsLmltYWcgPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBsZXhTaWduYWwgPSB1dGlscy5jb25zdHJ1Y3RDb21wbGV4QXJyYXkoc2lnbmFsKTtcbiAgfSBlbHNlIHtcbiAgICBjb21wbGV4U2lnbmFsLnJlYWwgPSBzaWduYWwucmVhbC5zbGljZSgpO1xuICAgIGNvbXBsZXhTaWduYWwuaW1hZyA9IHNpZ25hbC5pbWFnLnNsaWNlKCk7XG4gIH1cblxuICB2YXIgTiA9IGNvbXBsZXhTaWduYWwucmVhbC5sZW5ndGg7XG4gIHZhciBsb2dOID0gTWF0aC5sb2cyKE4pO1xuXG4gIGlmIChNYXRoLnJvdW5kKGxvZ04pICE9IGxvZ04pIHRocm93IG5ldyBFcnJvcignSW5wdXQgc2l6ZSBtdXN0IGJlIGEgcG93ZXIgb2YgMi4nKTtcblxuICBpZiAoY29tcGxleFNpZ25hbC5yZWFsLmxlbmd0aCAhPSBjb21wbGV4U2lnbmFsLmltYWcubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWFsIGFuZCBpbWFnaW5hcnkgY29tcG9uZW50cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoLicpO1xuICB9XG5cbiAgdmFyIGJpdFJldmVyc2VkSW5kaWNlcyA9IHV0aWxzLmJpdFJldmVyc2VBcnJheShOKTtcblxuICAvLyBzb3J0IGFycmF5XG4gIHZhciBvcmRlcmVkID0ge1xuICAgICdyZWFsJzogW10sXG4gICAgJ2ltYWcnOiBbXVxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgb3JkZXJlZC5yZWFsW2JpdFJldmVyc2VkSW5kaWNlc1tpXV0gPSBjb21wbGV4U2lnbmFsLnJlYWxbaV07XG4gICAgb3JkZXJlZC5pbWFnW2JpdFJldmVyc2VkSW5kaWNlc1tpXV0gPSBjb21wbGV4U2lnbmFsLmltYWdbaV07XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgTjsgX2krKykge1xuICAgIGNvbXBsZXhTaWduYWwucmVhbFtfaV0gPSBvcmRlcmVkLnJlYWxbX2ldO1xuICAgIGNvbXBsZXhTaWduYWwuaW1hZ1tfaV0gPSBvcmRlcmVkLmltYWdbX2ldO1xuICB9XG4gIC8vIGl0ZXJhdGUgb3ZlciB0aGUgbnVtYmVyIG9mIHN0YWdlc1xuICBmb3IgKHZhciBuID0gMTsgbiA8PSBsb2dOOyBuKyspIHtcbiAgICB2YXIgY3Vyck4gPSBNYXRoLnBvdygyLCBuKTtcblxuICAgIC8vIGZpbmQgdHdpZGRsZSBmYWN0b3JzXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBjdXJyTiAvIDI7IGsrKykge1xuICAgICAgdmFyIHR3aWRkbGUgPSB1dGlscy5ldWxlcihrLCBjdXJyTik7XG5cbiAgICAgIC8vIG9uIGVhY2ggYmxvY2sgb2YgRlQsIGltcGxlbWVudCB0aGUgYnV0dGVyZmx5IGRpYWdyYW1cbiAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgTiAvIGN1cnJOOyBtKyspIHtcbiAgICAgICAgdmFyIGN1cnJFdmVuSW5kZXggPSBjdXJyTiAqIG0gKyBrO1xuICAgICAgICB2YXIgY3Vyck9kZEluZGV4ID0gY3Vyck4gKiBtICsgayArIGN1cnJOIC8gMjtcblxuICAgICAgICB2YXIgY3VyckV2ZW5JbmRleFNhbXBsZSA9IHtcbiAgICAgICAgICAncmVhbCc6IGNvbXBsZXhTaWduYWwucmVhbFtjdXJyRXZlbkluZGV4XSxcbiAgICAgICAgICAnaW1hZyc6IGNvbXBsZXhTaWduYWwuaW1hZ1tjdXJyRXZlbkluZGV4XVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY3Vyck9kZEluZGV4U2FtcGxlID0ge1xuICAgICAgICAgICdyZWFsJzogY29tcGxleFNpZ25hbC5yZWFsW2N1cnJPZGRJbmRleF0sXG4gICAgICAgICAgJ2ltYWcnOiBjb21wbGV4U2lnbmFsLmltYWdbY3Vyck9kZEluZGV4XVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvZGQgPSB1dGlscy5tdWx0aXBseSh0d2lkZGxlLCBjdXJyT2RkSW5kZXhTYW1wbGUpO1xuXG4gICAgICAgIHZhciBzdWJ0cmFjdGlvblJlc3VsdCA9IHV0aWxzLnN1YnRyYWN0KGN1cnJFdmVuSW5kZXhTYW1wbGUsIG9kZCk7XG4gICAgICAgIGNvbXBsZXhTaWduYWwucmVhbFtjdXJyT2RkSW5kZXhdID0gc3VidHJhY3Rpb25SZXN1bHQucmVhbDtcbiAgICAgICAgY29tcGxleFNpZ25hbC5pbWFnW2N1cnJPZGRJbmRleF0gPSBzdWJ0cmFjdGlvblJlc3VsdC5pbWFnO1xuXG4gICAgICAgIHZhciBhZGRpdGlvblJlc3VsdCA9IHV0aWxzLmFkZChvZGQsIGN1cnJFdmVuSW5kZXhTYW1wbGUpO1xuICAgICAgICBjb21wbGV4U2lnbmFsLnJlYWxbY3VyckV2ZW5JbmRleF0gPSBhZGRpdGlvblJlc3VsdC5yZWFsO1xuICAgICAgICBjb21wbGV4U2lnbmFsLmltYWdbY3VyckV2ZW5JbmRleF0gPSBhZGRpdGlvblJlc3VsdC5pbWFnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb21wbGV4U2lnbmFsO1xufTtcblxuLy8gY29tcGxleCB0byByZWFsIGlmZnRcbnZhciBpZmZ0ID0gZnVuY3Rpb24gaWZmdChzaWduYWwpIHtcblxuICBpZiAoc2lnbmFsLnJlYWwgPT09IHVuZGVmaW5lZCB8fCBzaWduYWwuaW1hZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSUZGVCBvbmx5IGFjY2VwdHMgYSBjb21wbGV4IGlucHV0LlwiKTtcbiAgfVxuXG4gIHZhciBOID0gc2lnbmFsLnJlYWwubGVuZ3RoO1xuXG4gIHZhciBjb21wbGV4U2lnbmFsID0ge1xuICAgICdyZWFsJzogW10sXG4gICAgJ2ltYWcnOiBbXVxuICB9O1xuXG4gIC8vdGFrZSBjb21wbGV4IGNvbmp1Z2F0ZSBpbiBvcmRlciB0byBiZSBhYmxlIHRvIHVzZSB0aGUgcmVndWxhciBGRlQgZm9yIElGRlRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICB2YXIgY3VycmVudFNhbXBsZSA9IHtcbiAgICAgICdyZWFsJzogc2lnbmFsLnJlYWxbaV0sXG4gICAgICAnaW1hZyc6IHNpZ25hbC5pbWFnW2ldXG4gICAgfTtcblxuICAgIHZhciBjb25qdWdhdGVTYW1wbGUgPSB1dGlscy5jb25qKGN1cnJlbnRTYW1wbGUpO1xuICAgIGNvbXBsZXhTaWduYWwucmVhbFtpXSA9IGNvbmp1Z2F0ZVNhbXBsZS5yZWFsO1xuICAgIGNvbXBsZXhTaWduYWwuaW1hZ1tpXSA9IGNvbmp1Z2F0ZVNhbXBsZS5pbWFnO1xuICB9XG5cbiAgLy9jb21wdXRlXG4gIHZhciBYID0gZmZ0KGNvbXBsZXhTaWduYWwpO1xuXG4gIC8vbm9ybWFsaXplXG4gIGNvbXBsZXhTaWduYWwucmVhbCA9IFgucmVhbC5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgLyBOO1xuICB9KTtcblxuICBjb21wbGV4U2lnbmFsLmltYWcgPSBYLmltYWcubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsIC8gTjtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbXBsZXhTaWduYWw7XG59O1xuXG52YXIgZmZ0XzEgPSB7XG4gIGZmdDogZmZ0LFxuICBpZmZ0OiBpZmZ0XG59O1xuXG4vKipcbiAqIE1leWRhJ3MgaW50ZXJmYWNlIHRvIHRoZSBXZWIgQXVkaW8gQVBJLiBNZXlkYUFuYWx5emVyIGFic3RyYWN0cyBhbiBBUEkgb25cbiAqIHRvcCBvZiB0aGUgV2ViIEF1ZGlvIEFQSSdzIFNjcmlwdFByb2Nlc3Nvck5vZGUsIHJ1bm5pbmcgdGhlIE1leWRhIGF1ZGlvXG4gKiBmZWF0dXJlIGV4dHJhY3RvcnMgaW5zaWRlIHRoYXQgY29udGV4dC5cbiAqXG4gKiBNZXlkYUFuYWx5emVyJ3MgY29uc3RydWN0b3Igc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkgLSBNZXlkYUFuYWx5emVyXG4gKiBvYmplY3RzIHNob3VsZCBiZSBnZW5lcmF0ZWQgdXNpbmcgdGhlIHtAbGluayBjcmVhdGVNZXlkYUFuYWx5emVyfVxuICogZmFjdG9yeSBmdW5jdGlvbiBpbiB0aGUgbWFpbiBNZXlkYSBjbGFzcy5cbiAqXG4gKiBPcHRpb25zIGFyZSBvZiB0eXBlIHtAbGluayBNZXlkYUFuYWx5emVyT3B0aW9uc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGFuYWx5emVyID0gTWV5ZGEuY3JlYXRlTWV5ZGFBbmFseXplcih7XG4gKiAgIFwiYXVkaW9Db250ZXh0XCI6IGF1ZGlvQ29udGV4dCxcbiAqICAgXCJzb3VyY2VcIjogc291cmNlLFxuICogICBcImJ1ZmZlclNpemVcIjogNTEyLFxuICogICBcImZlYXR1cmVFeHRyYWN0b3JzXCI6IFtcInJtc1wiXSxcbiAqICAgXCJpbnB1dHNcIjogMixcbiAqICAgXCJudW1iZXJPZk1GQ0NDb2VmZmljaWVudHNcIjogMjBcbiAqICAgXCJjYWxsYmFja1wiOiBmZWF0dXJlcyA9PiB7XG4gKiAgICAgbGV2ZWxSYW5nZUVsZW1lbnQudmFsdWUgPSBmZWF0dXJlcy5ybXM7XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKi9cbnZhciBNZXlkYUFuYWx5emVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgZnVuY3Rpb24gTWV5ZGFBbmFseXplcihvcHRpb25zLCBfdGhpcykge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIHRoaXMuX20gPSBfdGhpcztcbiAgICAgICAgaWYgKCFvcHRpb25zLmF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fbS5lcnJvcnMubm9BQztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmJ1ZmZlclNpemUgJiZcbiAgICAgICAgICAgICFpc1Bvd2VyT2ZUd28ob3B0aW9ucy5idWZmZXJTaXplKSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fbS5fZXJyb3JzLm5vdFBvdzI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW9wdGlvbnMuc291cmNlKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9tLl9lcnJvcnMubm9Tb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbS5hdWRpb0NvbnRleHQgPSBvcHRpb25zLmF1ZGlvQ29udGV4dDtcbiAgICAgICAgLy8gVE9ETzogdmFsaWRhdGUgb3B0aW9uc1xuICAgICAgICB0aGlzLl9tLmJ1ZmZlclNpemUgPSBvcHRpb25zLmJ1ZmZlclNpemUgfHwgdGhpcy5fbS5idWZmZXJTaXplIHx8IDI1NjtcbiAgICAgICAgdGhpcy5fbS5ob3BTaXplID0gb3B0aW9ucy5ob3BTaXplIHx8IHRoaXMuX20uaG9wU2l6ZSB8fCB0aGlzLl9tLmJ1ZmZlclNpemU7XG4gICAgICAgIHRoaXMuX20uc2FtcGxlUmF0ZSA9XG4gICAgICAgICAgICBvcHRpb25zLnNhbXBsZVJhdGUgfHwgdGhpcy5fbS5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSB8fCA0NDEwMDtcbiAgICAgICAgdGhpcy5fbS5jYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuX20ud2luZG93aW5nRnVuY3Rpb24gPSBvcHRpb25zLndpbmRvd2luZ0Z1bmN0aW9uIHx8IFwiaGFubmluZ1wiO1xuICAgICAgICB0aGlzLl9tLmZlYXR1cmVFeHRyYWN0b3JzID0gZXh0cmFjdG9ycztcbiAgICAgICAgdGhpcy5fbS5FWFRSQUNUSU9OX1NUQVJURUQgPSBvcHRpb25zLnN0YXJ0SW1tZWRpYXRlbHkgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuX20uY2hhbm5lbCA9IHR5cGVvZiBvcHRpb25zLmNoYW5uZWwgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLmNoYW5uZWwgOiAwO1xuICAgICAgICB0aGlzLl9tLmlucHV0cyA9IG9wdGlvbnMuaW5wdXRzIHx8IDE7XG4gICAgICAgIHRoaXMuX20ub3V0cHV0cyA9IG9wdGlvbnMub3V0cHV0cyB8fCAxO1xuICAgICAgICB0aGlzLl9tLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyA9XG4gICAgICAgICAgICBvcHRpb25zLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX20ubnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzIHx8XG4gICAgICAgICAgICAgICAgMTM7XG4gICAgICAgIHRoaXMuX20ubnVtYmVyT2ZCYXJrQmFuZHMgPVxuICAgICAgICAgICAgb3B0aW9ucy5udW1iZXJPZkJhcmtCYW5kcyB8fCB0aGlzLl9tLm51bWJlck9mQmFya0JhbmRzIHx8IDI0O1xuICAgICAgICAvL2NyZWF0ZSBub2Rlc1xuICAgICAgICB0aGlzLl9tLnNwbiA9IHRoaXMuX20uYXVkaW9Db250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3Nvcih0aGlzLl9tLmJ1ZmZlclNpemUsIHRoaXMuX20uaW5wdXRzLCB0aGlzLl9tLm91dHB1dHMpO1xuICAgICAgICB0aGlzLl9tLnNwbi5jb25uZWN0KHRoaXMuX20uYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5fbS5fZmVhdHVyZXNUb0V4dHJhY3QgPSBvcHRpb25zLmZlYXR1cmVFeHRyYWN0b3JzIHx8IFtdO1xuICAgICAgICAvL2Fsd2F5cyByZWNhbGN1bGF0ZSBCUyBhbmQgTUZCIHdoZW4gYSBuZXcgTWV5ZGEgYW5hbHl6ZXIgaXMgY3JlYXRlZC5cbiAgICAgICAgdGhpcy5fbS5iYXJrU2NhbGUgPSBjcmVhdGVCYXJrU2NhbGUodGhpcy5fbS5idWZmZXJTaXplLCB0aGlzLl9tLnNhbXBsZVJhdGUsIHRoaXMuX20uYnVmZmVyU2l6ZSk7XG4gICAgICAgIHRoaXMuX20ubWVsRmlsdGVyQmFuayA9IGNyZWF0ZU1lbEZpbHRlckJhbmsoTWF0aC5tYXgodGhpcy5fbS5tZWxCYW5kcywgdGhpcy5fbS5udW1iZXJPZk1GQ0NDb2VmZmljaWVudHMpLCB0aGlzLl9tLnNhbXBsZVJhdGUsIHRoaXMuX20uYnVmZmVyU2l6ZSk7XG4gICAgICAgIHRoaXMuX20uaW5wdXREYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbS5wcmV2aW91c0lucHV0RGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX20uZnJhbWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9tLnByZXZpb3VzRnJhbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnNldFNvdXJjZShvcHRpb25zLnNvdXJjZSk7XG4gICAgICAgIHRoaXMuX20uc3BuLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgICAgICBpZiAoX3RoaXNfMS5fbS5pbnB1dERhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpc18xLl9tLnByZXZpb3VzSW5wdXREYXRhID0gX3RoaXNfMS5fbS5pbnB1dERhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpc18xLl9tLmlucHV0RGF0YSA9IGUuaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoX3RoaXNfMS5fbS5jaGFubmVsKTtcbiAgICAgICAgICAgIGlmICghX3RoaXNfMS5fbS5wcmV2aW91c0lucHV0RGF0YSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IF90aGlzXzEuX20uaW5wdXREYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShfdGhpc18xLl9tLnByZXZpb3VzSW5wdXREYXRhLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgIF90aGlzXzEuX20uaW5wdXREYXRhLmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICAgIF90aGlzXzEuX20uaG9wU2l6ZSk7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnNldChfdGhpc18xLl9tLnByZXZpb3VzSW5wdXREYXRhLnNsaWNlKF90aGlzXzEuX20uaG9wU2l6ZSkpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXQoX3RoaXNfMS5fbS5pbnB1dERhdGEsIF90aGlzXzEuX20ucHJldmlvdXNJbnB1dERhdGEubGVuZ3RoIC0gX3RoaXNfMS5fbS5ob3BTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmcmFtZXMgPSBmcmFtZShidWZmZXIsIF90aGlzXzEuX20uYnVmZmVyU2l6ZSwgX3RoaXNfMS5fbS5ob3BTaXplKTtcbiAgICAgICAgICAgIGZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgX3RoaXNfMS5fbS5mcmFtZSA9IGY7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gX3RoaXNfMS5fbS5leHRyYWN0KF90aGlzXzEuX20uX2ZlYXR1cmVzVG9FeHRyYWN0LCBfdGhpc18xLl9tLmZyYW1lLCBfdGhpc18xLl9tLnByZXZpb3VzRnJhbWUpO1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgY2FsbGJhY2sgaWYgYXBwbGljYWJsZVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXNfMS5fbS5jYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzXzEuX20uRVhUUkFDVElPTl9TVEFSVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzXzEuX20uY2FsbGJhY2soZmVhdHVyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpc18xLl9tLnByZXZpb3VzRnJhbWUgPSBfdGhpc18xLl9tLmZyYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGZlYXR1cmUgZXh0cmFjdGlvblxuICAgICAqIFRoZSBhdWRpbyBmZWF0dXJlcyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3YXMgZGVmaW5lZFxuICAgICAqIGluIHRoZSBNZXlkYU9wdGlvbnMgdGhhdCB3ZXJlIHBhc3NlZCB0byB0aGUgZmFjdG9yeSB3aGVuIGNvbnN0cnVjdGluZyB0aGVcbiAgICAgKiBNZXlkYUFuYWx5emVyLlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xBcnJheS48c3RyaW5nPil9IFtmZWF0dXJlc11cbiAgICAgKiBDaGFuZ2UgdGhlIGZlYXR1cmVzIHRoYXQgTWV5ZGEgaXMgZXh0cmFjdGluZy4gRGVmYXVsdHMgdG8gdGhlIGZlYXR1cmVzIHRoYXRcbiAgICAgKiB3ZXJlIHNldCB1cG9uIGNvbnN0cnVjdGlvbiBpbiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogYW5hbHl6ZXIuc3RhcnQoJ2Nocm9tYScpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIE1leWRhQW5hbHl6ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgICAgIHRoaXMuX20uX2ZlYXR1cmVzVG9FeHRyYWN0ID0gZmVhdHVyZXMgfHwgdGhpcy5fbS5fZmVhdHVyZXNUb0V4dHJhY3Q7XG4gICAgICAgIHRoaXMuX20uRVhUUkFDVElPTl9TVEFSVEVEID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3AgZmVhdHVyZSBleHRyYWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGFuYWx5emVyLnN0b3AoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBNZXlkYUFuYWx5emVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tLkVYVFJBQ1RJT05fU1RBUlRFRCA9IGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBBdWRpbyBOb2RlIGZvciBNZXlkYSB0byBsaXN0ZW4gdG8uXG4gICAgICogQHBhcmFtIHtBdWRpb05vZGV9IHNvdXJjZSAtIFRoZSBBdWRpbyBOb2RlIGZvciBNZXlkYSB0byBsaXN0ZW4gdG9cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBhbmFseXplci5zZXRTb3VyY2UoYXVkaW9Tb3VyY2VOb2RlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBNZXlkYUFuYWx5emVyLnByb3RvdHlwZS5zZXRTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHRoaXMuX20uc291cmNlICYmIHRoaXMuX20uc291cmNlLmRpc2Nvbm5lY3QodGhpcy5fbS5zcG4pO1xuICAgICAgICB0aGlzLl9tLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5fbS5zb3VyY2UuY29ubmVjdCh0aGlzLl9tLnNwbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNoYW5uZWwgb2YgdGhlIGF1ZGlvIG5vZGUgZm9yIE1leWRhIHRvIGxpc3RlbiB0b1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFubmVsIC0gdGhlIGluZGV4IG9mIHRoZSBjaGFubmVsIG9uIHRoZSBpbnB1dCBhdWRpbyBub2RlXG4gICAgICogZm9yIE1leWRhIHRvIGxpc3RlbiB0by5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBhbmFseXplci5zZXRDaGFubmVsKDApO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIE1leWRhQW5hbHl6ZXIucHJvdG90eXBlLnNldENoYW5uZWwgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICBpZiAoY2hhbm5lbCA8PSB0aGlzLl9tLmlucHV0cykge1xuICAgICAgICAgICAgdGhpcy5fbS5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDaGFubmVsIFwiLmNvbmNhdChjaGFubmVsLCBcIiBkb2VzIG5vdCBleGlzdC4gTWFrZSBzdXJlIHlvdSd2ZSBwcm92aWRlZCBhIHZhbHVlIGZvciAnaW5wdXRzJyB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBcIikuY29uY2F0KGNoYW5uZWwsIFwiIHdoZW4gaW5zdGFudGlhdGluZyB0aGUgTWV5ZGFBbmFseXplclwiKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBhIHNldCBvZiBmZWF0dXJlcyBmcm9tIHRoZSBjdXJyZW50IGZyYW1lLlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xBcnJheS48c3RyaW5nPil9IFtmZWF0dXJlc11cbiAgICAgKiBDaGFuZ2UgdGhlIGZlYXR1cmVzIHRoYXQgTWV5ZGEgaXMgZXh0cmFjdGluZ1xuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGFuYWx5emVyLmdldCgnc3BlY3RyYWxGbGF0bmVzcycpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIE1leWRhQW5hbHl6ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChmZWF0dXJlcykge1xuICAgICAgICBpZiAodGhpcy5fbS5pbnB1dERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tLmV4dHJhY3QoZmVhdHVyZXMgfHwgdGhpcy5fbS5fZmVhdHVyZXNUb0V4dHJhY3QsIHRoaXMuX20uaW5wdXREYXRhLCB0aGlzLl9tLnByZXZpb3VzSW5wdXREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWV5ZGFBbmFseXplcjtcbn0oKSk7XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBkZWZhdWx0IGV4cG9ydCBmb3IgTWV5ZGEsIHlvdSBwcm9iYWJseSB3YW50IHRvIGNoZWNrXG4gKiBvdXQge0BsaW5rIGRlZmF1bHR9XG4gKlxuICogQG1vZHVsZSBNZXlkYVxuICovXG52YXIgTWV5ZGEgPSB7XG4gICAgYXVkaW9Db250ZXh0OiBudWxsLFxuICAgIHNwbjogbnVsbCxcbiAgICBidWZmZXJTaXplOiA1MTIsXG4gICAgc2FtcGxlUmF0ZTogNDQxMDAsXG4gICAgbWVsQmFuZHM6IDI2LFxuICAgIGNocm9tYUJhbmRzOiAxMixcbiAgICBjYWxsYmFjazogbnVsbCxcbiAgICB3aW5kb3dpbmdGdW5jdGlvbjogXCJoYW5uaW5nXCIsXG4gICAgZmVhdHVyZUV4dHJhY3RvcnM6IGV4dHJhY3RvcnMsXG4gICAgRVhUUkFDVElPTl9TVEFSVEVEOiBmYWxzZSxcbiAgICBudW1iZXJPZk1GQ0NDb2VmZmljaWVudHM6IDEzLFxuICAgIG51bWJlck9mQmFya0JhbmRzOiAyNCxcbiAgICBfZmVhdHVyZXNUb0V4dHJhY3Q6IFtdLFxuICAgIHdpbmRvd2luZzogYXBwbHlXaW5kb3csXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBfZXJyb3JzOiB7XG4gICAgICAgIG5vdFBvdzI6IG5ldyBFcnJvcihcIk1leWRhOiBCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgcG93ZXIgb2YgMiwgZS5nLiA2NCBvciA1MTJcIiksXG4gICAgICAgIGZlYXR1cmVVbmRlZjogbmV3IEVycm9yKFwiTWV5ZGE6IE5vIGZlYXR1cmVzIGRlZmluZWQuXCIpLFxuICAgICAgICBpbnZhbGlkRmVhdHVyZUZtdDogbmV3IEVycm9yKFwiTWV5ZGE6IEludmFsaWQgZmVhdHVyZSBmb3JtYXRcIiksXG4gICAgICAgIGludmFsaWRJbnB1dDogbmV3IEVycm9yKFwiTWV5ZGE6IEludmFsaWQgaW5wdXQuXCIpLFxuICAgICAgICBub0FDOiBuZXcgRXJyb3IoXCJNZXlkYTogTm8gQXVkaW9Db250ZXh0IHNwZWNpZmllZC5cIiksXG4gICAgICAgIG5vU291cmNlOiBuZXcgRXJyb3IoXCJNZXlkYTogTm8gc291cmNlIG5vZGUgc3BlY2lmaWVkLlwiKSxcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5XG4gICAgICogQ3JlYXRlIGEgTWV5ZGFBbmFseXplclxuICAgICAqXG4gICAgICogQSBmYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIE1leWRhQW5hbHl6ZXIsIHRoZSBpbnRlcmZhY2UgZm9yIHVzaW5nXG4gICAgICogTWV5ZGEgaW4gdGhlIGNvbnRleHQgb2YgV2ViIEF1ZGlvLlxuICAgICAqXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGNvbnN0IGFuYWx5emVyID0gTWV5ZGEuY3JlYXRlTWV5ZGFBbmFseXplcih7XG4gICAgICogICBcImF1ZGlvQ29udGV4dFwiOiBhdWRpb0NvbnRleHQsXG4gICAgICogICBcInNvdXJjZVwiOiBzb3VyY2UsXG4gICAgICogICBcImJ1ZmZlclNpemVcIjogNTEyLFxuICAgICAqICAgXCJmZWF0dXJlRXh0cmFjdG9yc1wiOiBbXCJybXNcIl0sXG4gICAgICogICBcImlucHV0c1wiOiAyLFxuICAgICAqICAgXCJjYWxsYmFja1wiOiBmZWF0dXJlcyA9PiB7XG4gICAgICogICAgIGxldmVsUmFuZ2VFbGVtZW50LnZhbHVlID0gZmVhdHVyZXMucm1zO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNyZWF0ZU1leWRhQW5hbHl6ZXI6IGNyZWF0ZU1leWRhQW5hbHl6ZXIsXG4gICAgLyoqXG4gICAgICogTGlzdCBhdmFpbGFibGUgYXVkaW8gZmVhdHVyZSBleHRyYWN0b3JzLiBSZXR1cm4gZm9ybWF0IHByb3ZpZGVzIHRoZSBrZXkgdG9cbiAgICAgKiBiZSB1c2VkIGluIHNlbGVjdGluZyB0aGUgZXh0cmFjdG9yIGluIHRoZSBleHRyYWN0IG1ldGhvZHNcbiAgICAgKi9cbiAgICBsaXN0QXZhaWxhYmxlRmVhdHVyZUV4dHJhY3RvcnM6IGxpc3RBdmFpbGFibGVGZWF0dXJlRXh0cmFjdG9ycyxcbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IGFuIGF1ZGlvIGZlYXR1cmUgZnJvbSBhIGJ1ZmZlclxuICAgICAqXG4gICAgICogVW5sZXNzIGBtZXlkYS53aW5kb3dpbmdGdW5jdGlvbmAgaXMgc2V0IG90aGVyd2lzZSwgYGV4dHJhY3RgIHdpbGxcbiAgICAgKiBpbnRlcm5hbGx5IGFwcGx5IGEgaGFubmluZyB3aW5kb3cgdG8gdGhlIGJ1ZmZlciBwcmlvciB0byBjb252ZXJzaW9uIGludG9cbiAgICAgKiB0aGUgZnJlcXVlbmN5IGRvbWFpbi5cbiAgICAgKlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBtZXlkYS5idWZmZXJTaXplID0gMjA0ODtcbiAgICAgKiBjb25zdCBmZWF0dXJlcyA9IG1leWRhLmV4dHJhY3QoWyd6Y3InLCAnc3BlY3RyYWxDZW50cm9pZCddLCBzaWduYWwpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGV4dHJhY3Q6IGZ1bmN0aW9uIChmZWF0dXJlLCBzaWduYWwsIHByZXZpb3VzU2lnbmFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghc2lnbmFsKVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5fZXJyb3JzLmludmFsaWRJbnB1dDtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNpZ25hbCAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5fZXJyb3JzLmludmFsaWRJbnB1dDtcbiAgICAgICAgZWxzZSBpZiAoIWZlYXR1cmUpXG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9lcnJvcnMuZmVhdHVyZVVuZGVmO1xuICAgICAgICBlbHNlIGlmICghaXNQb3dlck9mVHdvKHNpZ25hbC5sZW5ndGgpKVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5fZXJyb3JzLm5vdFBvdzI7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5iYXJrU2NhbGUgPT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICAgICAgICAgdGhpcy5iYXJrU2NhbGUubGVuZ3RoICE9IHRoaXMuYnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5iYXJrU2NhbGUgPSBjcmVhdGVCYXJrU2NhbGUodGhpcy5idWZmZXJTaXplLCB0aGlzLnNhbXBsZVJhdGUsIHRoaXMuYnVmZmVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjYWxjdWxhdGUgbWVsIGJhbmsgaWYgYnVmZmVyIGxlbmd0aCBjaGFuZ2VkXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tZWxGaWx0ZXJCYW5rID09IFwidW5kZWZpbmVkXCIgfHxcbiAgICAgICAgICAgIHRoaXMuYmFya1NjYWxlLmxlbmd0aCAhPSB0aGlzLmJ1ZmZlclNpemUgfHxcbiAgICAgICAgICAgIHRoaXMubWVsRmlsdGVyQmFuay5sZW5ndGggIT0gdGhpcy5tZWxCYW5kcykge1xuICAgICAgICAgICAgdGhpcy5tZWxGaWx0ZXJCYW5rID0gY3JlYXRlTWVsRmlsdGVyQmFuayhNYXRoLm1heCh0aGlzLm1lbEJhbmRzLCB0aGlzLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyksIHRoaXMuc2FtcGxlUmF0ZSwgdGhpcy5idWZmZXJTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWNhbGN1bGF0ZSBjaHJvbWEgYmFuayBpZiBidWZmZXIgbGVuZ3RoIGNoYW5nZWRcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNocm9tYUZpbHRlckJhbmsgPT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICAgICAgICAgdGhpcy5jaHJvbWFGaWx0ZXJCYW5rLmxlbmd0aCAhPSB0aGlzLmNocm9tYUJhbmRzKSB7XG4gICAgICAgICAgICB0aGlzLmNocm9tYUZpbHRlckJhbmsgPSBjcmVhdGVDaHJvbWFGaWx0ZXJCYW5rKHRoaXMuY2hyb21hQmFuZHMsIHRoaXMuc2FtcGxlUmF0ZSwgdGhpcy5idWZmZXJTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJidWZmZXJcIiBpbiBzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5idWZmZXIgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy9zaWduYWwgaXMgYSBub3JtYWwgYXJyYXksIGNvbnZlcnQgdG8gRjMyQVxuICAgICAgICAgICAgdGhpcy5zaWduYWwgPSBhcnJheVRvVHlwZWQoc2lnbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsID0gc2lnbmFsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmVwYXJlZFNpZ25hbCA9IHByZXBhcmVTaWduYWxXaXRoU3BlY3RydW0oc2lnbmFsLCB0aGlzLndpbmRvd2luZ0Z1bmN0aW9uLCB0aGlzLmJ1ZmZlclNpemUpO1xuICAgICAgICB0aGlzLnNpZ25hbCA9IHByZXBhcmVkU2lnbmFsLndpbmRvd2VkU2lnbmFsO1xuICAgICAgICB0aGlzLmNvbXBsZXhTcGVjdHJ1bSA9IHByZXBhcmVkU2lnbmFsLmNvbXBsZXhTcGVjdHJ1bTtcbiAgICAgICAgdGhpcy5hbXBTcGVjdHJ1bSA9IHByZXBhcmVkU2lnbmFsLmFtcFNwZWN0cnVtO1xuICAgICAgICBpZiAocHJldmlvdXNTaWduYWwpIHtcbiAgICAgICAgICAgIHZhciBwcmVwYXJlZFNpZ25hbF8xID0gcHJlcGFyZVNpZ25hbFdpdGhTcGVjdHJ1bShwcmV2aW91c1NpZ25hbCwgdGhpcy53aW5kb3dpbmdGdW5jdGlvbiwgdGhpcy5idWZmZXJTaXplKTtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNTaWduYWwgPSBwcmVwYXJlZFNpZ25hbF8xLndpbmRvd2VkU2lnbmFsO1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0NvbXBsZXhTcGVjdHJ1bSA9IHByZXBhcmVkU2lnbmFsXzEuY29tcGxleFNwZWN0cnVtO1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0FtcFNwZWN0cnVtID0gcHJlcGFyZWRTaWduYWxfMS5hbXBTcGVjdHJ1bTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXh0cmFjdCA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZmVhdHVyZUV4dHJhY3RvcnNbZmVhdHVyZV0oe1xuICAgICAgICAgICAgICAgIGFtcFNwZWN0cnVtOiBfdGhpcy5hbXBTcGVjdHJ1bSxcbiAgICAgICAgICAgICAgICBjaHJvbWFGaWx0ZXJCYW5rOiBfdGhpcy5jaHJvbWFGaWx0ZXJCYW5rLFxuICAgICAgICAgICAgICAgIGNvbXBsZXhTcGVjdHJ1bTogX3RoaXMuY29tcGxleFNwZWN0cnVtLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogX3RoaXMuc2lnbmFsLFxuICAgICAgICAgICAgICAgIGJ1ZmZlclNpemU6IF90aGlzLmJ1ZmZlclNpemUsXG4gICAgICAgICAgICAgICAgc2FtcGxlUmF0ZTogX3RoaXMuc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgICAgICBiYXJrU2NhbGU6IF90aGlzLmJhcmtTY2FsZSxcbiAgICAgICAgICAgICAgICBtZWxGaWx0ZXJCYW5rOiBfdGhpcy5tZWxGaWx0ZXJCYW5rLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzU2lnbmFsOiBfdGhpcy5wcmV2aW91c1NpZ25hbCxcbiAgICAgICAgICAgICAgICBwcmV2aW91c0FtcFNwZWN0cnVtOiBfdGhpcy5wcmV2aW91c0FtcFNwZWN0cnVtLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzQ29tcGxleFNwZWN0cnVtOiBfdGhpcy5wcmV2aW91c0NvbXBsZXhTcGVjdHJ1bSxcbiAgICAgICAgICAgICAgICBudW1iZXJPZk1GQ0NDb2VmZmljaWVudHM6IF90aGlzLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyxcbiAgICAgICAgICAgICAgICBudW1iZXJPZkJhcmtCYW5kczogX3RoaXMubnVtYmVyT2ZCYXJrQmFuZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBmZWF0dXJlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmVhdHVyZS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGFjYywgKF9hID0ge30sXG4gICAgICAgICAgICAgICAgICAgIF9hW2VsXSA9IGV4dHJhY3QoZWwpLFxuICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmZWF0dXJlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0cmFjdChmZWF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2Vycm9ycy5pbnZhbGlkRmVhdHVyZUZtdDtcbiAgICAgICAgfVxuICAgIH0sXG59O1xudmFyIHByZXBhcmVTaWduYWxXaXRoU3BlY3RydW0gPSBmdW5jdGlvbiAoc2lnbmFsLCB3aW5kb3dpbmdGdW5jdGlvbiwgYnVmZmVyU2l6ZSkge1xuICAgIHZhciBwcmVwYXJlZFNpZ25hbCA9IHt9O1xuICAgIGlmICh0eXBlb2Ygc2lnbmFsLmJ1ZmZlciA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vc2lnbmFsIGlzIGEgbm9ybWFsIGFycmF5LCBjb252ZXJ0IHRvIEYzMkFcbiAgICAgICAgcHJlcGFyZWRTaWduYWwuc2lnbmFsID0gYXJyYXlUb1R5cGVkKHNpZ25hbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcmVwYXJlZFNpZ25hbC5zaWduYWwgPSBzaWduYWw7XG4gICAgfVxuICAgIHByZXBhcmVkU2lnbmFsLndpbmRvd2VkU2lnbmFsID0gYXBwbHlXaW5kb3cocHJlcGFyZWRTaWduYWwuc2lnbmFsLCB3aW5kb3dpbmdGdW5jdGlvbik7XG4gICAgcHJlcGFyZWRTaWduYWwuY29tcGxleFNwZWN0cnVtID0gZmZ0XzEuZmZ0KHByZXBhcmVkU2lnbmFsLndpbmRvd2VkU2lnbmFsKTtcbiAgICBwcmVwYXJlZFNpZ25hbC5hbXBTcGVjdHJ1bSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyU2l6ZSAvIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyU2l6ZSAvIDI7IGkrKykge1xuICAgICAgICBwcmVwYXJlZFNpZ25hbC5hbXBTcGVjdHJ1bVtpXSA9IE1hdGguc3FydChNYXRoLnBvdyhwcmVwYXJlZFNpZ25hbC5jb21wbGV4U3BlY3RydW0ucmVhbFtpXSwgMikgK1xuICAgICAgICAgICAgTWF0aC5wb3cocHJlcGFyZWRTaWduYWwuY29tcGxleFNwZWN0cnVtLmltYWdbaV0sIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXBhcmVkU2lnbmFsO1xufTtcbi8qKlxuICogTGlzdCBhdmFpbGFibGUgYXVkaW8gZmVhdHVyZSBleHRyYWN0b3JzLiBSZXR1cm4gZm9ybWF0IHByb3ZpZGVzIHRoZSBrZXkgdG9cbiAqIGJlIHVzZWQgaW4gc2VsZWN0aW5nIHRoZSBleHRyYWN0b3IgaW4gdGhlIGV4dHJhY3QgbWV0aG9kc1xuICovXG5mdW5jdGlvbiBsaXN0QXZhaWxhYmxlRmVhdHVyZUV4dHJhY3RvcnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZmVhdHVyZUV4dHJhY3RvcnMpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBNZXlkYUFuYWx5emVyXG4gKlxuICogQSBmYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIE1leWRhQW5hbHl6ZXIsIHRoZSBpbnRlcmZhY2UgZm9yIHVzaW5nXG4gKiBNZXlkYSBpbiB0aGUgY29udGV4dCBvZiBXZWIgQXVkaW8uXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgYW5hbHl6ZXIgPSBNZXlkYS5jcmVhdGVNZXlkYUFuYWx5emVyKHtcbiAqICAgXCJhdWRpb0NvbnRleHRcIjogYXVkaW9Db250ZXh0LFxuICogICBcInNvdXJjZVwiOiBzb3VyY2UsXG4gKiAgIFwiYnVmZmVyU2l6ZVwiOiA1MTIsXG4gKiAgIFwiZmVhdHVyZUV4dHJhY3RvcnNcIjogW1wicm1zXCJdLFxuICogICBcImlucHV0c1wiOiAyLFxuICogICBcImNhbGxiYWNrXCI6IGZlYXR1cmVzID0+IHtcbiAqICAgICBsZXZlbFJhbmdlRWxlbWVudC52YWx1ZSA9IGZlYXR1cmVzLnJtcztcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWV5ZGFBbmFseXplcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBNZXlkYUFuYWx5emVyKG9wdGlvbnMsIE9iamVjdC5hc3NpZ24oe30sIE1leWRhKSk7XG59XG4vLyBAdHMtaWdub3JlXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICB3aW5kb3cuTWV5ZGEgPSBNZXlkYTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXlkYTtcbiJdLCJuYW1lcyI6WyJfX3NwcmVhZEFycmF5IiwidG8iLCJmcm9tIiwicGFjayIsImFyZ3VtZW50cyIsImxlbmd0aCIsImkiLCJsIiwiYXIiLCJBcnJheSIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsImNvbmNhdCIsImJsYWNrbWFuIiwic2l6ZSIsImJsYWNrbWFuQnVmZmVyIiwiRmxvYXQzMkFycmF5IiwiY29lZmYxIiwiTWF0aCIsIlBJIiwiY29lZmYyIiwiY29zIiwiY2VpbCIsInNpbmUiLCJjb2VmZiIsInNpbmVCdWZmZXIiLCJzaW4iLCJoYW5uaW5nIiwiaGFubmluZ0J1ZmZlciIsImhhbW1pbmciLCJoYW1taW5nQnVmZmVyIiwid2luZG93aW5nIiwiT2JqZWN0IiwiZnJlZXplIiwiX19wcm90b19fIiwid2luZG93cyIsImlzUG93ZXJPZlR3byIsIm51bSIsInBvaW50d2lzZUJ1ZmZlck11bHQiLCJhIiwiYiIsImMiLCJtaW4iLCJhcHBseVdpbmRvdyIsInNpZ25hbCIsIndpbmRvd25hbWUiLCJlIiwiRXJyb3IiLCJjcmVhdGVCYXJrU2NhbGUiLCJzYW1wbGVSYXRlIiwiYnVmZmVyU2l6ZSIsImJhcmtTY2FsZSIsImF0YW4iLCJwb3ciLCJhcnJheVRvVHlwZWQiLCJ0IiwiX21lbFRvRnJlcSIsIm1lbFZhbHVlIiwiZnJlcVZhbHVlIiwiZXhwIiwiX2ZyZXFUb01lbCIsImxvZyIsImNyZWF0ZU1lbEZpbHRlckJhbmsiLCJudW1GaWx0ZXJzIiwibWVsVmFsdWVzIiwibWVsVmFsdWVzSW5GcmVxIiwibG93ZXJMaW1pdEZyZXEiLCJ1cHBlckxpbWl0RnJlcSIsImxvd2VyTGltaXRNZWwiLCJ1cHBlckxpbWl0TWVsIiwicmFuZ2UiLCJ2YWx1ZVRvQWRkIiwiZmZ0Qmluc09mRnJlcSIsImZsb29yIiwiZmlsdGVyQmFuayIsImoiLCJmaWxsIiwiaHpUb09jdGF2ZXMiLCJmcmVxIiwiQTQ0MCIsImxvZzIiLCJub3JtYWxpemVCeUNvbHVtbiIsImVtcHR5Um93IiwibWFwIiwiY29sRGVub21pbmF0b3JzIiwicmVkdWNlIiwiYWNjIiwicm93IiwiZm9yRWFjaCIsImNlbGwiLCJzcXJ0IiwidiIsImNyZWF0ZUNocm9tYUZpbHRlckJhbmsiLCJjZW50ZXJPY3RhdmUiLCJvY3RhdmVXaWR0aCIsImJhc2VDIiwibnVtT3V0cHV0QmlucyIsImZyZXF1ZW5jeUJpbnMiLCJfIiwiYmluV2lkdGhCaW5zIiwibWF4IiwiaGFsZk51bUZpbHRlcnMiLCJyb3VuZCIsImZpbHRlclBlYWtzIiwiZnJxIiwid2VpZ2h0cyIsIm9jdGF2ZVdlaWdodHMiLCJmcmFtZSIsImJ1ZmZlciIsImZyYW1lTGVuZ3RoIiwiaG9wTGVuZ3RoIiwibnVtRnJhbWVzIiwicm1zIiwiX2EiLCJUeXBlRXJyb3IiLCJlbmVyZ3kiLCJhYnMiLCJzcGVjdHJhbFNsb3BlIiwiYW1wU3BlY3RydW0iLCJhbXBTdW0iLCJmcmVxU3VtIiwiZnJlcXMiLCJwb3dGcmVxU3VtIiwiYW1wRnJlcVN1bSIsImN1ckZyZXEiLCJtdSIsImFtcGxpdHVkZVNwZWN0IiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJrIiwic3BlY3RyYWxDZW50cm9pZCIsInNwZWN0cmFsUm9sbG9mZiIsImFtcHNwZWMiLCJueXFCaW4iLCJlYyIsInRocmVzaG9sZCIsIm4iLCJzcGVjdHJhbEZsYXRuZXNzIiwic3BlY3RyYWxTcHJlYWQiLCJzcGVjdHJhbFNrZXduZXNzIiwibXUxIiwibXUyIiwibXUzIiwic3BlY3RyYWxLdXJ0b3NpcyIsIm11NCIsInpjciIsImxvdWRuZXNzIiwiX2IiLCJudW1iZXJPZkJhcmtCYW5kcyIsIk5VTV9CQVJLX0JBTkRTIiwic3BlY2lmaWMiLCJ0b3RhbCIsIm5vcm1hbGlzZWRTcGVjdHJ1bSIsImJiTGltaXRzIiwiSW50MzJBcnJheSIsImN1cnJlbnRCYW5kRW5kIiwiY3VycmVudEJhbmQiLCJzdW0iLCJwZXJjZXB0dWFsU3ByZWFkIiwibG91ZG5lc3NWYWx1ZSIsInNwcmVhZCIsInBlcmNlcHR1YWxTaGFycG5lc3MiLCJzcGVjIiwib3V0cHV0IiwiZXh0cmFjdFBvd2VyU3BlY3RydW0iLCJwb3dlclNwZWN0cnVtIiwiZXh0cmFjdE1lbEJhbmRzIiwibWVsRmlsdGVyQmFuayIsInBvd1NwZWMiLCJmaWx0ZXJlZCIsImxvZ2dlZE1lbEJhbmRzIiwiZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMiLCJ4IiwiX19lc01vZHVsZSIsImhhc093blByb3BlcnR5IiwiY29zTWFwIiwibWVtb2l6ZUNvc2luZXMiLCJOIiwiUElfTiIsImRjdCQyIiwic2NhbGUiLCJMIiwiY29lZmZpY2llbnRzIiwiX18iLCJpeCIsInByZXYiLCJjdXIiLCJpeF8iLCJhcnIiLCJkY3RfMSIsImRjdCIsImRjdCQxIiwibWZjYyIsIm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyIsIl9udW1iZXJPZk1GQ0NDb2VmZmljaWVudHMiLCJsb2dnZWRNZWxCYW5kc0FycmF5IiwibWZjY3MiLCJjaHJvbWEiLCJjaHJvbWFGaWx0ZXJCYW5rIiwiY2hyb21hZ3JhbSIsIm1heFZhbCIsImFwcGx5Iiwic3BlY3RyYWxGbHV4IiwicHJldmlvdXNTaWduYWwiLCJzZiIsInNwZWN0cmFsQ3Jlc3QiLCJwZWFrIiwiSW5maW5pdHkiLCJhcmdzIiwiY29tcGxleFNwZWN0cnVtIiwiYW1wbGl0dWRlU3BlY3RydW0iLCJleHRyYWN0b3JzIiwibWVsQmFuZHMiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJpc0FycmF5IiwiYXJyMiIsIm1lbW9pemVkUmV2ZXJzYWwiLCJtZW1vaXplZFplcm9CdWZmZXJzIiwiY29uc3RydWN0Q29tcGxleEFycmF5IiwiY29tcGxleFNpZ25hbCIsInJlYWwiLCJ1bmRlZmluZWQiLCJOdW1iZXIiLCJ2YWx1ZU9mIiwiaW1hZyIsImJpdFJldmVyc2VBcnJheSIsIm1heEJpbmFyeUxlbmd0aCIsInRvU3RyaW5nIiwidGVtcGxhdGVCaW5hcnkiLCJyZXBlYXQiLCJyZXZlcnNlZCIsImN1cnJCaW5hcnkiLCJzdWJzdHIiLCJyZXZlcnNlIiwiam9pbiIsInBhcnNlSW50IiwibXVsdGlwbHkiLCJhZGQiLCJzdWJ0cmFjdCIsImV1bGVyIiwia24iLCJjb25qIiwidXRpbHMkMSIsInV0aWxzIiwiZmZ0IiwibG9nTiIsImJpdFJldmVyc2VkSW5kaWNlcyIsIm9yZGVyZWQiLCJfaSIsImN1cnJOIiwidHdpZGRsZSIsIm0iLCJjdXJyRXZlbkluZGV4IiwiY3Vyck9kZEluZGV4IiwiY3VyckV2ZW5JbmRleFNhbXBsZSIsImN1cnJPZGRJbmRleFNhbXBsZSIsIm9kZCIsInN1YnRyYWN0aW9uUmVzdWx0IiwiYWRkaXRpb25SZXN1bHQiLCJpZmZ0IiwiY3VycmVudFNhbXBsZSIsImNvbmp1Z2F0ZVNhbXBsZSIsIlgiLCJ2YWwiLCJmZnRfMSIsIk1leWRhQW5hbHl6ZXIiLCJvcHRpb25zIiwiX3RoaXMiLCJfdGhpc18xIiwiX20iLCJhdWRpb0NvbnRleHQiLCJlcnJvcnMiLCJub0FDIiwiX2Vycm9ycyIsIm5vdFBvdzIiLCJzb3VyY2UiLCJub1NvdXJjZSIsImhvcFNpemUiLCJjYWxsYmFjayIsIndpbmRvd2luZ0Z1bmN0aW9uIiwiZmVhdHVyZUV4dHJhY3RvcnMiLCJFWFRSQUNUSU9OX1NUQVJURUQiLCJzdGFydEltbWVkaWF0ZWx5IiwiY2hhbm5lbCIsImlucHV0cyIsIm91dHB1dHMiLCJzcG4iLCJjcmVhdGVTY3JpcHRQcm9jZXNzb3IiLCJjb25uZWN0IiwiZGVzdGluYXRpb24iLCJfZmVhdHVyZXNUb0V4dHJhY3QiLCJpbnB1dERhdGEiLCJwcmV2aW91c0lucHV0RGF0YSIsInByZXZpb3VzRnJhbWUiLCJzZXRTb3VyY2UiLCJvbmF1ZGlvcHJvY2VzcyIsImlucHV0QnVmZmVyIiwiZ2V0Q2hhbm5lbERhdGEiLCJzZXQiLCJmcmFtZXMiLCJmIiwiZmVhdHVyZXMiLCJleHRyYWN0Iiwic3RhcnQiLCJzdG9wIiwiZGlzY29ubmVjdCIsInNldENoYW5uZWwiLCJjb25zb2xlIiwiZXJyb3IiLCJnZXQiLCJNZXlkYSIsImNocm9tYUJhbmRzIiwiZmVhdHVyZVVuZGVmIiwiaW52YWxpZEZlYXR1cmVGbXQiLCJpbnZhbGlkSW5wdXQiLCJjcmVhdGVNZXlkYUFuYWx5emVyIiwibGlzdEF2YWlsYWJsZUZlYXR1cmVFeHRyYWN0b3JzIiwiZmVhdHVyZSIsInByZXBhcmVkU2lnbmFsIiwicHJlcGFyZVNpZ25hbFdpdGhTcGVjdHJ1bSIsIndpbmRvd2VkU2lnbmFsIiwicHJlcGFyZWRTaWduYWxfMSIsInByZXZpb3VzQ29tcGxleFNwZWN0cnVtIiwicHJldmlvdXNBbXBTcGVjdHJ1bSIsImVsIiwiYXNzaWduIiwia2V5cyIsIndpbmRvdyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/meyda@5.6.3_rollup@4.44.1/node_modules/meyda/dist/node/main.js\n");

/***/ })

};
;