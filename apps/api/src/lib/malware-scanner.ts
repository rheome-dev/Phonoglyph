import { createHash } from 'crypto';
import { ScanResult } from './file-validation';

/**
 * Malware scanning service with heuristic analysis
 * In production, this would integrate with ClamAV, VirusTotal, or similar services
 */
export class MalwareScanner {
  private static readonly KNOWN_MALWARE_HASHES = new Set([
    // Add known malware file hashes here
    // These would be updated from threat intelligence feeds
  ]);

  private static readonly SUSPICIOUS_PATTERNS = [
    // Script injection patterns
    { pattern: /<script[\s\S]*?>[\s\S]*?<\/script>/gi, name: 'HTML Script Tag', severity: 'high' as const },
    { pattern: /javascript:/gi, name: 'JavaScript Protocol', severity: 'medium' as const },
    { pattern: /eval\s*\(/gi, name: 'JavaScript eval()', severity: 'high' as const },
    { pattern: /document\.write/gi, name: 'Document.write', severity: 'medium' as const },
    
    // Server-side script patterns
    { pattern: /<\?php/gi, name: 'PHP Code', severity: 'high' as const },
    { pattern: /<\?=/gi, name: 'PHP Short Tag', severity: 'high' as const },
    { pattern: /<%[\s\S]*?%>/gi, name: 'ASP/JSP Code', severity: 'high' as const },
    
    // Shell command patterns
    { pattern: /#!/gi, name: 'Shebang (Script)', severity: 'medium' as const },
    { pattern: /\$\(.*\)/gi, name: 'Command Substitution', severity: 'medium' as const },
    { pattern: /`.*`/gi, name: 'Backtick Command', severity: 'medium' as const },
    
    // SQL injection patterns
    { pattern: /union\s+select/gi, name: 'SQL Union Select', severity: 'high' as const },
    { pattern: /drop\s+table/gi, name: 'SQL Drop Table', severity: 'high' as const },
    { pattern: /insert\s+into/gi, name: 'SQL Insert', severity: 'medium' as const },
    
    // File inclusion patterns
    { pattern: /include\s*\(/gi, name: 'File Include', severity: 'medium' as const },
    { pattern: /require\s*\(/gi, name: 'File Require', severity: 'medium' as const },
    { pattern: /\.\.\/.*\.\./gi, name: 'Path Traversal', severity: 'high' as const },
    
    // Suspicious URLs and domains
    { pattern: /https?:\/\/[a-z0-9.-]+\.tk\//gi, name: 'Suspicious TLD (.tk)', severity: 'medium' as const },
    { pattern: /https?:\/\/[a-z0-9.-]+\.ml\//gi, name: 'Suspicious TLD (.ml)', severity: 'medium' as const },
    { pattern: /bit\.ly|tinyurl|t\.co/gi, name: 'URL Shortener', severity: 'low' as const },
    
    // Obfuscation patterns
    { pattern: /String\.fromCharCode/gi, name: 'Character Code Obfuscation', severity: 'medium' as const },
    { pattern: /unescape\(/gi, name: 'URL Unescape', severity: 'medium' as const },
    { pattern: /atob\(/gi, name: 'Base64 Decode', severity: 'low' as const },
    
    // Cryptocurrency mining patterns
    { pattern: /coinhive|cryptoloot|jsecoin/gi, name: 'Cryptocurrency Miner', severity: 'high' as const },
    { pattern: /stratum\+tcp/gi, name: 'Mining Pool Connection', severity: 'high' as const },
  ];

  private static readonly EXECUTABLE_SIGNATURES = [
    { signature: [0x4d, 0x5a], name: 'PE Executable (Windows)', severity: 'critical' as const },
    { signature: [0x7f, 0x45, 0x4c, 0x46], name: 'ELF Executable (Linux)', severity: 'critical' as const },
    { signature: [0xfe, 0xed, 0xfa, 0xce], name: 'Mach-O Executable (macOS)', severity: 'critical' as const },
    { signature: [0xca, 0xfe, 0xba, 0xbe], name: 'Java Class File', severity: 'high' as const },
    { signature: [0x50, 0x4b, 0x03, 0x04], name: 'ZIP Archive (Potential)', severity: 'medium' as const },
    { signature: [0x52, 0x61, 0x72, 0x21], name: 'RAR Archive', severity: 'medium' as const },
  ];

  /**
   * Scan buffer for malware using multiple detection methods
   */
  static async scanBuffer(buffer: Buffer): Promise<ScanResult> {
    const startTime = Date.now();
    const threats: ScanResult['threats'] = [];

    try {
      // 1. Hash-based detection
      const hashThreats = await this.scanByHash(buffer);
      threats.push(...hashThreats);

      // 2. Signature-based detection
      const signatureThreats = this.scanBySignature(buffer);
      threats.push(...signatureThreats);

      // 3. Pattern-based detection
      const patternThreats = this.scanByPattern(buffer);
      threats.push(...patternThreats);

      // 4. Heuristic analysis
      const heuristicThreats = this.heuristicAnalysis(buffer);
      threats.push(...heuristicThreats);

      const scanTime = Date.now() - startTime;

      return {
        isClean: threats.length === 0,
        threats,
        scanTime
      };

    } catch (error) {
      console.error('Malware scan failed:', error);
      
      // Fail securely - assume threat if scan fails
      return {
        isClean: false,
        threats: [{
          name: 'Scan Failure',
          type: 'scan_error',
          severity: 'high'
        }],
        scanTime: Date.now() - startTime
      };
    }
  }

  /**
   * Hash-based malware detection
   */
  private static async scanByHash(buffer: Buffer): Promise<ScanResult['threats']> {
    const threats: ScanResult['threats'] = [];
    
    // Calculate file hash
    const sha256 = createHash('sha256').update(buffer).digest('hex');
    const md5 = createHash('md5').update(buffer).digest('hex');
    
    // Check against known malware hashes
    if (this.KNOWN_MALWARE_HASHES.has(sha256) || this.KNOWN_MALWARE_HASHES.has(md5)) {
      threats.push({
        name: 'Known Malware Hash',
        type: 'hash_match',
        severity: 'critical'
      });
    }
    
    return threats;
  }

  /**
   * Signature-based detection for executable files
   */
  private static scanBySignature(buffer: Buffer): ScanResult['threats'] {
    const threats: ScanResult['threats'] = [];
    const uint8Array = new Uint8Array(buffer.slice(0, 16));
    
    for (const { signature, name, severity } of this.EXECUTABLE_SIGNATURES) {
      if (signature.every((byte, index) => uint8Array[index] === byte)) {
        threats.push({
          name,
          type: 'executable_signature',
          severity
        });
      }
    }
    
    return threats;
  }

  /**
   * Pattern-based detection for embedded scripts and malicious content
   */
  private static scanByPattern(buffer: Buffer): ScanResult['threats'] {
    const threats: ScanResult['threats'] = [];
    const content = buffer.toString('utf8', 0, Math.min(buffer.length, 1024 * 1024)); // First 1MB only
    
    for (const { pattern, name, severity } of this.SUSPICIOUS_PATTERNS) {
      if (pattern.test(content)) {
        threats.push({
          name,
          type: 'pattern_match',
          severity
        });
      }
    }
    
    return threats;
  }

  /**
   * Heuristic analysis for suspicious characteristics
   */
  private static heuristicAnalysis(buffer: Buffer): ScanResult['threats'] {
    const threats: ScanResult['threats'] = [];
    
    // Check for high entropy (possible encryption/obfuscation)
    const entropy = this.calculateEntropy(buffer);
    if (entropy > 7.5) {
      threats.push({
        name: 'High Entropy Content',
        type: 'heuristic',
        severity: 'medium'
      });
    }
    
    // Check for suspicious file size patterns
    if (buffer.length < 100) {
      threats.push({
        name: 'Suspiciously Small File',
        type: 'heuristic',
        severity: 'low'
      });
    }
    
    // Check for null bytes in text content (possible binary injection)
    const nullByteCount = buffer.filter(byte => byte === 0).length;
    const nullByteRatio = nullByteCount / buffer.length;
    if (nullByteRatio > 0.1 && nullByteRatio < 0.9) {
      threats.push({
        name: 'Mixed Binary/Text Content',
        type: 'heuristic',
        severity: 'medium'
      });
    }
    
    return threats;
  }

  /**
   * Calculate Shannon entropy of buffer
   */
  private static calculateEntropy(buffer: Buffer): number {
    const frequencies = new Array(256).fill(0);
    
    // Count byte frequencies
    for (const byte of buffer) {
      frequencies[byte]++;
    }
    
    // Calculate entropy
    let entropy = 0;
    const length = buffer.length;
    
    for (const freq of frequencies) {
      if (freq > 0) {
        const probability = freq / length;
        entropy -= probability * Math.log2(probability);
      }
    }
    
    return entropy;
  }

  /**
   * Update malware signatures (would be called periodically in production)
   */
  static async updateSignatures(): Promise<void> {
    // In production, this would fetch updates from threat intelligence feeds
    console.info('Malware signatures update check completed');
  }

  /**
   * Get scanner statistics
   */
  static getStats(): {
    knownMalwareHashes: number;
    suspiciousPatterns: number;
    executableSignatures: number;
  } {
    return {
      knownMalwareHashes: this.KNOWN_MALWARE_HASHES.size,
      suspiciousPatterns: this.SUSPICIOUS_PATTERNS.length,
      executableSignatures: this.EXECUTABLE_SIGNATURES.length
    };
  }
}
